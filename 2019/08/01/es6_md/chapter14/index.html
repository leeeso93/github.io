<!DOCTYPE html>
<html>

<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
<title>chapter14. 비동기적 프로그래밍 - Hexo</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta name="description" content="자바스크립트는 기본적으로  단일 스레드에서 동작한다. 즉 한 번에 한 가지 일만 할 수 있다.자바스크립트에서는 매우 일찍부터 비동기적 실행 매커니즘이 존재했지만, 필요한 장치가 추가되었다. 콜백, 프라미스, 제너레이터가 그것이다.제너레이터는 비동기적 프로그래밍을 전혀 지원하지 않으므로 비동기적으로 쓰기 위해 프라미스나 특수한 콜백과 함께 사용해야한다.사용">
<meta property="og:type" content="article">
<meta property="og:title" content="chapter14. 비동기적 프로그래밍">
<meta property="og:url" content="http://yoursite.com/2019/08/01/es6_md/chapter14/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="자바스크립트는 기본적으로  단일 스레드에서 동작한다. 즉 한 번에 한 가지 일만 할 수 있다.자바스크립트에서는 매우 일찍부터 비동기적 실행 매커니즘이 존재했지만, 필요한 장치가 추가되었다. 콜백, 프라미스, 제너레이터가 그것이다.제너레이터는 비동기적 프로그래밍을 전혀 지원하지 않으므로 비동기적으로 쓰기 위해 프라미스나 특수한 콜백과 함께 사용해야한다.사용">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/images/og_image.png">
<meta property="og:updated_time" content="2019-10-20T13:33:21.433Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="chapter14. 비동기적 프로그래밍">
<meta name="twitter:description" content="자바스크립트는 기본적으로  단일 스레드에서 동작한다. 즉 한 번에 한 가지 일만 할 수 있다.자바스크립트에서는 매우 일찍부터 비동기적 실행 매커니즘이 존재했지만, 필요한 장치가 추가되었다. 콜백, 프라미스, 제너레이터가 그것이다.제너레이터는 비동기적 프로그래밍을 전혀 지원하지 않으므로 비동기적으로 쓰기 위해 프라미스나 특수한 콜백과 함께 사용해야한다.사용">
<meta name="twitter:image" content="http://yoursite.com/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>

<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="chapter14. 비동기적 프로그래밍" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">Home</a>
                
                <a class="navbar-item" href="/archives">Archives</a>
                
                <a class="navbar-item" href="/categories">Categories</a>
                
                <a class="navbar-item" href="/tags">Tags</a>
                
                <a class="navbar-item" href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/leeeso93">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="Catálogo" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-12-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-07-31T15:00:00.000Z">2019-08-01</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/러닝자바스크립트/">러닝자바스크립트</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    25 minutes read (About 3685 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                chapter14. 비동기적 프로그래밍
            
        </h1>
        <div class="content">
            <blockquote>
<p>자바스크립트는 기본적으로  단일 스레드에서 동작한다. 즉 한 번에 한 가지 일만 할 수 있다.<br>자바스크립트에서는 매우 일찍부터 비동기적 실행 매커니즘이 존재했지만, 필요한 장치가 추가되었다. <strong>콜백, 프라미스, 제너레이터</strong>가 그것이다.<br>제너레이터는 비동기적 프로그래밍을 전혀 지원하지 않으므로 비동기적으로 쓰기 위해 프라미스나 특수한 콜백과 함께 사용해야한다.<br>사용자 입력 외에, 비동기적 테크닉을 사용해야 하는 경우는 크게 세 가지가 있다.</p>
<ul>
<li>Ajax 호출을 비롯한 네트워크 요청</li>
<li>파일을 읽고 쓰는 등의 파일시스템 작업</li>
<li>의도적으로 시간 지연을 사용하는 기능(알림 등)</li>
</ul>
</blockquote>
<a id="more"></a>

<h2 id="14-1-비유"><a href="#14-1-비유" class="headerlink" title="14.1 비유"></a>14.1 비유</h2><blockquote>
<p>분주한 음식점에서 전화번호를 받아서 자리가 나면 알려줌 : 콜백<br>음식점에 자리가 났을 떄 진동하는 호출기를 넘겨줌 - 프라미스 </p>
</blockquote>
<h2 id="14-2-콜백"><a href="#14-2-콜백" class="headerlink" title="14.2 콜백"></a>14.2 콜백</h2><blockquote>
<p><strong>콜백</strong>은 자바스크립트에서 가장 오래된 비동기적 매커니즘이다.<br>콜백이란 나중에 호출할 함수이다.<br>콜백 함수는 일반적으로 다른 함수에 넘기거나, 객체의 프로퍼티로 사용한다. 배열에 넣어서 쓰기도한다. 대게 익명 함수로 사용한다.</p>
</blockquote>
<figure class="highlight javascript hljs"><figcaption><span>setTimeOut</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// ## 14.2 콜백</span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"before setTimeout "</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"After setTimeout "</span>+ <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(f, <span class="hljs-number">60</span> *<span class="hljs-number">1000</span>); <span class="hljs-comment">// 1분 </span></span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"i happen after setTimeout"</span>);</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"me too"</span>);</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">before setTimeout Thu Aug 01 2019 21:10:46 GMT+0900 (GMT+09:00)</span></span><br><span class="line"><span class="hljs-comment">i happen after setTimeout</span></span><br><span class="line"><span class="hljs-comment">me too</span></span><br><span class="line"><span class="hljs-comment">After setTimeout Thu Aug 01 2019 21:11:46 GMT+0900 (GMT+09:00)</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br></pre></td></tr></table></figure>

<pre>
작성하는 코드와 실제 실행되는 코드가 다르다.
비동기적 실행의 가장 중요한 점은 어떤 것도 차단하지 않는다는 것
자바스크립트는 싱글 스레드를 사용하므로, 
컴퓨터에 60초 동안 대기한 후 코드를 실행하게되면 프로그램이 멈추고,
사용자 입력을 받아들이지 않는 등의 문제가 발생한다.
위 예제는 이름 붙은 함수 f를 setTimeout에 넘겼으나, 
이름을 쓸 이유가 없다면 일반적으로 익명 함수를 사용한다.
</pre>

<figure class="highlight javascript hljs"><figcaption><span>setTimeOut 익명함수</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"After TimeOut "</span>+ <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() ,<span class="hljs-number">6000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="14-2-1-setInterval-과-clearInterval"><a href="#14-2-1-setInterval-과-clearInterval" class="headerlink" title="14.2.1 setInterval 과 clearInterval"></a>14.2.1 setInterval 과 clearInterval</h2><blockquote>
<p>setTimeout은 콜백 함수를 한 번만 실행하고 멈추지만,<br>setInterval은 콜백을 정해진 주기마다 호출하며 clearInterval을 사용할 때까지 멈ㅊ지 않는다. </p>
</blockquote>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//분이 넘어거거나 10회째가 될 때까지 5초마다 콜백 실행</span></span><br><span class="line"><span class="hljs-keyword">const</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><br><span class="line"><span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">const</span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</span><br><span class="line">    <span class="hljs-keyword">if</span>(now.getMinutes() !== start.getMinutes() || ++i &gt;<span class="hljs-number">10</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> clearInterval(intervalId);</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;i&#125;</span>:<span class="hljs-subst">$&#123;now&#125;</span>`</span>);</span><br><span class="line">&#125;,<span class="hljs-number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment"> 1:Fri Aug 02 2019 13:59:47 GMT+0900 (한국 표준시)</span></span><br><span class="line"><span class="hljs-comment"> 2:Fri Aug 02 2019 13:59:52 GMT+0900 (한국 표준시)</span></span><br><span class="line"><span class="hljs-comment"> 3:Fri Aug 02 2019 13:59:57 GMT+0900 (한국 표준시)</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br></pre></td></tr></table></figure>

<pre>
setInterval이 ID 값을 반환하므로 이 ID를 써서 실행을 멈출 수 있다.
clearInterval이 반환하는 ID값을 받아 타임아웃을 종료
</pre>

<h2 id="14-2-2-스코프와-비동기적-실행"><a href="#14-2-2-스코프와-비동기적-실행" class="headerlink" title="14.2.2 스코프와 비동기적 실행"></a>14.2.2 스코프와 비동기적 실행</h2><blockquote>
<p>비동기적 실행에서 혼란스럽고 에러가 자주 일어나는 부분은 스코프와 클로저가 비동기적 실행에 영향을 미치는 부분이다.<br>함수를 호출하면 항상 클로저가 만들어진다. 매개변수를 포함해 함수 안에서 만든 변수는 모두 무언가가 자신에 접근 할 수 있는한 계속 존재</p>
</blockquote>
<figure class="highlight javascript hljs"><figcaption><span>countdown 오류</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//5초 카운트 다운</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countdown</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> i; <span class="hljs-comment">//i를 for 루프 밖에서 실행</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Countdown"</span>);</span><br><span class="line">    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">5</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;</span><br><span class="line">        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">            <span class="hljs-built_in">console</span>.log(i===<span class="hljs-number">0</span> ? <span class="hljs-string">"Go"</span>:i)</span><br><span class="line">        &#125;,(<span class="hljs-number">5</span>-i)*<span class="hljs-number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">countdown();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//-1이 6번 나옴</span></span><br></pre></td></tr></table></figure>

<pre>
var가 아닌 let 변수를 for 루프 밖에서 선언했으므로 같은 문제가 발생한다. 즉 for 루프가 실행을 마치고, i의 값이 -1이 된 다음에야 콜백이 실행된다. 
여기서 i는 두 가지 방법으로 사용됬다.
1. (5-i)이는 첫번째 타임아웃 : 0 , 두번쨰 : 1000, 세번쨰 : 2000
이렇게 동기적으로 실행된다.
</pre>

<figure class="highlight javascript hljs"><figcaption><span>countdown 문제해결</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//1. 즉시표현식</span></span><br><span class="line"><span class="hljs-keyword">var</span> count= <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Countdown"</span>);</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">5</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;</span><br><span class="line">        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">            <span class="hljs-built_in">console</span>.log(i===<span class="hljs-number">0</span> ? <span class="hljs-string">"Go"</span>:i)</span><br><span class="line">        &#125;,(<span class="hljs-number">5</span>-i)*<span class="hljs-number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//2. for 루프 안에 let i 선언</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countdown</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-comment">//  let i; i를 for 루프 밖에서 실행</span></span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Countdown"</span>);</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">5</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;</span><br><span class="line">        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">            <span class="hljs-built_in">console</span>.log(i===<span class="hljs-number">0</span> ? <span class="hljs-string">"Go"</span>:i)</span><br><span class="line">        &#125;,(<span class="hljs-number">5</span>-i)*<span class="hljs-number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">countdown();</span><br></pre></td></tr></table></figure>

<pre>
 즉시 호출하는 함수 표현식(IIFE)를 쓰거나, 
 더 간단하게는 for 루프 선언부에서 let i 를 쓰는 방식으로 해결 가능 
 콜백은 자신을 선언한 스코프(클로저)에 있는 것에 접근 할 수 있다. 그러므로 i의 값은 콜백이 실행되는 순간마다 다를 수 있다.
 이 원칙은 모든 비동기적 테크닉에 적용된다.
</pre>

<h2 id="14-2-3-우선-오류-콜백"><a href="#14-2-3-우선-오류-콜백" class="headerlink" title="14.2.3 우선 오류 콜백"></a>14.2.3 우선 오류 콜백</h2><blockquote>
<p><strong>우선 오류 콜백</strong> : 콜백을 사용하면 예외 처리가 어려워 지므로, 콜백과 관련된 에러를 처리할 표준이 필요<br>이에 따라 콜백의 첫 번쨰 매개변수에 에러 객체를 쓰자는 것이 등장<br>에러가 null이나 undefined 이면 에러가 없는 것<br>우선 오류 콜백에서 가장 먼저 생각할 것은<br><span class="bg-yellow">에러 매개변수를 체크하고 그에 맞게 반응한다는 것</span></p>
</blockquote>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//노드에서 파일 콘텐츠를 읽을 떄 우선 오류 콜백을 사용할 경우</span></span><br><span class="line"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> fname = <span class="hljs-string">'may_or_may_not_exist.txt'</span>;</span><br><span class="line">fs.readFile(fname, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err,data</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`error reading file <span class="hljs-subst">$&#123;fname&#125;</span>:<span class="hljs-subst">$&#123;err.message&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<pre>
콜백에서 가장 먼저 하는 일은 err 가 참 같은 값인지 확인하는 것
err가 참 같은 값이면 파일을 읽는 데 문제가 있다는 뜻이므로 콘솔에 오류를 보고하고 즉시 빠져나옵니다.
우선 오류 콜백을 사용할때 많이 하는 실수는 빠져나와야 한다는 사실을 잊는 다는 것 
프라미스를 사용하지 않으면 우선 오류 콜백은 노드 개발의 표준이나 다름없음
</pre>

<h2 id="14-2-4-콜백-헬"><a href="#14-2-4-콜백-헬" class="headerlink" title="14.2.4 콜백 헬"></a>14.2.4 콜백 헬</h2><blockquote>
<p><strong>콜백 헬</strong> : 중괄호로 둘러쌓여 끝없이 중첩된 삼각형의 코드 블록</p>
</blockquote>
<h2 id="14-3-프라미스"><a href="#14-3-프라미스" class="headerlink" title="14.3 프라미스"></a>14.3 프라미스</h2><blockquote>
<p><strong>프라미스</strong> : 콜백의 단점을 해결하려는 시도에서 만들어짐<br>프라미스가 콜백을 대체하는 것은 아니다. </p>
<ul>
<li>프라미스는 콜백을 예측 가능한 패턴으로 사용할 수 있게 한다.</li>
<li>프라미스 기반 비동기 함수를 호출하면 그 함수는 promise 인스턴스를 반환</li>
<li>성공(fulfilled)하거나, 실패(rejected) 하는 단 두가지 뿐 </li>
<li>성공한 프라미스가 나중에 실패할 일 같은 경우는 없음</li>
<li>단 한번만 일어난다. -&gt; 그 프라미스를 결졍됐다(settled)고 한다.</li>
<li>프라미스는 객체이므로 어디든 전달 할수 있다.<br>(음식점에서 받은 예약 호출기를 친구에게 맡기는 것과 비슷)</li>
</ul>
</blockquote>
<h2 id="14-3-1-프라미스-만들기"><a href="#14-3-1-프라미스-만들기" class="headerlink" title="14.3.1 프라미스 만들기"></a>14.3.1 프라미스 만들기</h2><blockquote>
<p>성공(resolve)와 실패(reject) 콜백이 있는 함수로 새 promise 인스턴스를 만들기만 하면 된다.</p>
</blockquote>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 5초 카운트 다운에 매이지 않고, 카운트가 끝나면 프라미스를 반환</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countdown</span>(<span class="hljs-params">seconds</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =seconds; i&gt;=<span class="hljs-number">0</span>; i--)&#123;</span><br><span class="line">            setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">"..."</span>);</span><br><span class="line">                <span class="hljs-keyword">else</span> resolve(<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"GO"</span>));</span><br><span class="line">            &#125;,(seconds-i)*<span class="hljs-number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">결과</span></span><br><span class="line"><span class="hljs-comment">5...</span></span><br><span class="line"><span class="hljs-comment">4...</span></span><br><span class="line"><span class="hljs-comment">3...</span></span><br><span class="line"><span class="hljs-comment">2...</span></span><br><span class="line"><span class="hljs-comment">1...</span></span><br><span class="line"><span class="hljs-comment">GO</span></span><br><span class="line"><span class="hljs-comment"></span></span><br><span class="line"><span class="hljs-comment">만약 이 함수가 실패하면 "GO"를 반환</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br></pre></td></tr></table></figure>

<pre>
resolve와 reject는 함수이다. resolve를 여러번 호출해도 결과는 같다.
첫 번째로 호출한 것만 의미 있다.
프라미스는 성공 또는 실패를 나타낼 뿐이다.
</pre>

<h2 id="14-3-2-프라미스-사용"><a href="#14-3-2-프라미스-사용" class="headerlink" title="14.3.2 프라미스 사용"></a>14.3.2 프라미스 사용</h2><figure class="highlight javascript hljs"><figcaption><span>프라미스 사용(카운트다운)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//13을 만나면 에러를 내는 함수</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countdown</span>(<span class="hljs-params">seconds</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =seconds; i&gt;=<span class="hljs-number">0</span>; i--)&#123;</span><br><span class="line">            setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(i === <span class="hljs-number">13</span>) <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"oh my god"</span>)); </span><br><span class="line">                <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">"..."</span>);</span><br><span class="line">                <span class="hljs-keyword">else</span> resolve(<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"GO"</span>));</span><br><span class="line">            &#125;,(seconds-i)*<span class="hljs-number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">15...</span></span><br><span class="line"><span class="hljs-comment">14...</span></span><br><span class="line"><span class="hljs-comment">Uncaught (in promise) Error: oh my god</span></span><br><span class="line"><span class="hljs-comment">12...</span></span><br><span class="line"><span class="hljs-comment">11...</span></span><br><span class="line"><span class="hljs-comment">10... </span></span><br><span class="line"><span class="hljs-comment">9...</span></span><br><span class="line"><span class="hljs-comment"></span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br></pre></td></tr></table></figure>

<pre>
13에서 에러가 발생, 그러나 콘솔에는 12부터 다시 카운트를 기록한다.
reject나 resolve가 함수를 멈추지는 않는다. 그저 프라미스의 상태를 관리할 뿐이다.
즉, 프라미스는 비동기적 작업이 성공 또는 실패하도록 확정하지만, 
현재는 진행 상황을 전혀 알려주지 않는다. 
즉, 프라미스는 완료되거나 파기될 뿐 50% 진행되었다.라는 개념자체가 없다.
</pre>

<h2 id="14-3-3-이벤트"><a href="#14-3-3-이벤트" class="headerlink" title="14.3.3 이벤트"></a>14.3.3 이벤트</h2><blockquote>
<p>이벤트가 일어나면 이벤트 발생을 담당하는 개체(emitter)에서 이벤트가 일어났음을 알린다.<br>필요한 이벤트는 모두 주시(listen)할 수 있다. 콜백을 통해서 가능<br>노드에서 이벤트를 지원하는 모듈 EventEmitter가 내장됨<br>EventEmitter는 클래스와 함께 사용하도록 설계</p>
</blockquote>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//countdown 함수를 countdown 클래스로 변경</span></span><br><span class="line"><span class="hljs-keyword">const</span> EventEmitter = <span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>).EventEmitter;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Countdown</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EventEmitter</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">constructor</span>(seconds,superstitious)&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>();</span><br><span class="line">        <span class="hljs-keyword">this</span>.seconds = seconds;</span><br><span class="line">        <span class="hljs-keyword">this</span>.superstitious = !!superstitious;</span><br><span class="line">    &#125;</span><br><span class="line">    go()&#123;</span><br><span class="line">        <span class="hljs-keyword">const</span> countdown = <span class="hljs-keyword">this</span>;</span><br><span class="line">        <span class="hljs-keyword">const</span> timeoutIds = [];</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = countdown.seconds; i&gt;=<span class="hljs-number">0</span>; i--)&#123;</span><br><span class="line">               timeoutIds.push(setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">                   <span class="hljs-keyword">if</span>(countdown.superstitious &amp;&amp; i ===<span class="hljs-number">13</span>)&#123;</span><br><span class="line">                        <span class="hljs-comment">//대기중인 타임아웃을 모두 취소</span></span><br><span class="line">                        timeoutIds.forEach(clearTimeout);</span><br><span class="line">                        <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'oh my god'</span>));</span><br><span class="line">                   &#125;</span><br><span class="line">                   countdown.emit(<span class="hljs-string">'trick'</span>,i);</span><br><span class="line">                   <span class="hljs-keyword">if</span>(i === <span class="hljs-number">0</span>) resolve();</span><br><span class="line">               &#125;,(countdown.seconds-i)*<span class="hljs-number">1000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//카운트다운 사용</span></span><br><span class="line"><span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> Countdown(<span class="hljs-number">5</span>);</span><br><span class="line">c.on(<span class="hljs-string">'trick'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>) <span class="hljs-built_in">console</span>.log(i+<span class="hljs-string">"..."</span>);</span><br><span class="line">&#125;);</span><br><span class="line">c.go().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'go'</span>);</span><br><span class="line">&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<pre>
EventEmitter를 상속하는 클래스는 이벤트를 발생시킬 수 있다.
실제 카운트다운을 시작하고 프라미스를 반환하는 부분은 go 메서드이다.
go메서드에서 
1) const countdown = this; 즉 countdown에 this를 할당
2) 카운트가 얼마나 남았는지 알려면 this 값을 알아야한다.
</pre>

<h2 id="14-3-4-프라미스-체인"><a href="#14-3-4-프라미스-체인" class="headerlink" title="14.3.4 프라미스 체인"></a>14.3.4 프라미스 체인</h2><blockquote>
<p>프라미스에는 체인으로 연결할 수 있다는 장점이 존재<br>프라미스가 완료되면 다른 프라미스를 반환하는 함수를 즉시 호출 가능</p>
</blockquote>
<figure class="highlight javascript hljs"><figcaption><span>프라미스 체인</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">launch</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Lift off"</span>);</span><br><span class="line">        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">            resolve(<span class="hljs-string">"in orbit"</span>);</span><br><span class="line">        &#125;,<span class="hljs-number">5</span>*<span class="hljs-number">1000</span>); <span class="hljs-comment">//2초만에 궤도도달</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//이 함수를 카운트다운에 쉽게 묶을 수 있다.</span></span><br><span class="line"><span class="hljs-keyword">const</span> c = <span class="hljs-keyword">new</span> Countdown(<span class="hljs-number">5</span>).on(<span class="hljs-string">'trick'</span>,i =&gt; <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">"..."</span>));</span><br><span class="line"></span><br><span class="line">c.go().then(launch).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(msg);</span><br><span class="line">&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"houston, we have a problem..."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<pre>
프라미스 체인을 사용하면 모든 단계에서 에러를 캐치할 필요가 없다.
체인 어디서든 에러가 생기면 체인 전체가 멈추고 catch 핸들러가 동작한다.
</pre>


<h2 id="14-3-5-결졍되지-않는-프라미스-방지하기"><a href="#14-3-5-결졍되지-않는-프라미스-방지하기" class="headerlink" title="14.3.5 결졍되지 않는 프라미스 방지하기"></a>14.3.5 결졍되지 않는 프라미스 방지하기</h2><blockquote>
<p>프라미스는 비동기적 코드를 단순화하고 콜백이 두 번 이상 실행되는 문제를 방지<br>하지만, reslove나 reject를 호출하는 걸 잊어서 프라미스가 결정되지 않는 문제까지 자동으로 해결하지는 못함<br>결정되지 않는 프라미스를 방지하는 방법은 프라미스에 타임아웃을 거는 것</p>
</blockquote>
<h2 id="14-4-제너레이터"><a href="#14-4-제너레이터" class="headerlink" title="14.4 제너레이터"></a>14.4 제너레이터</h2><blockquote>
<p>제너레이터는 함수와 호출자 사이의 양방향 통신을 가능하게 함.<br>제너레이터는 동기적 성격을 지녔지만, 프라미스와 결합하면 비동기 코드를<br>효율적으로 관리 가능</p>
</blockquote>
<figure class="highlight javascript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//파일 3개를 읽고 1분간 기다린 다음 그 내용을 합쳐서 네 번째 파일에 작성</span></span><br><span class="line"><span class="hljs-comment">//1. 노드의 콜백 오류를 프라미스로 바꾸기 </span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nfcall</span>(<span class="hljs-params">f,...args</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        f.call(<span class="hljs-literal">null</span>,...args,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err,...args</span>)</span>&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(err) <span class="hljs-keyword">return</span> reject(err);</span><br><span class="line">            resolve(args.length&lt;<span class="hljs-number">2</span> ? args[<span class="hljs-number">0</span>]:args);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//2. setTimeout을 써야하는데, 이는 오류 우선 콜백 패턴을 따르지 않으므로 같은 기능을 가진 ptimeout(promise timeout) 함수를 만든다.</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ptimeout</span>(<span class="hljs-params">delay</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        setTimeout(resolve,delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//3. 제너레이터 실행기</span></span><br><span class="line"><span class="hljs-comment">// 제너레이터는 동기적이지만, 호출자와 통신 가능하므로 제너레이터와의 통신을 관리하고, 비동기적 호출을 처리하는 함수 grun을 만듬 </span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grun</span>(<span class="hljs-params">g</span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> it = g();</span><br><span class="line">    (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">iterate</span>(<span class="hljs-params">val</span>)</span>&#123;</span><br><span class="line">        <span class="hljs-keyword">const</span> x = it.next(val);</span><br><span class="line">        <span class="hljs-keyword">if</span>(!x.done)&#123;</span><br><span class="line">            <span class="hljs-keyword">if</span>(x.value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>)&#123;</span><br><span class="line">                x.value.then(iterate).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> it.throw(err));</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                setTimeout(iterate,<span class="hljs-number">0</span>,x.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//grun은 제너레이터 실행기이고, yield로 값을 넘긴 제너레이터는 이터레이터에서 next를 호출할 때까지 기다린다. </span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">theFutureIsNow</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">const</span> dataA = <span class="hljs-keyword">yield</span> nfcall(fs,readFile, <span class="hljs-string">"a.txt"</span>);</span><br><span class="line">    <span class="hljs-keyword">const</span> dataB = <span class="hljs-keyword">yield</span> nfcall(fs,readFile, <span class="hljs-string">"b.txt"</span>);</span><br><span class="line">    <span class="hljs-keyword">const</span> dataC = <span class="hljs-keyword">yield</span> nfcall(fs,readFile, <span class="hljs-string">"c.txt"</span>);</span><br><span class="line">    <span class="hljs-keyword">yield</span> ptimeout(<span class="hljs-number">60</span>*<span class="hljs-number">1000</span>);</span><br><span class="line">    <span class="hljs-keyword">yield</span> nfcall(fs.writeFile,<span class="hljs-string">"d.txt"</span>,dataA + dataB + dataC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grun(theFutureIsNow);</span><br></pre></td></tr></table></figure>

<h2 id="14-4-2-제너레이터-실행기를-직접-만들지-마세요"><a href="#14-4-2-제너레이터-실행기를-직접-만들지-마세요" class="headerlink" title="14.4.2 제너레이터 실행기를 직접 만들지 마세요"></a>14.4.2 제너레이터 실행기를 직접 만들지 마세요</h2><p>co(link: <a href="https://github.com/tj/co" target="_blank" rel="noopener">https://github.com/tj/co</a>)
kos 미들웨어(link: <a href="https://koajs.com/" target="_blank" rel="noopener">https://koajs.com/</a>)</p>
<h2 id="14-4-3-제너레이터-실행기와-예외처리"><a href="#14-4-3-제너레이터-실행기와-예외처리" class="headerlink" title="14.4.3 제너레이터 실행기와 예외처리"></a>14.4.3 제너레이터 실행기와 예외처리</h2><blockquote>
<p>제너레이터 실행기를 쓰면 try/catch를 써서 예외 처리가 가능<br>콜백이나 프라미스를 사용하면 예외 처리가 쉽지 않다.<br>제너레이터 실행기는 비동기적으로 실행하면서도 동기적인 동작 방식을 유지하므로 try/catch문과 함께 쓸 수 있다.</p>
</blockquote>
<figure class="highlight javascript hljs"><figcaption><span>제너레이터 실행기와 예외처리</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">theFutureIsNow</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> data;</span><br><span class="line">    <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">    data = <span class="hljs-keyword">yield</span> <span class="hljs-built_in">Promise</span>.all([</span><br><span class="line">        nfcall(fs.readFile, <span class="hljs-string">"a.txt"</span>),</span><br><span class="line">        nfcall(fs.readFile, <span class="hljs-string">"b.txt"</span>),</span><br><span class="line">        nfcall(fs.readFile, <span class="hljs-string">"c.txt"</span>),</span><br><span class="line">    ]);</span><br><span class="line">    &#125;<span class="hljs-keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"unable to read.."</span> + err.message);</span><br><span class="line">        <span class="hljs-keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">yield</span> ptimeout(<span class="hljs-number">60</span> * <span class="hljs-number">1000</span>);</span><br><span class="line">    <span class="hljs-keyword">try</span>&#123;</span><br><span class="line">       <span class="hljs-keyword">yield</span> nfcall(js.writeFile, <span class="hljs-string">"d.txt"</span>, data[<span class="hljs-number">0</span>] + data[<span class="hljs-number">1</span>] + data[<span class="hljs-number">2</span>]);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="hljs-built_in">console</span>.err(<span class="hljs-string">"unable to write output file"</span>+ err.message);</span><br><span class="line">        <span class="hljs-keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">grun(theFutureIsNow);</span><br></pre></td></tr></table></figure>

<h2 id="14-5-요약"><a href="#14-5-요약" class="headerlink" title="14.5 요약"></a>14.5 요약</h2><blockquote>
<p>요약내용</p>
<ul>
<li>자바스크립트의 비동기적 실행은 콜백을 통해 이루어진다.</li>
<li>프라미스를 콜백 대신 사용할 수 있는 것은 아니다. 프라미스 역시 콜백을 사용</li>
<li>프라미스는 콜백이 여러 번 호출되는 문제를 해결</li>
<li>콜백을 여러 번 호출해야 한다면 이벤트와 결합하는 방법도 있다.<br>(프라미스도 함께 쓸 수 있다.)</li>
<li>프라미시는 반드시 결졍된다는(성공 or 실패한다는) 보장은 없다. 다만 프라미스에 타임아웃을 걸면 이 문제가 해결</li>
<li>프라미스는 체인으로 연결 할 수 있다.</li>
<li>프라미스와 제너레이터 실행기를 결합하면 비동기적 실행의 장점을 유지하면서도 동기적인 사고 방식으로 문제 해결 가능</li>
<li>제너레이터를 써서 동기적인 사고방식으로 문제를 해결 할 땐, 프로그램의 어느 부분에서 동시에 실행할 수 있는지 잘 봐야함. 동시에 실행할 부분은 Promise.all을 써서 실행</li>
<li>제너레이터 실행기 직접 만들지 말기</li>
<li>노드 스타일 콜백을 프라미스로 바꿀 필요도 없다. Q를 써라</li>
<li>제너레이터 실행기를 쓰면 예외 처리도 익숙한 방식으로 할 수 있다.</li>
</ul>
</blockquote>

        </div>
        
        
        
    </div>
</div>





<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2019/08/04/es6_md/chapter15/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">chapter15. 날짜와 시간</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2019/07/31/es6_md/chapter13/">
                <span class="level-item">chapter13. 함수와 추상적 사고</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">Comentarios</h3>
        
<script>
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/08/01/es6_md/chapter14/';
        this.page.identifier = '2019/08/01/es6_md/chapter14/';
    };
    (function() {
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'leeeso93' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>

<div id="disqus_thread">
    
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
    </div>
</div>
</div>
                
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-3 column-right ">
    
    
<div class="card widget" id="toc">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Catálogo
            </h3>
            <ul class="menu-list"><li>
        <a class="is-flex" href="#14-1-비유">
        <span class="has-mr-6">1</span>
        <span>14.1 비유</span>
        </a></li><li>
        <a class="is-flex" href="#14-2-콜백">
        <span class="has-mr-6">2</span>
        <span>14.2 콜백</span>
        </a></li><li>
        <a class="is-flex" href="#14-2-1-setInterval-과-clearInterval">
        <span class="has-mr-6">3</span>
        <span>14.2.1 setInterval 과 clearInterval</span>
        </a></li><li>
        <a class="is-flex" href="#14-2-2-스코프와-비동기적-실행">
        <span class="has-mr-6">4</span>
        <span>14.2.2 스코프와 비동기적 실행</span>
        </a></li><li>
        <a class="is-flex" href="#14-2-3-우선-오류-콜백">
        <span class="has-mr-6">5</span>
        <span>14.2.3 우선 오류 콜백</span>
        </a></li><li>
        <a class="is-flex" href="#14-2-4-콜백-헬">
        <span class="has-mr-6">6</span>
        <span>14.2.4 콜백 헬</span>
        </a></li><li>
        <a class="is-flex" href="#14-3-프라미스">
        <span class="has-mr-6">7</span>
        <span>14.3 프라미스</span>
        </a></li><li>
        <a class="is-flex" href="#14-3-1-프라미스-만들기">
        <span class="has-mr-6">8</span>
        <span>14.3.1 프라미스 만들기</span>
        </a></li><li>
        <a class="is-flex" href="#14-3-2-프라미스-사용">
        <span class="has-mr-6">9</span>
        <span>14.3.2 프라미스 사용</span>
        </a></li><li>
        <a class="is-flex" href="#14-3-3-이벤트">
        <span class="has-mr-6">10</span>
        <span>14.3.3 이벤트</span>
        </a></li><li>
        <a class="is-flex" href="#14-3-4-프라미스-체인">
        <span class="has-mr-6">11</span>
        <span>14.3.4 프라미스 체인</span>
        </a></li><li>
        <a class="is-flex" href="#14-3-5-결졍되지-않는-프라미스-방지하기">
        <span class="has-mr-6">12</span>
        <span>14.3.5 결졍되지 않는 프라미스 방지하기</span>
        </a></li><li>
        <a class="is-flex" href="#14-4-제너레이터">
        <span class="has-mr-6">13</span>
        <span>14.4 제너레이터</span>
        </a></li><li>
        <a class="is-flex" href="#14-4-2-제너레이터-실행기를-직접-만들지-마세요">
        <span class="has-mr-6">14</span>
        <span>14.4.2 제너레이터 실행기를 직접 만들지 마세요</span>
        </a></li><li>
        <a class="is-flex" href="#14-4-3-제너레이터-실행기와-예외처리">
        <span class="has-mr-6">15</span>
        <span>14.4.3 제너레이터 실행기와 예외처리</span>
        </a></li><li>
        <a class="is-flex" href="#14-5-요약">
        <span class="has-mr-6">16</span>
        <span>14.5 요약</span>
        </a></li></ul>
        </div>
    </div>
</div>

    
    
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Categorias
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/ES6/">
            <span class="level-start">
                <span class="level-item">ES6</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/SASS-SCSS/">
            <span class="level-start">
                <span class="level-item">SASS/SCSS</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/hexo/">
            <span class="level-start">
                <span class="level-item">hexo</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/intelliJ/">
            <span class="level-start">
                <span class="level-item">intelliJ</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/러닝자바스크립트/">
            <span class="level-start">
                <span class="level-item">러닝자바스크립트</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">21</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/리액트-react/">
            <span class="level-start">
                <span class="level-item">리액트 / react</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/타입스크립트/">
            <span class="level-start">
                <span class="level-item">타입스크립트</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">5</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
    
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Nube de etiquetas
        </h3>
        <a href="/tags/const/" style="font-size: 10px;">const</a> <a href="/tags/for/" style="font-size: 10px;">for</a> <a href="/tags/git세팅/" style="font-size: 10px;">git세팅</a> <a href="/tags/if/" style="font-size: 10px;">if</a> <a href="/tags/let/" style="font-size: 10px;">let</a> <a href="/tags/map/" style="font-size: 20px;">map</a> <a href="/tags/set/" style="font-size: 20px;">set</a> <a href="/tags/var/" style="font-size: 10px;">var</a> <a href="/tags/배열/" style="font-size: 10px;">배열</a> <a href="/tags/스코프/" style="font-size: 20px;">스코프</a> <a href="/tags/이터레이터/" style="font-size: 10px;">이터레이터</a> <a href="/tags/인스턴스/" style="font-size: 10px;">인스턴스</a> <a href="/tags/제너레이터/" style="font-size: 10px;">제너레이터</a> <a href="/tags/제어문/" style="font-size: 10px;">제어문</a> <a href="/tags/클래스/" style="font-size: 10px;">클래스</a> <a href="/tags/클로저/" style="font-size: 20px;">클로저</a> <a href="/tags/프로퍼티/" style="font-size: 10px;">프로퍼티</a>
    </div>
</div>

    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="chapter14. 비동기적 프로그래밍" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 John Doe&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="https://github.com/leeeso93">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Entradas',
                PAGES: 'Pages',
                CATEGORIES: 'Categorias',
                TAGS: 'Etiquetas',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>

</html>