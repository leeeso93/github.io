{"pages":[],"posts":[{"title":"chapter1. 첫 번째 에플리케이션","text":"1.2 사용할 프로그램 1) 문법 하이라이트2) 괄호 맞추기3) 코드접기4) 자동완성 1.3 주석에 관해12345//인라인주석/* 들여쓰기 블록주석*//* 들여쓰기 안한 주석 * 1.5 자바스크립트 콘솔1console.log(\"hello world\"); 1.6 제이쿼리12&lt;script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-3.4.1.min.js\"&gt;&lt;/script&gt;cs 1.7 단순한 그래픽 그리기index.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;link rel=\"stylesheet\" href=\"main.css\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=\"mainCanvas\"&gt;&lt;/canvas&gt; &lt;script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-3.4.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.9.25/paper-full.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"main.js?v=1.0\"&gt;&lt;/script&gt; &lt;script&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; main.js123456789101112131415$(document).ready(function(){ 'use strict'; paper.install(window); paper.setup(document.getElementById('mainCanvas')); //TODO var c = Shape.Circle(200,200,50); c.fillColor = 'green'; paper.view.draw(); console.log(\"main.js loaded\");}); 1.8 반복적인 작업 자동화하기1234567891011121314151617181920$(document).ready(function(){ 'use strict'; paper.install(window); paper.setup(document.getElementById('mainCanvas')); //TODO var c; for(var x=25; x&lt;400; x+=50){ for(var y=35; y&lt;400;y +=50){ c = Shape.Circle(x,y,20); c.fillColor ='green'; } } paper.view.draw(); //console.log(\"main.js loaded\");}); 1.9 사용자 입력 처리하기 비동기적 이벤트 : 이벤트가 언제 일어날지 프로그래머가 전혀 알 수 없는 이벤트사용자 입력은 항상 “비동기적”이다.ex) 사용자의 마우스 클릭 12345678910111213141516171819 $(document).ready(function(){ 'use strict'; paper.install(window); paper.setup(document.getElementById('mainCanvas')); //TODO var tool = new Tool(); //tool 객체 생성 tool.onMouseDown = function(event){ //onMouseDown 이벤트 핸들러 연결 var c = Shape.Circle(event.point.x, event.point.y, 20); c.fillColor =\"yellow\"; } paper.view.draw(); console.log(\"main.js loaded\");});","link":"/2019/06/24/chapter1/"},{"title":"chapter10. 맵과 셋","text":"10.1 맵 ES6 이전에는 키와 값을 연결하려면 객체를 사용해야함, 여러 단점 생성 프로토타입 체인으로 인해 의도하지 않은 연결이 생길 수 있음 객체 안에 연결된 키와 값이 몇 개인지 쉽게 알수 없음 키는 반드시 문자열이나 심볼이여야 하므로 객체를 키로 써서 값과 연결할 수 없음 객체는 프로퍼티 순서를 보장하지 않음 map123456789101112131415161718192021222324//mapconst u1= {name : 'Cynthia'};const u2= {name : 'Jackson'};const u3= {name : 'Olive'};const u4= {name : 'James'};const userRoles = new Map(); //맵 생성//set()을 사용해 사용자 역할 할당//set()은 체인으로 연결 할 수 있음userRoles .set(u1,'User') .set(u2,'User') .set(u3,'Admin');//생성자에 배열의 배열을 넘기는 형태로 써도됨const userRoles = new Map([ [u1,'User'], [u2,'User'], [u3,'Admin'],]);//u2의 role은? get();userRoles.get(u2); //\"User\" 맵에 존재하지 않은 키에 get()을 호출하면 undefined를 반환has() : 맵에 키가 존재하는지 확인 get&has12345//get()과 has()userRoles.has(u1)//trueuserRoles.get(u1) //\"User\"userRoles.has(u4) //falseuserRoles.get(u4) //undefined 맵에 이미 존재하는 키에 set()을 호출하면 값이 교체 set()으로값교체1234//set()으로 값 교체userRoles.get(u1); //\"User\"userRoles.set(u1,\"Admin\"); userRoles.get(u1); //\"Admin\" size : 맵의 요소 숫자를 반환 size1userRoles.size; //3 keys() : 맵의 키value() : 값entries() : 첫번째 요소가 키이고 두번째 요소가 값인 배열 반환 모두 for…of 루프를 사용할 수 있다. keys,value,entries1234567891011121314151617181920212223242526272829303132333435363738394041424344454647for(let u of userRoles.keys()) console.log(u.name); /* Cynthia Jackson Olive */for(let r of userRoles.values()) console.log(r); /* Admin User Admin */for(let ur of userRoles.entries()) console.log(`${ur[0].name}:${ur[1]}`); /* Cynthia:Admin Jackson:User Olive:Admin *///맵도 분해 가능 for(let [u,r] of userRoles.entries()) console.log(`${u.name}:${r}`); /* Cynthia:Admin Jackson:User Olive:Admin *///entries() 메서드는 맵의 기본 이터레이터//단축 가능합니다.for(let[u,r] of userRoles) console.log(`${u.name}:${r}`); /* Cynthia:Admin Jackson:User Olive:Admin */ delete() : 맵의 요소를 지움 delete()123//delete() :맵의 요소를 지움userRoles.delete(u2);userRoles.size //2 clear() : 맵의 모든 요소를 지움 clear()123//clear() : 맵의 모든 요소를 지움userRoles.clear();userRoles.size //0 10.2 위크맵 WeakMap은 다음 차이점을 제외하면 Map과 완전히 같다. 키는 반드시 객체여야한다. WeakMap의 키는 가비지 콜렉션에 포함 될 수 있다. WeakMap은 이터러블이 아니며 clear() 메서드도 없다. 자바스크립트 코드는 코드 어디에서 객체를 참조하는한 객체를 메모리에서 계속 유지 WeakMap은 그렇지 않으므로, 객체 인스턴스의 전용(private)한 키를 저장하기에 알맞는다. WeakMap12345678910111213141516171819//WeakMapconst SecretHolder = (function(){ const secrets = new WeakMap(); return class{ setSecret(secret){ //비밀저장 secrets.set(this, secret); } getSecret(){ //비밀호출 return secrets.get(this); } }})();const a = new SecretHolder();const b = new SecretHolder();a.setSecret('secret A');b.setSecret('secret B');a.getSecret(); //secret A IIEF 내부에서 그 인스턴스의 비밀스러운 내용을 저장할 수 있는 SecretHolder 클래스를 얻게된다. 10.3 셋 Set() : 중복을 허용하지 않는 데이터 집합ㅊ set()123456789101112const roles = new Set();roles.add(\"User\"); //사용자 역할 추가 add();roles.add(\"Admin\"); //관리자 역할 추가 add();/*Set(2) {\"User\", \"Admin\"}*/roles.size; //2 roles.delete(\"User\"); //trueroles //Set(1) {\"Admin\"}roles.delete(\"User\"); //false 10.3 위크셋 WeakSet() : 객체만 포함 할 수 있으며, 이 객체들은 가비지 콜렉션의 대상이됨 이터러블이 아님 주어진 객체가 set 안에 존재하는지 아닌지 판단하는 정도 WeakSet()123456789101112131415161718const naughty = new WeakSet();const childen = [ {name:'Suzy'}, {name : 'Derek'},];naughty.add(childen[1]); //value: {name: \"Derek\"}for(let child of childen){ if(naughty.has(child)) console.log(`Coal for ${child.name}`) else console.log(`presents for ${child.name}`)} /*presents for SuzyCoal for Derek*/","link":"/2019/07/23/chapter10/"},{"title":"chapter11. 예외와 예외 처리","text":"11.1 Error 객체 자바스크립트에는 내장된 Error 객체가 있고,이 객체는 에러 처리에 간편하게 사용할 수 있다.Error 인스턴스를 만들면서 에러 메시지를 지정 할 수 있다. error12const err = new Error(\"invalid Error\");//Error: invalid Error at &lt;anonymous&gt;:1:13 11.2 try/catch와 예외 처리 예외처리는 try…catch문을 사용 try...catch12345678910111213141516171819//유효한 이메일인지 체크function validateEmail(email){ return email.match(/@/) ? email : new Error(`invalid email :${email}`);}//try...catchconst email = 'a@d.com';try{ const validateEmail = validateEmail(email); if(validateEmail instanceof Error){ console.log(`Error ${validateEmail.message}`); }else{ console.log(`valid email ${validateEmail}`); }}catch(err){ console.error(`Error ${err.message}`); } 에러를 캐치했으므로 프로그램은 멈추지 않는다. 에러가 일어나면 즉시 catch 블록으로 이동함 validateEmail을 실행한 다음 if 문은 실행되지 않음 11.3 에러 일으키기 자바스크립트는 에러를 일으킬 떄 숫자나 문자열 등 어떤 값이든 catch절에 넘길 수 있다. 현금인출123456789//에러 일으키기/*계좌 잔고(balance)가 요청받은 금액보다 적다면 예외를 발생*/function billPay(amount,payee,account){ if(amount &gt; account.balance) throw new Error(\"insufficient funds\"); account.transfer(payee,amount);} throw를 호출하면 함수는 즉시 실행을 멈춤 따라서, account.transfer(payee,amount)는 실행되지 않는다. 11.4 예외 처리와 호출 스택 호출 스택 : 완료되지 않은 함수가 쌓이는 것 에러는 캐치 될 때까지 호출 스택을 따라 올라감 에러는 호출 스택 어디서든 캐치 할 수 있다. 에러를 캐치하지 않으면 자바스크립트 멈춤 =&gt;처리하지 않은 에러 or 캐치하지 않은 에러 stack 프로퍼티* : Error 인스턴스는 스택을 문자열로 표현한 stack 프로퍼티가 있다. 호출스택1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//에러 처리function a(){ console.log(\"a calling b\"); b(); console.log('a :done');}function b(){ console.log(\"b calling c\"); c(); console.log('b :done');}function c(){ console.log(\"c :throwing Error\"); throw new Error('e error'); console.log('c :done');}function d(){ console.log(\"d calling c\"); c(); console.log('d :done');}try{ a();}catch(err){ console.log(err.stack);}try{ d();}catch(err){ console.log(err.stack);}/*a calling bb calling cc :throwing ErrorError: e error at c (&lt;anonymous&gt;:17:11) at b (&lt;anonymous&gt;:11:5) at a (&lt;anonymous&gt;:5:5) at &lt;anonymous&gt;:28:5d calling cc :throwing ErrorError: e error at c (&lt;anonymous&gt;:17:11) at d (&lt;anonymous&gt;:23:5) at &lt;anonymous&gt;:34:5*/ 11.5 try…catch…finally try블록의 코드가 HTTP 연결이나 파일 같은 ‘자원’을 처리해야 할 때어느 시점에서 이 자원을 해제해야함 try는 에러가 일어나면 자원을 헤재할 기회가 사라질 수 있음 catch는 에러가 없으면 실행되지 않음 finally 에러 관계없이 반드시 호출됨 try...catch...finally123456789101112131415//try...catch...finallytry{ console.log(\"1.this line is executed..\"); throw new Error(\"whoops\"); console.log(\"2.this line is not..\");}catch(err){ console.log(\"3.there was an error...\");}finally{ console.log(\"4....always excuted\");}/*1.this line is executed..3.there was an error...4....always excuted*/","link":"/2019/07/24/chapter11/"},{"title":"chapter12. 이터레이터와 제너레이터","text":"이터레이터iterator : ‘지금 어디 있는지’ 파악할 수 있도록 도움 ex)배열 values() 메서드를 써서 이터레이터를 만들 수 있다. next() 메서드를 써서 호출할 수 있다. 이터레이터가 끝까지 진행하면 뒤로 돌아가서 다른 데이터를 제공할 수 없다. 이터레이터는 모두 독립적이다. 즉 새 이터레이터를 만들 때마다 처음에서 시작한다. 각각 다른 요소를 가리키는 이터레이터 여러 개를 동시에 사용 가능하다. 이터레이터1234567const book = [ \"1page\",\"2page\",\"3page\",\"4page\"];const it = book.values(); //이터레이터 생성it.next(); //이터레이터 호출 //{value: \"1page\", done: false}it.next(); // {value: \"2page\", done: false} 12.1 이터레이션 프로토콜 이터레이터 프로토콜은 모든 객체를 이터러블iterable 객체로 바꿀 수 있다. 이터레이션 프로토콜은 클래스에 심볼 메서드 Symbol.iterator가 있고,이 메서드가 이터레이터처럼 동작하는 객체, 즉 value와 done 프로퍼티가 있는 객체를 반환하는 next() 메서드를 가진 객체를 반환한다면 그 클래스의 인스턴스는 이터러블 객체란 뜻이다. 이터레이션_프로토콜1234567891011121314151617181920212223242526272829/*메시지에 타임스탬프를 붙이는 로그 클래스 */class Log{ constructor(){ this.messages = []; } add(message){ this.messages.push({message,timestamp:Date.now()}); } [Symbol.iterator](){ return this.messages.values(); }}const log = new Log();log.add(\"first\");log.add(\"second\");log.add(\"third\");for(let entry of log){ console.log(`${entry.message} @ ${entry.timestamp}`);}/*first @ 1563976491610second @ 1563976491610third @ 1563976491610*/ 이터레이터는 무한한 데이터에도 사용할 수 있다. 피보나치수열1234567891011121314151617181920212223242526272829303132//피보나치수열class FibonacciSequence{ [Symbol.iterator](){ let a = 0 , b = 1; return{ next(){ let rval = {value:b, done:false}; b += a; a = rval.value; return rval; } } }}const fib = new FibonacciSequence(); //인스턴스 생성let i = 0;for(let n of fib){ console.log(n); if(++i &gt;9) break; // 무한루프에서 벗어나게 10회 계산한뒤 빠져나옴}/* 1 2 3 5 8 13 21 34 55*/ 12.2 제너레이터 제너레이터 : 이터레이터를 사용해 자신의 실행을 제어하는 함수 제너레이터 만들때 function 키워드 뒤에 애스터리스크(*)를 붙인다. return 이외에 yield 키워드를 쓸 수 있다. 제너레이터의 두 가지 새로운 개념 1) 제너레이터는 함수의 실행을 개별적 단계로 나누어 함수의 실행을 제어한다. 2) 실행 중인 함수와 통신한다. 제너레이터의 두 가지 예외 1) 제너레이터는 언제든 호출자에게 제어권을 넘길 수 있다. 2) 제너레이터는 호출한 즉시 실행되지는 않는다. 대신 이터레이터를 반환하고, 이터레이터의 next() 메서드를 호출함에 따라 실행된다. 제너레이터12345678910111213141516171819202122232425/* 무지개 색깔을 반환하는 제너레이터 생성 */function* rainbow(){//* 기호는 제너레이터 문법 yield 'red'; yield 'orange'; yield 'yellow'; yield 'green'; yield 'blue'; yield 'indigo'; yield 'violet';}const it = rainbow(); //함수호출for(let color of it){ console.log(color);}/*redorangeyellowgreenblueindigoviolet*/ 제너레이터를 호출하면 이터레이터를 얻는다. 함수를 호출한 다음 이터레이터를 써서 단계별로 진행한다. 12.2.1 yield 표현식과 양뱡향 통신 yield 표현식을 통해 양뱡향 통신이 이뤄진다. yield 표현식의 값은 호출자가 제너레이터의 이터레이터에서 next를 호출할 때 제공하는 매개변수이다. 대화_이어나가기123456789101112// yield 표현식과 양뱡향 통신//대화_이어나가기 제너레이터 생성function* interrogate(){ const name = yield 'what is your name?'; //let it = itterrogate(); const color = yield 'what is your favorite color?'; return `${name}'s favorite color is ${color}`;}const it = interrogate();it.next(); //{value: \"what is your name?\", done: false}it.next(\"Ethan\"); //{value: \"what is your favorite color?\", done: false}it.next(\"red\"); //{value: \"Ethan's favorite color is red\", done: true} 제너레이터를 호출하면 호출자가 함수의 실행을 제어할 수 있다. 제너레이터는 화살표 표기법으로 만들 수 없으며 반드시 function*을 써야한다. 12.2.2 제너레이터와 return yield문은 제너레이터의 마지막 문이여서 제너레이터를 끝내지 않는다. 제너레이터에서 return 문을 사용하면, 그 위치와 관계없이 done은 true가 되고, value프로퍼티는 return이 반환하는 값이 된다. 제너레이터와_return1234567891011//제너레이터와 returnfunction* abc(){ yield 'a'; yield 'b'; return 'c';}const it = abc();it.next(); //{value: \"a\", done: false}it.next(); //{value: \"b\", done: false}it.next(); //{value: \"c\", done: true} 제너레이터에서 중요한 값을 return으로 반환하지 말아야한다.제너레이터가 반환한 값을 사용할 때는 yield로 쓰고,return은 제너레이터를 중간에 종료할 떄만 사용","link":"/2019/07/25/chapter12/"},{"title":"chapter16. Math","text":"자바스크립트의 숫자는 모두 IEEE 754 64비트 부동소수점 숫자이다.~기호는 그 값의 근삿값이라는 의미이다.Math 객체의 프로퍼티를 메서드라 부르지 않고 함수라고 칭할 것 16.1 숫자 형식 자바스크립트의 숫자 형식 메서드는 모두 숫자가 아닌 문자열을 반환한다.따라서 숫자 형식을 바꾸는 것은 실제로 표시하기 직전에 해아한다.숫자를 저장하거나 계산할 때는 따로 형식을 지정하지 않은 숫자 타입이여야 한다. 16.1.1 고정 소수점 소수점 뒤 자릿수를 지정한느 형식을 원한다면 toFIxed()를 사용이 숫자는 반올림이다. 12345const x = 19.51;x.toFixed(3); //\"19.510\"x.toFixed(2); //\"19.51\"x.toFixed(1); //19.5x.toFixed(0); //20 16.1.2 지수 표기법toExponential()을 사용, 마찬가지로 반올림 123456const x = 3800.5;x.toExponential(4); //3.8005e+3x.toExponential(3); //3.801e+3x.toExponential(2); //3.80e+3x.toExponential(1); //3.8e+3x.toExponential(0); //4e+3 16.1.3 고정 전체 자리수 소수점이 어디 나타나든 관계없이 숫자 몇 개로 표현하느냐가 중요하다면 toPrecison()을 사용반올림 1234567//## 16.1.3 고정 전체 자리수let x = 1000;x.toPrecision(5); //1000.0x.toPrecision(4); //1000x.toPrecision(3); //1.00e+3x.toPrecision(2); //1.0e+3x.toPrecision(1); //1e+3 16.1.4 다른 진수toString(): 2진수나 8진수 16진수 표현등을 할때 사용 123456const x = 12;x.toString(); //12x.toString(10); //12x.toString(16); //cx.toString(8); //14x.toString(2); //1100 16.1.5 고급 숫자 형식 다양한 형식으로 숫자를 표시해야할때 수천자리의 아주 큰 숫자 괄호를 쓰는 등 , 음수 표현을 다르게 해야 하는 경우 공학 표기법Numeral.js(link:http://numeraljs.com/) 라이브러리를 사용 16.2 상수 Math 객체에는 몇 가지 아주 중요한 상수가 프로퍼티로 내장되어 있다. 12345678910111213//기본적인 상수Math.E;Math.PI;//로그 관련 상수Math.LN2;Math.LN10;Math.LOG2E;Math.LOG10E;//대수 관련 상수Math.SQRT1_2;Math.SQRT2; 16.3 대수 함수16.3.1 거듭제곱 제곱 관련 기본 함수는 Math.pow이며 제곱근, 세제곱근, e의 거듭제곱 등 자주 쓰이는 연산에는 간편 함수가 있다. 16.3.2 로그 함수 자연로그 함수는 Math.log이다. 상용로그를 log , 자연로그를 ln이라고 표현하는 언어도 있으므로, 자바스크립트의 log는 자연로그라고 기억해야한다.ES6에서는 자주 쓰이는 상용로그 Math.log10 함수가 생김 표 16-2 함수 16.3.3 기타 함수 절댓값, 부호, 배열의 최솟값/최댓값 등 숫자 관련 기타 함수 16.3.4 의사 난수 생성 자바스크립트에서 의사 난수를 생성할 땐 Math.random()을 사용 0이상 1미만의 숫자를 반환 16.4 삼각함수 사인,코사인,탄젠트,아크 사인,아크 코사인,아크 탄젠트등자바스크립트의 삼각함수는 모두 라인 값을 기준으로 한다. 16.5 쌍곡선함수","link":"/2019/08/05/chapter16/"},{"title":"chapter3. 리터럴과 변수, 상수, 데이터타입","text":".. 제작 중입니다..","link":"/2019/06/25/chapter3/"},{"title":"chapter2. 자바스크립트 개발 도구","text":"2.1 자바스크립트 개발 도구 1) 깃 (git) : 프로젝트가 커져도 쉽게 관리할 수 있고 다른 개발자와 협력할 수 있게 하는 버전 컨드롤 도구2) 노드(node): 브라우저 밖에서 자바스크립트를 실행 가능하게 하는 도구3) 걸프 (Gulp) : 반복적인 개발 작업을 자동화하는 빌드 도구4) 바벨 (babel) : ES6 -&gt;ES5 로 변환하는 트랜스컴파일러5) ES린트 (ESLint) :자주하는 실수를 피하고 더 나은 프로그래머가 되도록 돕는 린트 프로그램 2.2.1 GIT 설치 깃설치link: https://git-scm.com/downloads 2.2.2 gitbash 설치 \\ : 일반 윈도우에서는 /(역슬래시) 로 디렉터리를 표시하지만 gitbash에서는 (슬래시)로 ~ : 홈 디렉터리 cd : 다른 디렉터리로 이동 pwd : 현재 디렉터리 경로 출력 mkdir test : 현재 디렉터리에서 test 라는 서브 디렉터리를 만든다. cd .. : (..) 은 부모 디렉터리로 한 단계 위 디렉터리로 이동하게 2.2.6 걸프와 그런트 gulp : 반복 작업을 자동화 해주는 도구 1) 터미널에 각각 명령어를 입력해 걸프를 설치한다. bash12npm install -g gulpnpm install --save-dev gulp 2) 설치 후 프로젝트 루트에 gulpfile.js를 만든다. gulpfile.js123456const gulp = require('gulp');//걸프 의존성을 여기 씁니다. gulp.task('default', function() { //걸프 작업을 여기 씁니다.}); 2.3 트랜스컴파일러 - 바벨1) 바벨을 설치해준다. bash1npm install --save-dev gulp-babel @babel/core @babel/preset-env 2) 프리셋 설치 후에 프로젝트 루트에 .babelrc 파일을 만든다. .babelrc123{ \"presets\": [\"es2015\"] } #위와 같이 작성하는 프리셋내용도 아래와 같이 변경이 필요하다.{ \"presets\": [\"@babel/preset-env\"] } 2.3.1 바벨을 걸프와 함께 사용하기1) gulp-babel 패키지를 설치한다. bash1npm install --save-dev gulp-babel 2) gulpfile.js를 수정한다. bash123456789101112131415const gulp = require('gulp');const babel = require('gulp-babel'); gulp.task('default', function() { //노드소스 gulp.src('es6/**/*.js') .pipe(bable()) .pipe(gulp.dest('dist')); //브라우저 소스 gulp.src('public/es6/**/*.js') .pipe(babel()) .pipe(gulp.dest('public/dist')); done();}); 2.4 린트EsLint12npm install -g eslintnpm install --save-dev gulp-eslint","link":"/2019/06/24/chapter2/"},{"title":"chapter13. 함수와 추상적 사고","text":"13.1 서브루틴으로서의 함수 서브루틴 : 프로시저, 루틴, 서브프로그램, 매크로 등 다양하게 불린다.복잡한 코드를 간단하게 만드는 기초적인 수단이다.반복되는 작업의 일부를 떼어내서 이름을 붙이고 언제든지 이름을 부르면 실행된다. 1234567891011121314151617//오늘이 윤년인지 아닌지 판단하는 알고리즘const year = new Date().getFullYear();//console.log(year); //2019if(year % 4 !== 0) console.log(`${year} is not a leap year`);if(year % 100 !== 0) console.log(`${year} is not a leap year`);if(year % 400 !== 0) console.log(`${year} is not a leap year`);else console.log(`${year} is a leap year`);//오늘이 윤년인지 아닌지 판단하는 함수function printLeapYearStatus(){ const year = new Date().getFullYear(); //console.log(year); //2019 if(year % 4 !== 0) console.log(`${year} is not a leap year`); if(year % 100 !== 0) console.log(`${year} is not a leap year`); if(year % 400 !== 0) console.log(`${year} is not a leap year`); else console.log(`${year} is a leap year`);} 13.2 값을 반환하는 서브루틴으로서의 함수서브루틴 함수123456789101112function isCurrentYearLeapYear(){ const year = new Date().getFullYear(); if(year % 4 !== 0) return false; if(year % 100 !== 0) return false; if(year % 400 !== 0) return false; else return true;}//값 반환const dayInMonth = [31,isCurrentYearLeapYear() ? 29:28, 30,31,30,31,31,30,31,30,31];if(isCurrentYearLeapYear()) console.log('it is a leap year');console.log(dayInMonth); // [ 31, 28, 30, 31, 30, 31, 31, 30, 31, 30, 31 ] 13.3 함수로서의 함수 순수한 함수 : 입력이 같으면 결과도 반드시 같다.앞의 isCurrentYearLeapYear()는 언제 호출하느냐에 따라 값이 달라지므로 순수함수가 아니다. 순수함수에는 부수효과가 없다. 즉, 함수를 호출한다고 해서 프로그램의 상태가 바뀌면 안됌 순수함수 아닐때1234567// #순수함수 - 순수하지 않은 함수(레인보우)const colors = ['red','orrange','yellow','green','blue','indigo','violet'];let colorIndex = -1;function getNextRaindowColor(){ if(++colorIndex &gt;= colors.length) colorIndex = 0; return colors[colorIndex];} 이 함수는 순수함수의 두가지 정의를 모두 어긴다. 1. 입력이 같아도 결과가 항상 다르고, 2. 변수 colorIndex를 바꾸는 부수효과가 발생한다. (colorIndex는 getNextRaindowColor 함수에 속하지 않는데도 함수를 호출하면 바뀜 = > 부수효과 발생) 순수함수로 레인보우 수정123456789101112// #순수함수 - 순수한함수(레인보우)//이터레이터function getRainbowIterator(){ const colors = ['red','orrange','yellow','green','blue','indigo','violet']; let colorIndex = -1; return{ next(){ if(++colorIndex &gt;= colors.length) colorIndex = 0; return {value : colors[colorIndex], done : false} } }} 이 함수는 순수함수다. 1. 입력이 같으면 결과가 항상같다. 2. 부수효과가 발생하지 않는다. next() 메서드는 매번 다른 값을 반환할테니 순수함수가 아니지 않은가에 대한 해설 next()는 함수가 아니라 메서드이다. 메서드는 자신이 속한 객체라는 컨텍스트 안에서만 동작하므로, 메서드의 동작은 그 객체의 의해 좌우된다. 즉 다른부분에서 getRainbowIterator()를 호출해도 독립적인 이터레이터가 생성된다. 13.4 그래서? 함수의 세가지 측면 : 서브루틴, 값을 반환하는 서브루틴, 순수함수에 대해 서브루틴 : 반복을 없애준다. 순수한 함수 : 코드를 테스트하기 쉽고 이해하고 재사용하기 쉽다.순수함수는 부수효과를 발생시키지 않으므로 버그를 줄여준다. 13.4.1 함수도 객체다 자바스크립트 함수는 Function 객체의 인스턴스이다.typeof v =&gt; v가 함수일 때 “function”을 반환typeof array =&gt; array가 배열이면 “object”를 반환v instanceof object =&gt; true를 반환한다.그러므로 변수가 함수인지 확인하고 싶을 땐 typeof를 써보기 13.5 IIFE와 비동기적 코드 IIFE(즉시 호출하는 함수 표현식), 클로저를 만들 수 있음IIFE는 비동기적 코드가 정확히 동작할 수 있도록 새 변수를 스코프에 만든다. 1234567//5초에서 시작하고 카운트다운이 끝나면 \"GO\"를 표시하는 타이머var i;for(i = 5; i&gt;=0; i--){ setTimeout(function(){ console.log(i===0? \"GO\": i); }, (5-i)*1000);} //-1이 6번 출력 setTimeout에 전달된 함수가 루프 안에서 실행되지 않고 루프가 종료된 뒤에 실행되었다. 루프는 5에서 시작해 -1로 끝난다. -1이 되기 전에 콜백함수가 실행되지 않는다. 콜백함수가 호출되는 시점에서 i의 값은 -1이다. 그러므로 -1이 6번 출력된다. 12345678910111213141516171819202122232425262728293031//5초에서 시작하고 카운트다운이 끝나면 \"GO\"를 표시하는 타이머//위에 함수로 감쌈function loopBody(i){ setTimeout(function(){ console.log(i===0? \"GO\": i); }, (5-i)*1000);}var i;for(i = 5; i&gt;=0; i--){ loopBody(i);} /*54321GO*///IIFE로 고쳐쓰기 /*한번쓰고 버릴 함수는 이름을 붙이는게 성가심*/var i;for(i = 5; i&gt;=0; i--){ (function(i){ setTimeout(function(){ console.log(i===0? \"GO\" :i); }, (5-i)*1000); })(i);} 13.6 변수로서의 함수 함수를 가리키는 변수를 만들어 별명을 정할 수 있다. 배열에 함수를 넣을 수 있다. 물론 다른 타입의 데이터와 섞일 수 있다. 함수를 객체의 프로퍼티로 사용할 수 있다. 함수를 함수에 전달할 수 있다. 함수가 함수를 반환할 수 있다. 함수를 매개변수로 받는 함수를 반환하는 것도 가능하다. 함수에 별명정하기123456789//함수를 가리키는 변수를 만들어 별명을 정할 수 있다.function addThreeSquareAddFiveTakeSqureRoot(x){ return Math.sqrt(Math.pow(x+3,2)+5);}//별명쓰기const f = addThreeSquareAddFiveTakeSqureRoot;const answer = (f(5) + f(2)) / f(7);//7.3484692283495345 별명을 지을 때 addThreeSquareAddFiveTakeSqureRoot에 괄호를 붙이지 않음 괄호를 붙이면 함수를 호출하고, 호출 결과가 저장되게됨 13.6.1 배열 안의 함수 배열 안의 함수를 쓰는것은 유용하다.자주 하는 일을 한 셋으로 묶는 파이프라인이 좋은 예 13.6.2 함수에 함수 전달 비동기적 프로그래밍콜백함수 : 자신을 감싼 함수가 실행을 마쳤을 때 호출함수에 함수를 전달하는 방식 함수전달1234567function sum(arr,f){ //함수가 전달되지 않았으면 매개변수를 그대로 반환하는 null 함수를 씁니다. if(typeof f !='function') f = x=&gt;x; return arr.reduce((a,x) =&gt; a += f(x),0);}sum([1,2,3]);//6sum([1,2,3], x =&gt; x*x);//14 13.6.3 함수를 반환하는 함수함수반환123456789101112131415function sum(arr,f){ //함수가 전달되지 않았으면 매개변수를 그대로 반환하는 null 함수를 씁니다. if(typeof f !='function') f = x=&gt;x; return arr.reduce((a,x) =&gt; a += f(x),0);}sum([1,2,3]);//6sum([1,2,3], x =&gt; x*x);//14function newSummer(f){ return arr =&gt; sum(arr,f);}const sumOfSquares = newSummer(x =&gt; x*x);const sumOfCubs = newSummer(x =&gt; Math.pow(x,3));sumOfSquares([1,2,3]); //14sumOfCubs([1,2,3]); //36 13.7 재귀 재귀함수 : 자기 자신을 호출하는 함수같은 일을 반복하면서 그 대상이 점차 줄어드는 상황에서 재귀를 유용하게 쓸 수 있다. 재귀 함수에는 종료 조건이 있어야한다. 1234567891011121314151617181920212223//건초더비에서 바늘을 찾아야하는 예제function findNeedle(haystack){ if(haystack.length===0) return \"no haystack here\"; if(haystack.shift() === 'needle') return \"found it\" return findNeedle(haystack)//건초더미의 건초가 하나 줄었다.}findNeedle(['hay','hay','hay','hay','needle','hay','hay',]);/*\"no haystack here\"\"no haystack here\"\"no haystack here\"\"no haystack here\"\"found it\"\"no haystack here\"\"no haystack here\"*///숫자의 계승을 찾는 예제function fact(n){ if(n === 1) return 1; return n * fact(n-1);}","link":"/2019/07/31/chapter13/"},{"title":"chapter15. 날짜와 시간","text":"자바스크립트의 Date 객체는 원래 넷스케이프 프로그래머 켄 스미스가 만들었다.사실 자바의 java.util.Date를 가져온 것 15.1 날짜, 타임존, 타임스탬프, 유닉스 시간0초(UTC: 1970년 1월 1일 0시 0분 0초)타임존(UTC, 때때로 그리니치 표준시 GMT)라고도 불린다.타임존이란?타임존은 동일한 로컬 시간을 따르는 지역을 의미하며, 주로 해당 국가에 의해 법적으로 지정된다. 보통 국가별로 각자의 고유한 타임존을 사용하고 있으며, 미국이나 캐나다처럼 면적이 넓은 나라인 경우 지역별로 각기 다른 타임존을 사용하기도 한다. GMT한국의 타임존은 보통 GMT+09:00 으로 표현된다. 여기서 GMT는 Greenwich Mean Time의 약자로서 경도 0도에 위치한 영국 그리니치 천문대를 기준으로 하는 태양 시간을 의미한다. GMT 시간은 1925년 2월 5일부터 사용하기 시작하였으며, 1972년 1월 1일까지 세계 표준시로 사용되었다.UTCUTC는 지구 자전주기의 흐름이 늦어지고 있는 문제를 해결하기 위해 1972년에 세슘 원자의 진동수에 기반한 국제 원자시를 기준으로 다시 지정된 시간대이다. 즉, UTC는 좀더 정확한 시간측정을 위해서 GMT를 대체하기 위해 제정된 새로운 표준이며,시간적으로는 둘 사이에 아주 미세한 차이밖에 없지만, 소프트웨어에서 사용할 때는 UTC라고 하는 것이 더 정확한 표현일 것이다자바스크립트는 보통 이 숫자를 사람이 읽기 편한 그레고리력 날짜로 변환한다.자바스크립트의 Date 인스턴스는 모두 유닉스 시간 원점으로부터 몇 밀리초가 지났는지를 나타내는 숫자이다.숫자형 표현이 필요하면 valueOf() 메서드를 사용한다. 1234// ## 15.1 날짜, 타임존, 타임스탬프, 유닉스 시간const d = new Date();console.log(d); //2019-08-04T12:36:34.573Zconsole.log(d.valueOf()); //1564922215240 15.2 Date 객체 만들기 Date 객체는 네 가지 방법으로 만들 수 있다.매개변수 없이 호출하면 현재 날짜에 해당하는 Date 객체를 반환문자열을 제공하면 그 문자열을 해석해서 그에 맞는 날짜를 반환숫자를 넣으면 유닉스 타임스탬프로 해석 12345678910111213//자바스크립트 월은 0으로 시작, 0은 1월이고, 1은 2월new Date(2015,0); //Thu Jan 01 2015 00:00:00 GMT+0900 (한국 표준시)new Date(2015,1); //Sun Feb 01 2015 00:00:00 GMT+0900 (한국 표준시)new Date(2015,1,14); //2015년 2월 14일 0시new Date(2015,1,14,13); ////2015년 2월 14일 1시new Date(2015,1,14,13,30,5); //Sat Feb 14 2015 13:30:05 GMT+0900 (한국 표준시)//유닉스 타임스탬프로 날짜 생성new Date(0); //Thu Jan 01 1970 09:00:00 GMT+0900 (한국 표준시)new Date(1000);//날짜 문자열 해석new Date('June 14,2013'); //Fri Jun 14 2013 00:00:00 GMT+0900 (한국 표준시) 리스본이나 그리니치 등 UTC 지역에 살지 않는 한, 예제에서 UTC로 표기한 시각은 독자의 콘솔에 표시되는 내용과 다르다. 즉 타임존을 명시할 방법이 없다. Date 객체는 항상 UTC 기준으로 저장하고, 출력 시 운영제체에 에서 정의한 표준시에 맞게 변환 15.3 Moment.js Moment.js는 타임존을 지원하는 버전과 지원하지 않는 버전 2가지가 있다. Moment.js 호출1234567//웹 기반 프로젝트시 &lt;script src=\"http:////cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.4.0/moment-timezone.min.js\"&gt;&lt;/script&gt;//노드에서 사용하기npm install moment --save moment-timezone//불러오기const moment = require('moment-timezone'); 15.5 날짜 데이터 만들기 Date 객체를 써서 날짜를 만들어도 되긴 하지만, 타임존을 명시하지 않고 날짜를 생성할 때는 어느 타임존이 사용되는지 생각해야하고, 어느 지역에서 날짜를 생성하느냐에 따라 달라지게 된다.예) 버지니아 앨링턴의 서버에서 날짜 관련 코드를 만들면, 캘리포니아 로스앤잴레스의 사용자 브라우저에서는 3시간의 차이가 발생 15.5.1 서버에서 날짜 생성하기 서버에서 날짜를 생성할 땐 UTC를 사용하거나 타임존을 명시하는 편이 좋다.UTC 날짜를 사용할 수 있는 환경이라면 Date 객체의 UTC 메서드를 사용하라 1234const d = new Date(Date.UTC(2016,4,27)); console.log(d);/*Fri May 27 2016 09:00:00 GMT+0900 (한국 표준시)*/ Date.UTC는 Date의 매개변수를 똑같이 받지만, 새 Date 인스턴스를 반환하지 않고 해당 날짜의 숫자형 값을 반환한다. 이 숫자를 Date 생성자에 넘기면 날짜 인스턴스를 얻을 수 있다. 특정 타임존에 있는 서버에서 날짜를 생성할 땐 moment.tz를 써서 Date 인스턴스를 만들면 타임존을 손으로 변환할 필요가 없다. moment.tz1234//특정 타임존에 있는 서버에서 날짜를 생성const moment = require('moment-timezone');const d = moment.tz([2016,3,27,9,19],'America/Los_Angeles').toDate();console.log(d); //2016-04-27T16:19:00.000Z 15.6 날짜 데이터 전송하기 일반적으로 Date 객체를 그냥 전송해도 안전하지만,자바스크립트에서 날짜를 전송하는 가장 확실한 방법은 JSON을 사용하는 것날짜는 JSON에서 1:1 대칭이 되게끔 파싱할 수 없으므로, JSON 명세에는 날짜에 대한 데이터 타입을 정의하지 않는다. 1234567// ## 15.6 날짜 데이터 전송하기const before = { d: new Date() };before.d instanceof Date //trueconst json = JSON.stringify(before);const after = JSON.parse(json);after.d instanceof Date; //falsetypeof after.d; // \"string\" 즉, JSON으로 바로 날짜를 다룰 수는 없지만, 전송된 문자열에서 날짜를 ‘복구’하는 것은 가능하다. 123//전송된 문자열에서 날짜 복구하기after.d = new Date(after.d);after.d instanceof Date; //true 원래 날짜가 어느 타임존에 있던, 일단 JSON으로 인코드된 날짜는 UTC이다. 그리고 JSON으로 인코드된 문자열을 Date 생성자에 넘겨서 얻은 날짜는 사용자의 타임존을 기준으로 표시된다. 문자를 인코드하지 않고 valueOf() 메서드로 얻은 숫자를 그냥 전송해도 된다. 1234567const before = { d: new Date() };typeof before.d //\"object\"const json = JSON.stringify(before);const after = JSON.parse(json);typeof after.d //\"string\"const d = new Date(after.d);// console.log(d); /Sun Aug 04 2019 22:54:52 GMT+0900 15.7 날짜 형식 Moment.js의 format 메서드를 서서 날짜를 원하는 형식으로 만들 수 있다.예를 들어 문자열 YYYY는 네 자리 연도로 바뀐다. 1234567891011const moment = require('moment-timezone');const d = new Date(Date.UTC(1093,4,10));//다음 기준은 로스앤잴리스에 사는 사람 기준d.toLocaleDateString(); //\"1093. 5. 10.\"d.toLocalFormat();//d.toLocaleTimeString();d.toTimeString();d.toUTCString();moment(d).format(\"YYYY-MM-DD\");//console.log(d); //1093-05-10 15.8 날짜의 구성 요소 Date 인스턴스의 각 구성 요소에 접근할 땐 다음 메서드를 사용한다. 1234567891011121314151617const d = new Date(Date.UTC(1815,9,10));//지금 시각 2019 - 08 - 04 오후 11시 11분 기준//다음 결과는 로스앤젤리스 기준d.getFullYear();//1815d.getMonth(); // 9d.getDate(); //10d.getDay(); //2 - (화요일)d.getHours(); //8 d.getMinutes(); //27d.getSeconds(); //52d.getMilliseconds(); //0//UTC 기준 메서드d.getUTCFullYear(); //1815d.getUTCMonth(); //9d.getUTCDate(); //10//etc... 15.9 날짜 비교 날짜 A와 날짜 B중 어느 쪽이 더 앞인가 하는 단순 날짜 비교 때는 자바스크립트에 내장된 비교 연산자를 통해 할 수 있다.Date 인스턴스는 날짜를 숫자로 지정하므로, 숫자에 쓸 수 있는 비교 연산자를 그대로 사용하면 된다. 12345const d1 = new Date(1996,2,1);const d2 = new Date(2009,4,27);d1 &gt; d2//false;d1 &lt; d2//true; 15.10 날짜 연산 날짜는 숫자이므로 날짜에서 날짜를 빼면 몇 밀리초가 지났는지 알 수 있다. 12345const d1 = new Date(1996,2,1);const d2 = new Date(2009,4,27);const msDiff = d2- d1 //417744000000const daysDiff = msDiff/1000/60/60/24; //4835 Array.prototype.sort를 써서 날짜를 정렬 할 수도 있다. 12345678910111213const dates = [];const min = new Date(2017,0,1).valueOf();const delta = new Date(2020,0,1).valueOf() - min;for(let i =0; i &lt;10 ; i++) dates.push(new Date(min + delta*Math.random()));//dates 배열은 랜덤으로 만들었으므로 뒤죽박죽일것//날짜순으로 정렬하기dates.sort((a,b) =&gt; a-b);/*dates(10) [Thu Jan 12 2017 07:13:33 GMT+0900 (한국 표준시), Sat Jan 14 2017 15:30:06 GMT+0900 (한국 표준시), Tue Jan 31 2017 07:46:50 GMT+0900 (한국 표준시), Sun Apr 23 2017 02:13:01 GMT+0900 (한국 표준시), Mon Sep 18 2017 06:02:23 GMT+0900 (한국 표준시), Thu Dec 07 2017 16:38:18 GMT+0900 (한국 표준시), Sun Dec 17 2017 19:38:32 GMT+0900 (한국 표준시), Mon Apr 02 2018 11:27:48 GMT+0900 (한국 표준시), Mon Jun 03 2019 09:55:56 GMT+0900 (한국 표준시), Fri Dec 27 2019 00:38:29 GMT+0900 (한국 표준시)]*/ 15.11 사용자가 알기 쉬운 상대적 날짜 Moment.js에서 제공하는 목록 날짜를 더하거나 빼는 메서드 메서드를 체인으로 연결하기 ‘3일전’과 같이 상대적으로 날짜 표현하기 123456789101112131415161718//Moment.js에서 제공하는 목록입니다.let m = moment(); //현재m.add(3,\"days\");//m은 이제 3일 뒤m.subtract(2,\"years\"); //m은 이제 2년 전으로부터 3일이 지난 날짜m = moment();//리셋m.startOf(\"year\"); // m은 이제 올해 1월 1일m.endOf(\"month\");//m은 이제 올해 1월 31일//메서드를 체인으로 연결let m = moment().add(10,\"hours\").subtract(3,\"days\").endOf(\"month\");//m은 이제 3일전으로부터 10시간 뒤인 달의 마지막 순간//상대적 날짜m.subtract(10,\"seconds\").fromNow(); //","link":"/2019/08/04/chapter15/"},{"title":"chapter17. 정규표현식","text":"17.1 부분 문자열 검색과 대체 정규표현식(정규식)으로 하는 일은 문자열 속에서 부분 문자열을 찾는 일이며찾은 부분을 교체할 때도 있다.다만 그 전에, 정규식을 쓰지 않고 검색하고 교체하는 방법인String.prototype 메서드 검색을 살펴본다,큰 문자열 안에 원하는 부분 문자열이 존재하는지 여부를 찾을 때 사용 String.prototype12345678910const input = \"AS I was going to Saint Ives\";input.startsWith(\"AS\"); //trueinput.endsWith(\"Ives\"); //trueinput.startsWith(\"going\", 9); //true - index 9에서 시작하느냐input.endsWith(\"going\", 14); //true - 끝에서 부터 14번째에input.includes(\"going\"); //true;input.includes(\"going\", 10); //false - index 10에서 시작하면 going 이 없다.input.indexOf(\"going\"); // 9 ;input.indexOf(\"going\", 10); // -1;input.indexOf(\"nope\"); // -1; 이들 메서드는 모두 대소문자를 구분한다. 따라서 input.startsWith(\"as\")는 false 이다. 대소문자를 구분하지 않고 비교하려면 소문자고 바꿔서 비교하면 된다. String.prototype12const input = \"AS I was going to Saint Ives\";input.toLowerCase().startsWith(\"as\"); //true String.prototype.toLowerCase는 원래 문자열은 그대로 두고 새 문자열을 반환한다.자바스크립트 문자열은 항상 불변이다.부분 문자열을 찾아 교체하려면 String.prototype.replace 사용 String.prototype.replace1234567891011//String.prototype.replaceconst input = \"AS I was going to Saint Ives\";const output = input.replace(\"going\", \"walking\");/*//원래 문자열은 바뀌지 않는다.console.log(input);\"AS I was going to Saint Ives\"console.log(output);\"AS I was walking to Saint Ives\"*/ 17.2 정규식 만들기 자바스크립트 정규식은 RegExp 클래스이다. RegExp 생성자로도 정규식을 만들 수 있지만, 간편한 리터럴 문법도 있다.정규식 리터럴은 슬래시(/)로 감싼 형태이다. 정규식 만들기12const rel1 = /going/; //단어 going을 찾을 수 있는 정규식const rel2 = new RegExp(\"going\"); //생성자를 사용했지만 결과는 같다. 17.3 정규식 검색 정규식이 만들어지면 다양한 옵션으로 문자열을 검색 할 수 있다.예) /\\w{3,}/ig =&gt; 세 글자 이상인 단어에 모두 일치하고, 대소문자를 가리지 않음 정규식 검색1234567891011121314151617181920const input = \"AS I was going to Saint Ives\";const re = /\\w{3,}/gi;//문자열(input)의 메서드를 사용할 때input.match(re); //(4) [\"was\", \"going\", \"Saint\", \"Ives\"]input.search(re); //5 세글자 이상으로 된 단어의 첫번쨰 인덱스는 5이다.//정규식(re)의 메서드를 사용할 때re.exec(input); //[\"was\", index: 5, input: \"AS I was going to Saint Ives\", groups: undefined]re.exec(input); //goingre.exec(input); //Saintre.exec(input); //Ivesre.exec(input); //null - 일치하는 것이 더이상 없다.re.test(input); //true - input에는 세 글자 이상으로 된 단어가 한 개 이상 있다.//정규식 리터럴을 사용시input.match(/\\w{3,}/gi);input.search(/\\w{3,}/gi);/\\w{3,}/gi.exec(input);/\\w{3,}/gi.test(input); 17.4 정규식을 사용한 문자열 교체 String.prototype.replace 메서드에도 정규식을 쓸 수 있다. 123456//네 글자 이상으로 된 단어를 모두 교체const input = \"AS I was going to Saint Ives\";const output = input.replace(/\\w{4,}/gi, \"****\");/*\"AS I was **** to **** ****\"*/ 17.5 입력 소비 정규식이 입력 문자열을 소비하는 패턴이라고 생각하는 것정규식이 문자열을 소비할 떄 사용하는 알고리즘 문자열 왼쪽에서 오른쪽으로 진행 일단 소비한 글자에 다시 돌아오지 않는다 한 번에 한 글자씩 움직이며 일치하는 것이 있는지 확인한다. 일치하는 것을 찾으면 해당하는 글자를 한꺼번에 소비 후 다음 글자로 진행 17.6 대체1234567//html 페이지를 문자열에 담고, 이 문자열에서 &lt;a&gt;,&lt;area&gt;,&lt;link&gt;,&lt;script&gt;등등을 찾고 싶을 때, 대소문자 상관없이 찾고싶을 때const html = 'HTML With &lt;a href=\"one\"&gt;one link&lt;/a&gt; and some JavaScript' + '&lt;script src=\"stuff.js\"&gt;';const matches = html.match(/area|a|link|script|source/gi); //첫 시도//(8) [\"a\", \"link\", \"a\", \"a\", \"a\", \"a\", \"Script\", \"script\"] 파이프(|)는 대체를 뜻하는 메타 문자이다.ig는 대소문자를 가리지 않고 전체를 검색하라는 의미이다.문자열이 겹치는 것이 있을 때는 더 큰것을 먼저 써야한다. 17.7 HTML 찾기 정규식으로는 HTML을 분석할 수 없습니다.p 태그 안에 a 태그가 존재하는 등의 계층적 구조에 취약합니다. 17.8 문자셋 문자셋은 글자 하나를 다른 것으로 대체하는 방법을 줄인 것 문자셋123456789101112131415const beer99 = \"99 bottles of beer on the wall\" + \"take 1 down and pass it around-- \" + \"98 bottles of bear on the wall\";const matches = beer99.match(/|0|1|2|3|4|5|6|7|8|9/g);// 문자셋은 이러한 문자들이 들어갈 수 있다는 것을 간략하게 표시할 수 있다.const m1 = beer99.match(/[0123456789]/g);const m2 = beer99.match(/[0-9]/g);//범위 결합도 가능합니다.const match = beer99.match(/[\\-0-9a-z.]/gi);//특정 문자 범위를 제외하고도 찾을 수 있다. 문자열 제외시 캐럿(^)을 맨 앞에 붙임const match = beer99.match(/^[\\-0-9a-z.]/gi); 17.9 자주 쓰는 문자셋 매우 자주 쓰이는 일부 문자셋은 단축 표기가 있다.이를 클래스라고 부르기도 한다. 공백문자셋 \\s을 써서 줄을 맞출 때가 많습니다. 공백12345678const stuff = \"hight: 9\\n\" + \"medium : 5\\n\" + \"low : 2\\n\";const levels = stuff.match(/:\\s*[0-9]/g);//전화번호 양식 맞추기const messyPhone = `(505) 555 - 1515`;const neatPhone = messyPhone.replace(/\\D/g, \"\");//neatPhone//\"5055551515\" 17.10 반복 반복 메타문자는 얼마나 많이 일치해야하는지 지정할 떄 사용문자셋 다음의 +는 그 앞에 있는 요소가 하나 이상 있어야한다는 뜻반복 메타 문자는 그 자체로는 별 의미가 없다. 반복123456//숫자 여러개를 찾는 예제//기존verconst match = beer99.match(/[0-9][0-9][0-9][0-9][0-9][0-9]/);//반복 메타 문자로 수정const match = beer99.match(/[0-9]+/); 17.11 마침표와 이스케이프 정규식에서 마침표(.)는 줄바꿈 문자를 제외한 모든 문자에 일치하는 특수문자입니다.이 메타문자는 입력이 어떤 문자이든 상관하지 않고 소비하려고 할때 사용 1234567891011//문자열에서 우편번호만 필요하고 다른것은 필요 없을 때const input = \"Address : 333 Main St., Anywhere, NY, 55532. Phone : 555 -555-2525.\";const match = input.match(/\\d{5}.*/);/*[\"55532. Phone : 555 -555-2525.\", index: 38, input: \"Address : 333 Main St., Anywhere, NY, 55532. Phone : 555 -555-2525.\", groups: undefined]*///마침표 자체가 필요할 때const equation = \"(2 + 3.5 ) * 7\";const match = equation.match(/\\(\\d \\+ \\d\\.\\d\\) \\* \\d/); 17.11.1 진정한 와일드 카드 마침표가 줄바꿈을 제외한 모든 문자에 일치하면, 줄바꿈 문자를 포함해서 모든 문자에 일치하는 것은 바로 [\\s\\S]이다. 17.12 그룹 그룹을 사용하면 하위 표현식을 만들고 단위 하나로 취급할 수 있다.그 그룹에 일치하는 결과를 나중에 사용하도록 캡쳐할 수도 있다.그룹은 괄호로 만든다. 캡쳐하지 않은 그룹은 (? :[subexpression]) 형태이고, 여기서 [subexpression]이 일치시키려는 패턴이다. 17.13 소극적 일치, 적극적 일치 정규식은 기본적으로 적극적이다. 검색을 멈추기 전에 일치하려는 것을 최대한 많이 찾으려고 한다. 적극적 일치12345678910111213141516171819//&lt;i&gt;태그를 &lt;strong&gt; 태그로 바꿀때//적극적 일치const input = \"Regex pros konw the difference between\\n\" + \"&lt;i&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/i&gt; matching.\";var a = input.replace(/&lt;i&gt;(.*)&lt;\\/i&gt;/gi, \"&lt;strong&gt;$1&lt;/strong&gt;\");/*a를 콘솔에 입력\"Regex pros konw the difference between&lt;strong&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/strong&gt; matching.\"*///소극적 일치var b = input.replace(/&lt;i&gt;(.*?)&lt;\\/i&gt;/gi, \"&lt;strong&gt;$1&lt;/strong&gt;\");/*\"Regex pros konw the difference between&lt;strong&gt;greedy&lt;/strong&gt; and &lt;strong&gt;lazy&lt;/strong&gt; matching.\"*/ 정규식은 일치할 가능성이 있는 동안 문자를 소비하지 않고 계속 넘어간다 정규식은 를 만나면 를 더 찾을 수 없을 때까지 소비하지 않고 계속 진행한다. 원래 문자열에는 가 두개 있으므로, 정규식은 첫번째 것을 무시하고 그대로 진행 반복 메타 문자 *를 소극적으로 바꾸려면 뒤에 ?를 붙이면된다 17.14 역참조 그룹을 사용하면 역참조라는 테그닉을 사용 가능서브 그룹을 포함해 , 정규식의 각 그룹은 숫자를 할당 받음숫자는 맨 왼쪽이 1번에서 시작해서 오른쪽으로 갈수록 1씩 늘어남역슬래시 뒤에 숫자를 써서 이 그룹을 참조 할 수 있다.즉, \\1은 맨 처음 일치한 그룹이 된다.따욤표의 짝을 맞출 때 등 사용 17.15 그룹 교체 그룹을 사용하면 문자열 교체도 더 다양한 방법으로 사용가능 17.16 함수를 이용한 교체 함수를 사용하면 복잡한 정규식을 단순화 할 수 있다. 17.17 위치 지정 ‘–으로 시작하는 문자열’, ‘–로 끝나는 문자열’ 등을 정규식의 앵커라고 부른다. ^는 문자열의 처음 $는 문자열의 마지막 123456789// ## 17.17 위치 지정const input = \"it was the best of times, it was the worst of times\";const beginning = input.match(/^\\w+/g); //[\"it\"]const end = input.match(/\\w+$/g); //[\"times\"]//문자열의 줄바꿈이 들어 갔을 때 각 줄의 처음과 끝을 찾으면 m 플래그 사용const input = \"one line\\ntwo line\\nthree line\\nfour\";const beginning = input.match(/^\\w+/gm); //[\"one\", \"two\", \"three\", \"four\"]const end = input.match(/\\w+$/gm); // [\"line\", \"line\", \"line\", \"four\"] 17.18 단어 경계 일치 단어 경계 메타 문자인 \\b 와 \\B는 앵커와 마찬가지로 입력을 소비하지 않는다.단어 경계는 알파벳 또는 숫자(\\w)로 시작하는 부분, 알파벳이나 숫자가 아닌 문자(\\W)로 시작하는 부분, 또는 문자열의 시작과 끝에 일치한다. 17.19 룩어헤드 룩어헤드는 입력을 소비하지 않는다.룩어헤드를 쓰면 정규식 하나로 비밀번호의 유효성을 검사가능하다. 룩어헤드123456789/* * 비밀번호가 규칙에 맞도록 검사해서 * 비밀번호에 대문자와 소문자, 숫자가 최소 하나씩 포함되어야하고, * 글자도 아니고 숫자도 아닌 문자는 들어갈 수 없다. *///룩어헤드로 비밀번호 유효성 체크하기function vaildPassword(p) { return /(?=.*[A-Z])(?=.*[0-9])(?=.*[a-z])(?!.*[^a-zA-Z0-9])/.test(p);}","link":"/2019/08/07/chapter17/"},{"title":"chapter7. 스코프","text":"스코프 변수와 상수, 매개변수가 언제 어디서 정의되는지를 결정ex ) 함수 매개변수가 함수 바디 안에서만 존재하는 것 스코프123456//스코프function f(x){ return x + 3;}f(5); // 8x; //ReferenceError : x is not defined x가 아주 잠시나마 존재했으므로 x + 3을 계산 할 수 있었다. 그러나 함수를 벗어나면 x가 존재하지 않는 것처럼 보인다. 따라서 x의 스코프가 함수 f라고한다. 스코프 : 시야, 범위라고 이해 변수의 스코프가 어떤 함수라고 말할 때, 함수를 실제 호출할 때 까지는 함수 바디의 정해진 매개변수가 존재하지 않는다. 함수를 호출할 때마다 매개변수가 나타나고, 함수가 제어권을 반환하면 스코프 밖으로 사라진다. 변수와 상수는 만들기 전에는 존재하지 않는다. let이나 const로 선언 하기 전에는 스코프 안에서 존재하지 않는다. (var는 특수한 경우) 변수를 선언 : 식별자를 주어서 존재를 알린다.변수를 정의 : 선언과 함께 값을 부여한다.자바스크립트는 선언과 동시에 값이 주어지므로 둘을 구분하지 않는다. 7.1 스코프와 존재변수가 존재하지 않으면 그 변수는 스코프안에 ‘있지 않음’ → 그 변수는 존재하지 않는다 ?꼭 그런건 아님 스코프 : 실행 컨텍스트에서 현재 보이고 접근할 수 있는 식별자존재한다 : 그 식별자가 메모리가 할당된 무언가를 가리킴 ‘존재하지만 스코프 안에는 없는 변수의 예’ 무언가가 더 존재하지 않는다 해도 자바스크립트는 메모리를 바로 회수하는 것이 아닌, 자동적으로 가비지 콜렉션 프로세스에서 메모리를 회수 한다. 7.1 정적 스코프와 동적 스코프1234567891011function f1(){ console.log('one');}; function f2(){ console.log('two');}; f2();f1();f2(); 정적으로 보면 이 프로그램은 위에서 아래로 읽어내리지만(f1 정의-> f2정의) 실행을 하면 f2 -> f1 -> f2 자바스크립트의 스코프는 정적, 어떤 변수가 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다. 1234567891011const x = 3;function f(){ console.log(x); console.log(y);} { //새 스코프 const y = 5; f();} 1. 변수 x는 함수 f를 정의 할 때 존재하나 y는 다른 스코프에도 존재 한다. 2. 다른 스코프에서 y를 선언하고 그 스코프에서 f를 호출하더라도 f를 호출하면 x는 그 바디 안에 스코프에 있지만 y는 그렇지 않다. 3. 정적 스코프는 전역 스코프, 블록 스코프 , 함수 스코프에 적용된다. 7.3 전역 스코프스코프는 계층적이며 트리 맨아래 바탕이 되는 무언가가 있어야 한다.-&gt; 암시적으로 주어지는 스코프가 필요 이를 전역 스코프 라고 한다. 전역 스코프에서 선언한 것은 무엇이든 프로그램의 모든 스코프에서 볼 수 있다. 전역변수 : 전역 스코프에서 선언된 것 , 전역 스코프에 의존하는 걸 피해라.. 12345678910//전역 스코프, 전역변수 let name = 'lrene' //전역let age = 25; //전역 function greet(){ console.log(`hello ${name}`);}function getBirthYear(){ return new Date().getFullYear() - age;} 1. 함수가 호출하는 스코프에 대단히 의존적이다 2. name과 age의 값을 어디든지 실수로 바꿀 수 있다. 3. greet()와 getBirthYear()도 전역 변수에 의존하므로 name과 age를 정확히 사용한다는 가정에서만 쓸 수 있다. 12345678910111213//전역 스코프, 전역변수 개선ver1//단일 객체에 보관 let user = { name = 'Irene', age : 25,}; function greet(){ console.log(`hello ${name}`);}function getBirthYear(){ return new Date().getFullYear() - age;} 1. user을 써서 단일 객체에 보관 2. 그러나 아직 greet와 getBirthYear은 전역 user에 의존 123456789//전역 스코프, 전역변수 개선ver2//모든 스코프에서 호출할 수 있고, 명시적으로 user을 전달 받음 function greet(user){ console.log(`hello ${user.name}`);} function getBirthYear(user){ return new Date().getFullYear() - user.age;} 1. 모든 스코프에서 호출할 수 있고, 명시적으로 user을 전달 받음 7.4 블록 스코프 블록의 스코프안에서만 보이는 식별자let,const는 식별자를 블록 스코프에서 선언 1234567891011121314151617//블록 스코프 console.log('before block'); { console.log('inside block'); const x = 3; console.log(x);}console.log(`outside block; x = ${x}`);//결과/*before block inside block 3ReferenceError: x is not defined*/ x는 블록 안에서 정의되었고, 블록을 나가는 즉시 x도 스코프 밖으로 사라지므로 정의되지 않은 것으로 간주 7.5 변수 숨기기 다른 스코프에 있으면서 이름이 같은 변수나 상수는 혼란을 초래 1234567891011121314{ //block 1 const x = 'blue'; console.log(x); // \"blue\"}console.log(x); //ReferenceError: x is not defined { //block2 const x = 3; console.log(x) // \"3\"} console.log(typeof x); //undefined ; x는 스코프 밖에 있습니다. 변수 숨기기 12345678910111213141516//스코프 중첩 { //외부블록 let x = 'blue'; console.log(x) ; //\"blue\" { //내부블록 let x = 3; console.log(x); // \"3\" } console.log(x); //\"blue\" } console.log(typeof x); //undefined ; x는 스코프에 있지 않습니다. . 1. 내부 블록의 x와 외부블록의 x는 이름만 같은 다른 변수이다. 2. 그러므로 외부 스코프의 x를 숨기는 (가리는) 효과를 발휘 3. 실행 흐름이 내부 블록에 들어가 새 x를 정의 할 때, 두 변수가 모두 스코프 안에 있다 4. 이름이 같은 x의 경우 내부 블록에서 외부 스코프에 접근 할 방법은 없음 1234567891011121314151617{ //외부블록 let x = {color : \"blue\"}; let y = x; let z =3; { //내부블록 let x = 5; //외부블록의 x가 가려짐 console.log(x); //5 console.log(y.color)//\"blue\": y가 가리키는 외부 스코프의 x가 가리키는 객체는 모두 스코프 안에 있다. y.color = \"red\"; console.log(z) //\"3\" :z는 숨겨지지 않았다. } console.log(x.color); //\"red\" 객체가 내부스코프에서 수정됨 console.log(y.color); //\"red\"; x와 y는 같은 객체를 가리킴 console.log(z); //\"3\"} 1. 스코프는 계층적 , 이로인해 스코프 체인이란 개념이 생김 2. 스코프 체인에 있는 변수는 스코프에 있는 것이므로 숨겨지지만 않으면 접근이 가능하다. 7.6 함수, 클로저, 정적 스코프 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 경우가 많다.이를 클로저라고 한다.클로저 : 스코프를 함수 주변으로 좁히는 것 클로저예제12345678910//클로저 예제 let globalFunc; //정의되지 않은 전역함수 { let blockVar = \"a\"; globalFunc = function(){ console.log(blockVar); }} globalFunc(); //\"a\" 1. globalFunc가 블록 안에서 값을 할당 받음 2. globalFunc를 호출하면 이 함수는 스코프에서 빠져나왔어도 blockVar에 접근 할 수 있다. 3. 일반적으로 스코프를 빠져나가면 해당 스코프 안에서 선언한 변수는 메모리에서 제거해도 안전하다 4. 그러나 스코프 안에서 함수를 정의했고, 이 함수는 스코프 밖에서도 참조할 수 있으므로 자바스크립트는 스코프를 계속 유지한다. => 즉, 스코프 안에서 함수를 정의하면 해당 스코프는 더 오래 유지가 된다 . => 또한, 접근 할 수 없는 것에 접근 할 수 있게하는 효과도 있다. 123456789let f; //정의되지 않은 함수 { let o = {note : 'safe'}; f = function(){ return 0; }}let oRef = f();oRef.note = 'not so safe after all!'; 1. 일반적으로 스코프 바깥쪽에 있는 것들은 접근할 수 없다. 2. 그러나 함수를 정의해 클로저를 만들면 접근할 방법이 생긴다 . 7.7 즉시 호출하는 함수 표현식 함수 표현식을 사용하면 즉시 호출하는 함수 표현식(llEF)를 만들 수 있다.IIFE : Immediately Invoked Function Expressions, 함수를 선언하고 즉시 실행 IIEF1234//IIEF(function(){ //IIEF 바디 })(); 함수 표현식으로 익명 함수를 만들고 그 함수를 즉시 호출 IIFE는 내부에 있는 것 모두 자신의 스코프를 가지지만, IIEF가 함수이므로 스코프 밖으로 무언갈 내보낼 수 있는 장점을 가짐 12345const message =(function(){ const secret = \"I'm a secret!\"; return `The secret is ${secret.length} characters long.`;})();console.log(message);//The secret is 13 characters long. 1. 변수 secret은 IIEF 스코프 안에서 안전하게 보호되며 외부에서 접근 할 수 없다. 2. 그렇지만 IIEF는 함수이므로 무엇이든 반환할 수 있다. 12345678910const f = (function(){ let count = 0; return function(){ return `i have been called ${++count} time(s)`; }})(); f(); //i have been called 1 time(s)f(); //i have been called 2 time(s)//... 변수 count는 IIEF안에 안전하게 보관되어 있으므로 손댈 방법이 없다. f는 자신이 몇 번 호출됐는지 정확히 알고 있다. 7.8 함수 스코프와 호이스팅 letlet으로 변수를 선언하면, 그 변수는 선언하기 전에 존재하지 않는다. varvar로 선언한 변수는 현재 스코프 안이라면 어디서든 사용할 수 있으며, 선언하기 전에도 사용할 수 있다. 아직 선언되지않은 변수의 값 == 에러를 일으킴존재하되 값이 undefined인 변수 = 에러를 일으키지 않음 1234567891011121314151617//let x; //x가 정의되지 않음 let x = 3; //에러가 실행되어 멈춰서 여기에 도달할 수 없음``` &lt;pre&gt;let을 쓰면 변수를 선언하기 전에 사용하려고 할때 에러가 난다. &lt;/pre&gt;```javascript//var x;var x = 3;x; //3x; //선언(할당은 아닌)이 끌어올려 집니다. x; //undefinedvar x = 3;x; //3 1. var로 변수를 선언하면, 선언하기 전에도 사용할 수 있다. 2. var로 선언한 변수는 끌어올린다는 뜻의 호이스팅이라는 메커니즘을 따름 3. 선언만 끌어올리지며, 할당은 끌어올리지지 않는다. 123456789101112131415161718192021222324252627282930313233343536//원래코드 if(x !==3){ console.log(y); //undefined var y = 5; if(y === 5){ var x = 3; } console.log(y); //5} if(x === 3){ console.log(y); //5} //자바스크립트가 해석한 코드 var x;var y; if(x !== 3){ console.log(y); y = 5; if (y === 5){ x = 3; } console.log(y);} if(x === 3){ console.log(y);}var x = 3;if(x === 3){ var x = 2; console.log(x); //2}console.log(x); //2 1. 같은 함수나 전역 스코프 안에서는 var로 새 변수를 만들 수 없다. 2. let으로 가능 했던 변수 숨김도 불가능 3. 그렇지만 ES5로 트랜스 컴파일 해야하므로 var의 동작을 이해해야한다. 7.9 함수 호이스팅 var로 선언된 변수와 마찬가지로, 함수 선언도 스코프 맨 위로 끌어올려진다.함수를 선언하기 전에 호출 할 수 있다. 1234f(); //\"f\"function f(){ console.log(f);} 그러나, 변수에 할당한 함수 표현식은 끌어올려지지 않는다. 1234f(); //ReferrenceError : f는 정의되지 않았습니다.let f = function(){ console.log(f);}; 7.10 사각지대 let으로 선언하는 변수는 선언하기 전까지 존재하지 않는다는 직관적 개념스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드 1234567if(typeof x ===\"undefined\"){ console.log(\"x doesn't exist or is undefined\");}else{ //x를 사용해도 안전한 코드} //결과 x doesn't exist or is undefined 해당 코드는 안전하고 에러가 발생하지 않는다. BUT, 이 코드를 let으로 바꾸면 에러가 발생 사각지대let1234567//사각지대 letif(typeof x === \"undefined\"){ console.log(\"x doesn't exist or is undefined\");}else{ //x를 사용해도 안전한 코드 }let x = 5;//Uncaught ReferenceError: Cannot access 'x' before initialization ES6에서는 typeof 연산자로 변수가 정의됐는지 확인 할 필요가 거의 없어짐 7.11 스트릭트 모드 암시적 전역변수(ES5문법) : var로 변수를 선언하는 것을 잊으면 자바스크립트는 전역 변수를 참조하려 한다고 간주하고,그런 전역변수를 스스로 생성 =&gt; 수많은 문제 생성스트릭트 모드 : 암시적 전역 변수를 허용하지 않음“use strict”를 코드 맨 앞에 씀 전역 스코프에서 스트릭트 모드를 사용하지 않는 편이 좋다 . 스트릭트모드123456(function(){ 'use strict'; //코드를 전부 이 안에서 작성합니다. //이 코드는 스트릭트 모드로 동작하지만, //이 코드와 함께 동작하는 다른 스크립트는 스트릭트 모드에 영향을 받지 않습니다.})();","link":"/2019/07/13/chapter7/"},{"title":"chapter4. 제어문","text":"4.1.2 블록문 여러 개의 중괄호로 묶은 것제어문에는 블록을 쓰는 것이 일반적 12345let funds = 50; //시작조건while(funds&gt;1 &amp;&amp; funds &lt;100){ funds = funds +2; funds = funds -1;} 4.1.3 공백블록이 없는 경우 12345let funds = 50; //시작조건while(funds&gt;1 &amp;&amp; funds &lt;100) funds = funds +2; //while 루프 바디 funds = funds -1; //while 루프 끝난 후 실행 4.1.4 보조 함수123456789//m 이상 n 이하의 무작위 정수를 반환한다.function rand(m,n){ return m + Math.floor((n - m +1) * Math.random());} //크라운 앤 랭커 게임의 여섯 가지 도형 중 하나를 무작위로 반환한다.function randFace(){ return [\"crown\",\"anchor\",\"heart\",\"spade\",\"Club\",\"diamond\"][rand(0,5)];} 4.1.5 if else 문123456789const bets = {crown:0, anchor:0, heart:0, spade:0, club:0, diamond:0}; //토마스가 베팅할 카드 목록 {카드:얼마}let totalBet = rand(1,funds);if(totalBet===7){ //만약 돈을 7펜스를 뽑으면 totalBet = funds; //남은 돈을 다 건다. bets.heart = totalBet; //하트에 건다.}else{ //그 판에 걸 돈을 분배}funds = funds - totalBet; // 남은돈 = 기존판에 남은돈 - 건 돈의 총액 4.1.6 do while 루프 while과 다르게 시작하면서 조건을 검사하지 않고 마지막에 검사한다.루프바디를 최소 한 번은 실행하려 할 때 사용 1234567let remaining = totalBet; //남은돈 = 걸 돈 총액;do{ let bet = rand(1,remaining); let face = randFace(); bets[face] = bets[face] + bet; remaining = remaining - bet;}while(remaining&gt;0); 4.1.7 for 루프 어떤 일을 정해진 숫자만큼 반복할 때 1234const hand =[];for(let roll=0; roll &lt;3; roll++){ hand.push(randFace());} 4.1.8 if문123456let winnings = 0; for(let die=0; die&lt;hand.length; die++){//hand.length ==3 (주사위를 세 번 굴린다.) let face = hand[die]; if(bets[face] &gt; 0) winnings = winnings + bets[face]; } funds = funds +winnings; 4.1.9 하나로합치기크라운앤앵커게임1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*[규칙]1. 크라운, 앵커, 하트, 클럽, 스페이드, 다이아몬드 그림이 있고 선원이 무작위로 돈을 건다.2. 6면체 주사위 세개를 굴린다. 3. 주사위가 사각형 번호에 일치하는 숫자에 멈추면 선원은 거기 건 만큼의 돈을 따게된다.4. 예외 -&gt; 토마스(선원)에게는 몇가지 규칙이 있다.4-1)*///m 이상 n 이하의 무작위 정수를 반환합니다.function rand(m,n){ return m + Math.floor((n - m + 1) * Math.random());} //rand(0,5) = &gt; 0~5까지의 무작위 수를 반환.//크라운 앤 앵커 게임의 여섯 그림 중 하나에 해당하는 문자열을 무작위로 반환합니다.function randFace(){ return [\"crown\",\"anchor\",\"heart\",\"spade\",\"club\",\"diamond\"][rand(0,5)];} // randFace() =&gt; \"crown\"randFace();let funds = 50; //선원이 가진 초기자본 = 50펜스let round = 0; //게임 라운드while(funds &gt; 1 &amp;&amp; funds &lt; 100){ //선원 규칙 100펜스,0펜스가 되면 게임종료 즉 게임을 계속할때 round++; //게임 라운드가 1 올라가고 console.log('round ${round}:'); //돈을 건다. let bets = {crown :0 ,anchor:0,heart:0,spade:0,club:0,diamond:0}; let totalBet = rand(1,funds); //1~99까지의 무작위 금액을 거는 것에 대한 토탈 배팅 금액 console.log(totalBet); //선원의 조건 if(totalBet ===7){ //뽑은 돈이 7펜스면 totalBet == funds; //남은 돈을 다 배팅 bets.heart = totalBet //현재는 0 인데 남은 돈 하트에 걸어버림 }else{ //판돈 나누기 let remaining = totalBet; do{ let bet = rand(1,remaining); //1~남은돈까지의 무작위 금액을 거는 것에 대한 배팅 금액 let face = randFace();// randFace() =&gt; \"crown\" bets[face] = bets[face] + bet; //0 = 0 + (1~남은돈까지의 무작위 금액을 거는 것에 대한 배팅 금액) remaining = remaining -bet //남은돈 = 남은돈 - (1~남은돈까지의 무작위 금액을 거는 것에 대한 배팅 금액) }while(remaining&gt;0)//남은 돈이 0보다 클 때까지 do 구문을 계속 반복 } funds = funds - totalBet; //자본 = 자본 - 건돈 총액 //주사위 굴리기 contst hand =[]; for(let roll = 0; roll&lt;3; roll++ ){ //3개의 주사위를 굴림 hand.push(randFace()); // hand 배열에 \"crown\" 넣음 } //딴 돈을 가져옴 let winnings = 0; for(let die=0; die&lt;hand.length; die++){ let face = hand[die]; if(bets[face] &gt;0) winnings = winnings + bets[face]; } funds = funds + winnings;} 4.2 자바스크립트 제어문 조건문ifif elseswitch 반복문whiledo whilefor 4.2.1 제어문의 예외 제어문의 실행 방식을 바꿈break :루프 중간에 빠져나감continue : 루프 다음 단계로 바로 건너뜀return : 루프문 무시 함수 빠져나감throw : 반드시 처리해야할 예외를 발생(제어문 밖에서도 작용) 4.2.2. if else 문을 체인으로 연결하기12345678//수요일을 싫어해서 배팅 1 if(new Date().getDay()===3){ //new Date().getDay() 요일 반환 0은 일요일 totalBet === 1;}else if(totalBet===7){ //7펜스를 뽑으면 전부 배팅 totalBet === funds;}else{ console.log(\"no supersitition here\");}; 4.2.3 메타문법 다른 문법을 설명하는 문법, 자바스크립트 제어문을 간결하게 표현대괄호([]) : 옵션생략 부호 (…) : ‘여기 들어갈 내용이 더 있다’단어 : placeholderexpression: 어떤 값condition: 참 또는 거짓 같은 메타문법1234567891011121314151617181920212223//while : 컨디션이 참 같은 값이면 statement 를 실행한다.while(condition) statement //if else if(condition) //condition이 참 같은 값이면 statement1//statement1실행[else //그렇지 않다면 statement2] //statement2 실행 //do while do statement //statement는 최소한 한 번 실행 while(condition); //condition이 참 같은 값일 동안 반복 실행 //forfor([initialization];[condition];[final-expression]) statement/*루프에 들어가기 전 initialization 실행condition이 참인 동안 statement 실행 final-expression을 실행한 다음 condition 다시 체크*/ 4.2.4 for 루프의 다른 패턴​&gt; 쉼표 연산자를 쓰면 초기화와 마지막 표현식에 여러 문을 결합 할 수 있다. 루프의_다른_패턴 12345678910111213141516//피보나치 수열 =&gt; i,j 동시 선언, 세 변수 동시 조작 for(let temp, i=0, j=1; j&lt;30; temp =i, i =j, j = i + temp)console.log(j); //for 루프에서 조건 생략시 항상 true로 평가되어 무한 루프 for(;;) console.log(\"i will repeat\"); //특이한 for문들..let s ='3'; //숫자가 들어있는 문자열for(; s&lt;s.length; s ='' + s); //문자열의 길이가 조건 for(let x = 0.2; x&lt;3.0; x +=0.2) //제어변수가 정수가 아님 console.log(x); for(; !player.isBroke;) //조건에 객체 프로퍼티 사용console.log('still playing'); 4.2.5 switch 문 for 문이 두가지 중 하나를 선택하는 경우라면 switch는 조건 하나로 여러 가지 중 하나를 선택 12345678910111213141516171819202122232425262728293031323334353637383940414243//switchswitch(totalBet){ case 7 : //totalBet ==7 일때 totalBet = funds; //조건 실행 break; // 이 루프를 빠져나감 case 13 : // totalBet == 13일때 1펜스 기부 totalBet = funds -1; case 11 : //break 문이 없으므로 case 13 다음 바로 11로 넘어감 totalBet = 0; break; case 21 : //break가 걸렸으므로 안 넘어감 totalBet = 21; break; default : //case 절이 없을 때 실행 console.log(\"no\"); break;``` * return```javascript//return 즉시 함수를 빠져나갑니다.function adjustBet(totalBet,funds){ switch(totalBet){ case 7: return funds; case 13: return 0; //break문 대신 return을 사용 할 수 있다. default : return totalBet; }}``` ## 4.2.6 for ...in 루프&gt;객체에 프로퍼티에 루프를 실행하도록 설계 ```javascriptconst player={name:'Thomas',rank:'Midshipman',age:25};for(let prop in player){ if(!player.hasOwnProperty(prop)) continue; console.log(prop + ':' + player[prop]);} 4.2.7 for …of 루프 es6에서새로 생긴 반복문","link":"/2019/06/25/chapter4/"},{"title":"chapter9. 객체와 객체지향 프로그래밍","text":"9.1 프로퍼티 나열 1) 배열은 값을 가지며 각 값에는 숫자형 인덱스가 있습니다. 객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있습니다2) 배열에는 순서가 있습니다. 반면 객체는 그런 순서가 보장되지 않습니다. 9.1.1 for…in for…in : 객체 프로퍼티를 나열할 떄 123456789101112const SYM = Symbol();const o ={a:1,b:2,c:3,[SYM]:4};for(let prop in o){ if(!o.hasOwnProperty(prop)) continue; console.log(`${prop}:${o[prop]}`)}/*a:1b:2c:3*/ hasOwnProperty : for...in에 나타날 위험을 제거하기 위해 사용 for...in 루프에는 키가 심볼인 프로퍼티는 포함 안됌 9.1.2 Object.keys 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환 12345678910// 9.1.2 Object.keysconst SYM = Symbol();const o ={a:1,b:2,c:3,[SYM]:4};Object.keys(o).forEach(prop =&gt; console.log (`${prop} :${o[prop]}`));/*a:1b:2c:3*/ hasOwnProperty를 체크할 필요가 없다. 객체의 프로퍼티 키를 배열로 가져와야 할때 Object.keys가 편리하다. 9.2 객체지향 프로그래밍 OOP) 객체 : 데이터와 기능을 논리적으로 묶은 것 클래스 : 자동차처럼 추상적이고 범용적인 것 인스턴스 : 특정 자동차처럼 구체적이고 한정적인 것 메서드 : 기능 클래스 메서드 : 클래스지만 특정 인스턴스에 묶이지 않는 기능 생성자 : 인스턴스를 처음 만들 떄 생성자가 실행됨, 객체 인스턴스를 초기화함 클래스 : 운송수단서브 클래스 : 자동차, 보트, 비행기..보트 서브 클래스 : 요트, 카누,모터보트… 9.2.1 클래스와 인스턴스 생성 ES6애서 클래스를 만드는 간편한 새 문법을 도입함 클래스만들기12345class Car{ constructor(){ }} 새 클래스 Car을 만듬, 아직 인스턴스(특정 자동차)는 안만들어짐 인스턴스만들기12const car1 = new Car();const car2 = new Car(); 인스턴스를 만들 떈 new 키워드를 사용한다 instanceof123//instanceofcar1 instanceof Car //truecar1 instanceof Bus //false instanceof : 객체가 클래스인지, 인스턴스인지 확인 car1은 Car의 인스턴스이지만, Bus의 인스턴스는 아니다. 12345678910111213141516171819202122//제조사, 모델, 변속 기능 추가class Car{ constructor(make, model){ this.make = make; this.model = model; this.userGears = ['P','N','R','D']; this.userGear = this.userGears[0]; } shift(gear){ if(this.userGears.indexOf(gear)&lt;0) throw new Error('invalid gear :' `${gear}`); this.userGear = gear }}//실제 사용const car1 = new Car('Thsla','Model S');const car2 = new Car('Mazda','3i');car1.shift('D');car2.shift('R');car1.userGear //\"R\" this : 메서드를 호출한 인스턴스를 가리키는 목적 userGears : 사용할 수 있는 기어 목록 gear : 현재 기어 사용할 수 있는 첫번째 기어로 초기화 shift : 메서드(기어변속) * 실수로 기어 프로퍼티를 고치지 않도록 어느 정도 막을 수 있다. _ : 외부에서 접근하면 안돼는 프로퍼티 이름 앞에 붙이는 가짜 접근 제한 ex)_userGears 9.2.2 클래스는 함수다. ES6에서 class 키워드를 도입하기 전까지,클래스를 만드는 것은 곧 클래스 생성자로 사용될 함수를 만든다는 의미but, class는 단축 문법일 뿐이고 자바스크립트의 클래스가 바뀐 것은 아님 es5123456function Car(make,model){ this.make = make; this.model = model; this.userGears = ['P','N','R','D']; this.userGear = this.userGears[0];} es61234class Es6Car {} //생성자는 의도적으로 생략function Es5Car {}&gt; typeof Es6Car //'function'&gt; typeof Es5Car //'function' 9.2.3 프로토타입 프로토타입 메서드: 클래스의 인스턴스에서 사용할 수 있는 메서드ex) Car.prototype.shift :Car 클래스의 인스턴스에서 사용할 수 있는 shift 메서드는 프로토타입 메서드임 최근엔 메서드를 ‘#’로 표기하기도함 ex)Car#shift 클래스는 대문자로 시작하는게 관용적임 함수의 prototype 프로퍼티가 중요한 시점은 new 키워드로 새 인스턴스를 만들때 new 키워드로 만든 새 객체는 생성자 prototype 프로퍼티에 접근가능 ‘proto‘(밑줄 2개) 프로퍼티에 저장() 동적 디스패치 : 메서드 호출 prototype123456789101112131415161718192021222324252627282930313233//9.2.3 프로토타입const Car = (function(){ const carProps = new WeakMap(); class Car{ constructor(make,model){ this.make = make; this.model = model; this._userGears = ['P','N','R','D']; carProps.set(this,{userGear:this._userGears[0]}); } get userGear(){return carProps.get(this).userGear;} set userGear(value){ if(this._userGears.indexOf(value)&lt;0) throw new Error(`${value}`); carProps.get(this).userGear = value; } shift(gear){this.userGear = gear;} } return Car;})();const car1 = new Car();const car2 = new Car();car1.shift === Car.prototype.shift; //true;car1.shift('D');car1.shift('d');//error;car1.userGear; // 'D';car1.shift === car2.shift; //true;car1.shift = function(gear) {this.userGear = gear.toUpperCase();}car1.shift === Car.prototype.shift; //false 9.2.4 정적 메서드 정적 메서드 : 클래스 메서드 특정 인스턴스에 적용되지 않음 this는 인스턴스가 아니라 클래스 자체에 묶임 클래스와 관련되지만 인스턴스와 관련없는 범용적 작업에 사용ex) 자동차 식별 번호 (VIN) 붙이기 여러 인스턴스를 대상으로 하는 작업에도 사용 정적메서드123456789101112131415161718192021222324252627282930313233//areSimilar : 두 자동차의 제조사와 모델이 같으면 true 반환 메서드//areSame : 두 자동차의 VIN이 같으면 true반환 메서드class Car{ static getNextVin(){ return Car.nextVin++; //this.nextVin++이라고 써도 되지만, // Car을 앞에 쓰면 정적 메서드라는 걸 상기 } constructor(make,model){ this.make = make; this.model = model; this.vin = Car.getNextVin(); } static areSimilar(car1,car2){ return car1.make == car2.make &amp;&amp; car1.model == car2.model; } static areSame(car1,car2){ return car1.vin === car2.vin; }}Car.nextVin = 0; //초기값const car1 = new Car(\"Tesla\",\"S\");const car2 = new Car(\"Mazda\",\"3\");const car3 = new Car(\"Mazda\",\"3\");car1.vin; //0car2.vin; //1car3.vin; //2Car.areSimilar(car1,car2);//falseCar.areSimilar(car2,car3);//trueCar.areSame(car2,car3);//falseCar.areSame(car2,car2);//true 9.2.5 상속 클래스 인스턴스는 클래스의 기능을 모두 상속한다. 프로토타입 체인 : 조건에 맞는 프로토타입을 찾을 때 까지 체인을 계속 거슬러감 프로토타입을 찾지 못하면 에러를 일으킴 123456789101112131415161718192021222324252627282930313233343536//프로토타입 체인/*deployAirbags */class Vehicle { constructor(){ this.passengers = []; console.log(\"Vehicle created\"); } addPassenger(p){ this.passengers.push(p); }}class Car extends Vehicle{ constructor(){ super(); console.log(\"Car created\"); } deployAirbags(){ console.log(\"BWOOSH\"); }}const v = new Vehicle(); v.addPassenger(\"Frank\");v.addPassenger(\"Judy\");v.passengers; // [\"Frank\",\"Judy\"];const c = new Car();c.addPassenger(\"Alice\");c.addPassenger(\"Cameron\");c.passengers; //[\"Alice\",\"Cameron\"]v.deployAirbags(); //errorc.deployAirbags(); //console.log(\"BWOOSH\"); extends : Car를 Vehicle의 서브 클래스로 만듬 super() : 슈퍼클래스의 생성자 호출, 서브클래스에서는 이 함수를 반드시 호출 c 에서는 deployAirbags 호출 가능, v 에서는 error 서브클래스는 슈퍼클래스의 모든 메서드에 접근 가능 / 반대는 불가 9.2.6 다형성 다형성 : 여러 슈퍼클러스의 맴버인 인스턴스instanceOf 연산자: 객체가 클래스의 인스턴스인지 확인 다형성123456789//다형성// Vehicle : 슈퍼클래스 // Motorcycle 와 Car는 Vehicle의 서브클래스임 class Motorcycle extends Vehicle{};const c = new Car();const m = new Motorcycle();c instanceof Car; //truec instanceof Vehicle; //truem instanceof Car //false 자바스크립트의 모든 객체는 루트 클래스인 Object의 인스턴스이다 9.2.7 객체 프로퍼티 나열 다시 보기1234567891011121314151617181920212223242526272829//class Super{ constructor(){ this.name = 'Super'; this.isSuper = true; }}//유효하지만 권장xSuper.prototype.sneaky = 'not recommended';class Sub extends Super{ constructor(){ super();//서브클래스는 써줘야함 this.name = 'Sub'; this.isSub = true; }}const obj = new Sub(); for(let p in obj){ console.log(`${p} : ${obj[p]}`+ (obj.hasOwnProperty(p)? '': '(inherited)'));}/*name : SubisSuper : trueisSub : truesneaky : not recommended(inherited) */ 9.2.8 문자열 표현 toString : 객채의 기본적인 문자열 표현을 제공 9.3 다중 상속, 믹스인, 인터페이스 다중 상속 : 클래스가 슈퍼 클래스 두 개를 가지는 기능, 충돌 위험 존재인터페이스 : 다중 상속을 지원하지 않는 언어의 경우 인터페이스를 도입믹스인 : 기능을 필요한 만큼 섞은 것Symbol() : 심볼은 고유하므로, 다른 슈퍼클래스의 기능과 충돌할 가능성이 없다.","link":"/2019/07/22/chapter9/"},{"title":"chapter14. 비동기적 프로그래밍","text":"자바스크립트는 기본적으로 단일 스레드에서 동작한다. 즉 한 번에 한 가지 일만 할 수 있다.자바스크립트에서는 매우 일찍부터 비동기적 실행 매커니즘이 존재했지만, 필요한 장치가 추가되었다. 콜백, 프라미스, 제너레이터가 그것이다.제너레이터는 비동기적 프로그래밍을 전혀 지원하지 않으므로 비동기적으로 쓰기 위해 프라미스나 특수한 콜백과 함께 사용해야한다.사용자 입력 외에, 비동기적 테크닉을 사용해야 하는 경우는 크게 세 가지가 있다. Ajax 호출을 비롯한 네트워크 요청 파일을 읽고 쓰는 등의 파일시스템 작업 의도적으로 시간 지연을 사용하는 기능(알림 등) 14.1 비유 분주한 음식점에서 전화번호를 받아서 자리가 나면 알려줌 : 콜백음식점에 자리가 났을 떄 진동하는 호출기를 넘겨줌 - 프라미스 14.2 콜백 콜백은 자바스크립트에서 가장 오래된 비동기적 매커니즘이다.콜백이란 나중에 호출할 함수이다.콜백 함수는 일반적으로 다른 함수에 넘기거나, 객체의 프로퍼티로 사용한다. 배열에 넣어서 쓰기도한다. 대게 익명 함수로 사용한다. setTimeOut1234567891011121314// ## 14.2 콜백console.log(\"before setTimeout \" + new Date());function f(){ console.log(\"After setTimeout \"+ new Date());}setTimeout(f, 60 *1000); // 1분 console.log(\"i happen after setTimeout\");console.log(\"me too\");/*before setTimeout Thu Aug 01 2019 21:10:46 GMT+0900 (GMT+09:00)i happen after setTimeoutme tooAfter setTimeout Thu Aug 01 2019 21:11:46 GMT+0900 (GMT+09:00)*/ 작성하는 코드와 실제 실행되는 코드가 다르다. 비동기적 실행의 가장 중요한 점은 어떤 것도 차단하지 않는다는 것 자바스크립트는 싱글 스레드를 사용하므로, 컴퓨터에 60초 동안 대기한 후 코드를 실행하게되면 프로그램이 멈추고, 사용자 입력을 받아들이지 않는 등의 문제가 발생한다. 위 예제는 이름 붙은 함수 f를 setTimeout에 넘겼으나, 이름을 쓸 이유가 없다면 일반적으로 익명 함수를 사용한다. setTimeOut 익명함수123setTimeout(function(){ console.log(\"After TimeOut \"+ new Date() ,6000);}); 14.2.1 setInterval 과 clearInterval setTimeout은 콜백 함수를 한 번만 실행하고 멈추지만,setInterval은 콜백을 정해진 주기마다 호출하며 clearInterval을 사용할 때까지 멈ㅊ지 않는다. 123456789101112131415//분이 넘어거거나 10회째가 될 때까지 5초마다 콜백 실행const start = new Date();let i =0;const intervalId = setInterval(function(){ let now = new Date(); if(now.getMinutes() !== start.getMinutes() || ++i &gt;10) return clearInterval(intervalId); console.log(`${i}:${now}`);},5000);/* 1:Fri Aug 02 2019 13:59:47 GMT+0900 (한국 표준시) 2:Fri Aug 02 2019 13:59:52 GMT+0900 (한국 표준시) 3:Fri Aug 02 2019 13:59:57 GMT+0900 (한국 표준시)*/ setInterval이 ID 값을 반환하므로 이 ID를 써서 실행을 멈출 수 있다. clearInterval이 반환하는 ID값을 받아 타임아웃을 종료 14.2.2 스코프와 비동기적 실행 비동기적 실행에서 혼란스럽고 에러가 자주 일어나는 부분은 스코프와 클로저가 비동기적 실행에 영향을 미치는 부분이다.함수를 호출하면 항상 클로저가 만들어진다. 매개변수를 포함해 함수 안에서 만든 변수는 모두 무언가가 자신에 접근 할 수 있는한 계속 존재 countdown 오류12345678910111213//5초 카운트 다운function countdown(){ let i; //i를 for 루프 밖에서 실행 console.log(\"Countdown\"); for(i=5; i&gt;=0; i--){ setTimeout(function(){ console.log(i===0 ? \"Go\":i) },(5-i)*1000); }}countdown();//-1이 6번 나옴 var가 아닌 let 변수를 for 루프 밖에서 선언했으므로 같은 문제가 발생한다. 즉 for 루프가 실행을 마치고, i의 값이 -1이 된 다음에야 콜백이 실행된다. 여기서 i는 두 가지 방법으로 사용됬다. 1. (5-i)이는 첫번째 타임아웃 : 0 , 두번쨰 : 1000, 세번쨰 : 2000 이렇게 동기적으로 실행된다. countdown 문제해결123456789101112131415161718192021//1. 즉시표현식var count= function(i){console.log(\"Countdown\"); for(let i=5; i&gt;=0; i--){ setTimeout(function(){ console.log(i===0 ? \"Go\":i) },(5-i)*1000); }}();//2. for 루프 안에 let i 선언function countdown(){ // let i; i를 for 루프 밖에서 실행 console.log(\"Countdown\"); for(let i=5; i&gt;=0; i--){ setTimeout(function(){ console.log(i===0 ? \"Go\":i) },(5-i)*1000); }}countdown(); 즉시 호출하는 함수 표현식(IIFE)를 쓰거나, 더 간단하게는 for 루프 선언부에서 let i 를 쓰는 방식으로 해결 가능 콜백은 자신을 선언한 스코프(클로저)에 있는 것에 접근 할 수 있다. 그러므로 i의 값은 콜백이 실행되는 순간마다 다를 수 있다. 이 원칙은 모든 비동기적 테크닉에 적용된다. 14.2.3 우선 오류 콜백 우선 오류 콜백 : 콜백을 사용하면 예외 처리가 어려워 지므로, 콜백과 관련된 에러를 처리할 표준이 필요이에 따라 콜백의 첫 번쨰 매개변수에 에러 객체를 쓰자는 것이 등장에러가 null이나 undefined 이면 에러가 없는 것우선 오류 콜백에서 가장 먼저 생각할 것은에러 매개변수를 체크하고 그에 맞게 반응한다는 것 123456//노드에서 파일 콘텐츠를 읽을 떄 우선 오류 콜백을 사용할 경우const fs = require('fs');const fname = 'may_or_may_not_exist.txt';fs.readFile(fname, function(err,data){ if(err) return console.error(`error reading file ${fname}:${err.message}`);}); 콜백에서 가장 먼저 하는 일은 err 가 참 같은 값인지 확인하는 것 err가 참 같은 값이면 파일을 읽는 데 문제가 있다는 뜻이므로 콘솔에 오류를 보고하고 즉시 빠져나옵니다. 우선 오류 콜백을 사용할때 많이 하는 실수는 빠져나와야 한다는 사실을 잊는 다는 것 프라미스를 사용하지 않으면 우선 오류 콜백은 노드 개발의 표준이나 다름없음 14.2.4 콜백 헬 콜백 헬 : 중괄호로 둘러쌓여 끝없이 중첩된 삼각형의 코드 블록 14.3 프라미스 프라미스 : 콜백의 단점을 해결하려는 시도에서 만들어짐프라미스가 콜백을 대체하는 것은 아니다. 프라미스는 콜백을 예측 가능한 패턴으로 사용할 수 있게 한다. 프라미스 기반 비동기 함수를 호출하면 그 함수는 promise 인스턴스를 반환 성공(fulfilled)하거나, 실패(rejected) 하는 단 두가지 뿐 성공한 프라미스가 나중에 실패할 일 같은 경우는 없음 단 한번만 일어난다. -&gt; 그 프라미스를 결졍됐다(settled)고 한다. 프라미스는 객체이므로 어디든 전달 할수 있다.(음식점에서 받은 예약 호출기를 친구에게 맡기는 것과 비슷) 14.3.1 프라미스 만들기 성공(resolve)와 실패(reject) 콜백이 있는 함수로 새 promise 인스턴스를 만들기만 하면 된다. 1234567891011121314151617181920212223// 5초 카운트 다운에 매이지 않고, 카운트가 끝나면 프라미스를 반환function countdown(seconds){ return new Promise(function(resolve,reject){ for(let i =seconds; i&gt;=0; i--){ setTimeout(function(){ if(i&gt;0) console.log(i + \"...\"); else resolve(console.log(\"GO\")); },(seconds-i)*1000); } });}/*결과5...4...3...2...1...GO만약 이 함수가 실패하면 \"GO\"를 반환*/ resolve와 reject는 함수이다. resolve를 여러번 호출해도 결과는 같다. 첫 번째로 호출한 것만 의미 있다. 프라미스는 성공 또는 실패를 나타낼 뿐이다. 14.3.2 프라미스 사용프라미스 사용(카운트다운)12345678910111213141516171819202122//13을 만나면 에러를 내는 함수function countdown(seconds){ return new Promise(function(resolve,reject){ for(let i =seconds; i&gt;=0; i--){ setTimeout(function(){ if(i === 13) return reject(new Error(\"oh my god\")); if(i&gt;0) console.log(i + \"...\"); else resolve(console.log(\"GO\")); },(seconds-i)*1000); } });}/*15...14...Uncaught (in promise) Error: oh my god12...11...10... 9...*/ 13에서 에러가 발생, 그러나 콘솔에는 12부터 다시 카운트를 기록한다. reject나 resolve가 함수를 멈추지는 않는다. 그저 프라미스의 상태를 관리할 뿐이다. 즉, 프라미스는 비동기적 작업이 성공 또는 실패하도록 확정하지만, 현재는 진행 상황을 전혀 알려주지 않는다. 즉, 프라미스는 완료되거나 파기될 뿐 50% 진행되었다.라는 개념자체가 없다. 14.3.3 이벤트 이벤트가 일어나면 이벤트 발생을 담당하는 개체(emitter)에서 이벤트가 일어났음을 알린다.필요한 이벤트는 모두 주시(listen)할 수 있다. 콜백을 통해서 가능노드에서 이벤트를 지원하는 모듈 EventEmitter가 내장됨EventEmitter는 클래스와 함께 사용하도록 설계 12345678910111213141516171819202122232425262728293031323334353637//countdown 함수를 countdown 클래스로 변경const EventEmitter = require('events').EventEmitter;class Countdown extends EventEmitter{ constructor(seconds,superstitious){ super(); this.seconds = seconds; this.superstitious = !!superstitious; } go(){ const countdown = this; const timeoutIds = []; return new Promise(function(resolve,reject){ for(let i = countdown.seconds; i&gt;=0; i--){ timeoutIds.push(setTimeout(function(){ if(countdown.superstitious &amp;&amp; i ===13){ //대기중인 타임아웃을 모두 취소 timeoutIds.forEach(clearTimeout); return reject(new Error('oh my god')); } countdown.emit('trick',i); if(i === 0) resolve(); },(countdown.seconds-i)*1000)); } }); }}//카운트다운 사용const c = new Countdown(5);c.on('trick',function(i){ if(i&gt;0) console.log(i+\"...\");});c.go().then(function(){ console.log('go');}).catch(function(err){ console.log(err.message);}); EventEmitter를 상속하는 클래스는 이벤트를 발생시킬 수 있다. 실제 카운트다운을 시작하고 프라미스를 반환하는 부분은 go 메서드이다. go메서드에서 1) const countdown = this; 즉 countdown에 this를 할당 2) 카운트가 얼마나 남았는지 알려면 this 값을 알아야한다. 14.3.4 프라미스 체인 프라미스에는 체인으로 연결할 수 있다는 장점이 존재프라미스가 완료되면 다른 프라미스를 반환하는 함수를 즉시 호출 가능 프라미스 체인12345678910111213141516function launch(){ return new Promise(function(resolve,reject){ console.log(\"Lift off\"); setTimeout(function(){ resolve(\"in orbit\"); },5*1000); //2초만에 궤도도달 });}//이 함수를 카운트다운에 쉽게 묶을 수 있다.const c = new Countdown(5).on('trick',i =&gt; console.log(i + \"...\"));c.go().then(launch).then(function(msg){ console.log(msg);}).catch(function(err){ console.error(\"houston, we have a problem...\");}); 프라미스 체인을 사용하면 모든 단계에서 에러를 캐치할 필요가 없다. 체인 어디서든 에러가 생기면 체인 전체가 멈추고 catch 핸들러가 동작한다. 14.3.5 결졍되지 않는 프라미스 방지하기 프라미스는 비동기적 코드를 단순화하고 콜백이 두 번 이상 실행되는 문제를 방지하지만, reslove나 reject를 호출하는 걸 잊어서 프라미스가 결정되지 않는 문제까지 자동으로 해결하지는 못함결정되지 않는 프라미스를 방지하는 방법은 프라미스에 타임아웃을 거는 것 14.4 제너레이터 제너레이터는 함수와 호출자 사이의 양방향 통신을 가능하게 함.제너레이터는 동기적 성격을 지녔지만, 프라미스와 결합하면 비동기 코드를효율적으로 관리 가능 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//파일 3개를 읽고 1분간 기다린 다음 그 내용을 합쳐서 네 번째 파일에 작성//1. 노드의 콜백 오류를 프라미스로 바꾸기 function nfcall(f,...args){ return new Promise(function(resolve,reject){ f.call(null,...args,function(err,...args){ if(err) return reject(err); resolve(args.length&lt;2 ? args[0]:args); }); });}//2. setTimeout을 써야하는데, 이는 오류 우선 콜백 패턴을 따르지 않으므로 같은 기능을 가진 ptimeout(promise timeout) 함수를 만든다.function ptimeout(delay){ return new Promise(function(resolve,reject){ setTimeout(resolve,delay); });}//3. 제너레이터 실행기// 제너레이터는 동기적이지만, 호출자와 통신 가능하므로 제너레이터와의 통신을 관리하고, 비동기적 호출을 처리하는 함수 grun을 만듬 function grun(g){ const it = g(); (function iterate(val){ const x = it.next(val); if(!x.done){ if(x.value instanceof Promise){ x.value.then(iterate).catch(err =&gt; it.throw(err)); }else{ setTimeout(iterate,0,x.value); } } })();}//grun은 제너레이터 실행기이고, yield로 값을 넘긴 제너레이터는 이터레이터에서 next를 호출할 때까지 기다린다. function* theFutureIsNow(){ const dataA = yield nfcall(fs,readFile, \"a.txt\"); const dataB = yield nfcall(fs,readFile, \"b.txt\"); const dataC = yield nfcall(fs,readFile, \"c.txt\"); yield ptimeout(60*1000); yield nfcall(fs.writeFile,\"d.txt\",dataA + dataB + dataC);}grun(theFutureIsNow); 14.4.2 제너레이터 실행기를 직접 만들지 마세요co(link: https://github.com/tj/co) kos 미들웨어(link: https://koajs.com/) 14.4.3 제너레이터 실행기와 예외처리 제너레이터 실행기를 쓰면 try/catch를 써서 예외 처리가 가능콜백이나 프라미스를 사용하면 예외 처리가 쉽지 않다.제너레이터 실행기는 비동기적으로 실행하면서도 동기적인 동작 방식을 유지하므로 try/catch문과 함께 쓸 수 있다. 제너레이터 실행기와 예외처리12345678910111213141516171819202122function* theFutureIsNow(){ let data; try{ data = yield Promise.all([ nfcall(fs.readFile, \"a.txt\"), nfcall(fs.readFile, \"b.txt\"), nfcall(fs.readFile, \"c.txt\"), ]); }catch(err){ console.error(\"unable to read..\" + err.message); throw err; } yield ptimeout(60 * 1000); try{ yield nfcall(js.writeFile, \"d.txt\", data[0] + data[1] + data[2]); } catch(err){ console.err(\"unable to write output file\"+ err.message); throw err; }}grun(theFutureIsNow); 14.5 요약 요약내용 자바스크립트의 비동기적 실행은 콜백을 통해 이루어진다. 프라미스를 콜백 대신 사용할 수 있는 것은 아니다. 프라미스 역시 콜백을 사용 프라미스는 콜백이 여러 번 호출되는 문제를 해결 콜백을 여러 번 호출해야 한다면 이벤트와 결합하는 방법도 있다.(프라미스도 함께 쓸 수 있다.) 프라미시는 반드시 결졍된다는(성공 or 실패한다는) 보장은 없다. 다만 프라미스에 타임아웃을 걸면 이 문제가 해결 프라미스는 체인으로 연결 할 수 있다. 프라미스와 제너레이터 실행기를 결합하면 비동기적 실행의 장점을 유지하면서도 동기적인 사고 방식으로 문제 해결 가능 제너레이터를 써서 동기적인 사고방식으로 문제를 해결 할 땐, 프로그램의 어느 부분에서 동시에 실행할 수 있는지 잘 봐야함. 동시에 실행할 부분은 Promise.all을 써서 실행 제너레이터 실행기 직접 만들지 말기 노드 스타일 콜백을 프라미스로 바꿀 필요도 없다. Q를 써라 제너레이터 실행기를 쓰면 예외 처리도 익숙한 방식으로 할 수 있다.","link":"/2019/08/01/chapter14/"},{"title":"chapter8. 배열과 배열 처리","text":"8.1 배열의 기초 1) 배열은 객체와 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다.2) 자바스크립트 배열은 비균질적입니다. 즉 한 배열의 요소가 모두 같은 타입일 필요는 없습니다.다른 배열이나 객체도 포함 할 수 있습니다.3) 배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근할 때도 대괄호[]를 사용합니다.4) 모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다.5) 배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하면 배열은 자동으로 그 인덱스에 맞게 늘어나며,빈 자리는 undefined로 채워집니다.6) Array 생성자를 써서 배열을 만들수도 있습니다.(별로 사용하진 않음) 1234567891011121314151617181920212223242526272829303132333435363738394041//배열 리터럴const arr1 = [1,2,3]; //숫자배열const arr2 = [\"one\",2,\"three\"] //비균질적 배열const arr3 = [[1,2,3], [\"one\",2,\"three\"]]//배열을 포함한 배열const arr4 = [ //비균질적 배열 {name :\"Fred\",type :\"object\", luckyNumbers=[5,7,13] },[ {name :\"Susan\",type:\"object\"}, {name :\"Anthony\",type:\"object\"},],1,function(){return 'arrays can contain functions too'},\"three\",]; //배열 요소에 접근하기arr1[0]; //1arr1[2]; //3arr3[1] //[\"one\",2,\"three\"]arr4[1][0] //{name :\"Susan\",type:\"object\"} //배열 길이arr1.length; //3arr4.length; //5arr4[1].length //2 //배열 길이 늘리기 arr1[4] = 5; //[1, 2, 3, undefined, 5]arr1.length // 5 //배열의 현재 길이보다 큰 인덱스에 접근하는 것 만으로는 길이가 늘어나지 않음arr2[10];//undefined;arr2.length //3 //Array 생성자 const arr5 = new Array(); //빈 배열 생성 const arr6 = new Array(1,2,3) //[1,2,3]const arr7 = new Array(2) //(2) [empty × 2] 길이가 2개인 빈 배열 const arr8 = new Array(\"2\");//[\"2\"]; 8.2 배열 요소 조작 배열 메서드 중 일부는 배열 ‘자체를’ 수정하며, 다른 일부는 새 배열을 반환한다. push : 배열 자체를 수정 concat : 새 배열을 반환 8.2.1 배열의 처음이나 끝에서 요소 하나를 추가하거나 제거하기 배열의 처음 : 인덱스가 0인 요소배열의 끝 : 인덱스가 가장 큰 요소 arr.length - 1인 요소 push() : 배열의 끝에서 요소를 추가 pop() : 배열의 끝에서 요소를 제거 ※ 데이터를 수직으로 쌓아올리는 스택 stack 에 해당하는 행동 shift() : 배열의 앞에서 요소를 제거 unshift() : 베열의앞에서 요소를 추가 ※ 대기열과 비슷한 큐 stack 에 해당하는 행동 12345const arr = [\"b\",\"c\",\"d\"];arr.push(\"e\"); //arr = [\"b\",\"c\",\"d\",\"e\"];arr.pop(); // arr = [\"b\",\"c\",\"d\"];arr.unshift(\"a\"); // arr = [\"a\",\"b\",\"c\",\"d\"];arr.shift();//arr = [\"b\",\"c\",\"d\"]; 8.2.3 배열 일부 가져오기 *slice(a,b) : *배열의 일부를 가져옴 a : 어디서부터 가져올지, b : 어디까지 가져올지(바로 앞 인덱스까지) 지정 두번째 매개변수를 생략하면 배열의 마지막까지 반환음수 인덱스를 쓸수 있고, 음수 인덱스를 쓰면 배열의 끝에서부터 요소를 센다. slice12345678//sliceconst arr = [1,2,3,4,5];arr.slice(3); // [4,5]arr.slice(2,4); //[3,4]arr.slice(-2); //[4,5]arr.slice(1,-2); //[2,3]arr.slice(-2,-1); //[4]//arr는 바뀌지 않는다. 8.2.4 임의의 위치에 요소 추가하거나 제거하기 splice(a,b,c) : 배열을 수정 a : 수정을 시작할 인덱스 , b: 제거할 요소 숫자 (아무것도 제거하지 않을땐 0 ) c : 배열에 추가될 요소 splice123456//splice const arr = [1,5,7];arr.splice(1,0,2,3,4); //[1,2,3,4,5,7];arr.splice(5,0,6); //[1,2,3,4,5,6,7];arr.splice(1,2); // [1,4,5,6,7];arr.splice(2,1,\"a\",\"b\"); // [1,4,\"a\",\"b\",6,7]; 8.2.5 배열 안에서 요소 교체하기 copyWithin(a,b,c) : ES6에서 새로도입한 메서드 a : 복사한 요소를 붙여넣을 위치 b : 복사할 위치 c : 복사를 끝낼 위치 (생략가능) slice과 마찬가지로 음수 인덱스를 사용하면 배열의 끝에서 부터 센다. 12345678910111213141516171819202122//copywithinconst arr = [1,2,3,4];arr.copyWithin(1,2);//[1, 3, 4, 4]arr.copyWithin(2,0,2);//[1, 3, 1, 3]arr.copyWithin(0,-3,-1); //[3, 1, 1, 3]``` ## 8.2.6 특정 값으로 배열 채우기* **fill()**: 정해진 값으로 배열을 채움 크기를 지정해서 배열을 생성하는 Array 생성자와 아주 잘 어울림 배열의 일부만 채우려고 할때는 시작 인덱스와 끝 인덱스를 지정 음수 인덱스도 사용할 수 있다. ```javascript fill //fill const arr = new Array(5).fill(1);//[1,1,1,1,1]; arr.fill(\"a\"); // [\"a\", \"a\", \"a\", \"a\", \"a\"] arr.fill(\"b\",1);//[\"a\", \"b\", \"b\", \"b\", \"b\"] arr.fill(\"c\",2,4);//[\"a\", \"b\", \"c\", \"c\", \"b\"] arr.fill(5.5,-4); //[\"a\", 5.5, 5.5, 5.5, 5.5] arr.fill(0,-3,-1); //[\"a\", 5.5, 0, 0, 5.5] reverse() : 배열의 요소를 반대로 바꿈 sort() : sort는 배열의 요소의 순서를 정렬 (오름차순) reverse&sort1234567//reverse const arr = [1,2,3,4,5]; arr.reverse(); // [5,4,3,2,1] //sort const arr = [5,3,2,4,1]; arr.sort(); // [1,2,3,4,5]; 8.3 배열 검색 indexOf() : 찾고자 하는 것과 정확히 일치(===)하는 첫 번째 요소의 인덱스를 반환 lastIndexOf() : 배열의 끝에서부터 검색 배열의 일부분을 검색하려면 시작 인덱스를 지정 일치하는 것을 못찾으면 -1을 반환 indexOf1234567891011121314151617//indexOf const o = {name : \"Jerry\"};const arr = [1,5,\"a\",o,true,5,[1,2],\"9\"];arr.indexOf(5);//1arr.lastIndexOf(5);//5arr.indexOf(\"a\"); //2arr.lastIndexOf(\"a\"); //2arr.indexOf( {name : \"Jerry\"} ); //-1arr.indexOf(o); //3arr.indexOf([1,2]); //-1arr.indexOf(\"9\"); //7arr.indexOf(9); //-1 arr.indexOf(\"a\",5) //-1arr.indexOf(5,5) //5arr.lastIndexOf(5,4) //1arr.lastIndexOf(true,3) //-1순으로 정렬 findIndex() : 보조함수를 써서 검색 조건을 지정할 수 있다. 하지만 검색을 시작할 인덱스를 지정할 수 없고, 뒤에서 부터 찾을 수도 없다. findIndex123456findIndexconst arr = [{id : 5 , name: \"Judith\"}, {id : 7 , name: \"Francis\"}];arr.findIndex(o =&gt; o.id===5); //0arr.findIndex(o =&gt; o.name ==='Francis'); //1 arr.findIndex(o =&gt; o ===3); //-1arr.findIndex(o =&gt; o.id ===17); //-1 find() : indexOf와 findIndexOf()는 조건에 맞는 요소의 인덱스를 찾을 때 알맞지만, 요소의 인덱스가 아닌 요소 자체를 찾을때 조건에 맞는 요소가 없을 때 undefined를 반환 find123const arr = [{id : 5 , name: \"Judith\"}, {id : 7 , name: \"Francis\"}];arr.find(o =&gt; o.id===5); //{id: 5, name: \"Judith\"}arr.find(o =&gt; o.id===2); //undefined find와 findIndex에 전달하는 함수는 배열의 각 요소를 첫번째 매개변수로 받고,현재 요소의 인덱스와 배열 자체도 매개변수로 받는다. 특정 인덱스보다 뒤에 있는 제곱수를 찾아야 한다. 12const arr = [1,17,16,5,4,16,10,3,49];arr.find((x,i) =&gt; i &gt;2 &amp;&amp; Number.isInteger(Math.sqrt(x))); find와 findIndex에 전달하는 함수의 this도 수정 할 수 있다. 함수가 객체의 메서드인 것처럼 호출 할 수 있다. 간혹, 조건을 만족하는 요소의 인덱스나 요소 자체가 아닌, 단순히 조건을 만족하는 요소가 있는지 없는지만 알아도 될때 some() : 조건에 맞는 요소를 찾으면 즉시 검색을 멈추고 true 를 반환, 찾지 못하면 false를 반환 every() : 배열의 모든 요소가 조건에 맞아야 true를 반환하며, 그렇지 않으면 false를 반환 조건에 맞지 않은 요소를 찾아야만 검색을 멈추고 false를 반환 some&every123456789//someconst arr = [5,7,12,15,17];arr.some(x =&gt; x%2 ===0); //짝수 찾기 12가 짝수이므로 truearr.some(x =&gt; Number.isInteger(Math.sqrt(x))); //제곱수 false //everyconst arr = [4,6,16,36];arr.every(x =&gt; x%2 ===0); //짝수찾기 모든 요소가 짝수 true arr.every(x =&gt; Number.isInteger(Math.sqrt(x))); //false 6이 제곱수가 아님 8.4 map과 filter map(a,i) : 배열 요소를 변형 , 사본을 반환하며 원래 배열은 바뀌지 않는다. a : 요소 i :인덱스 filter() : 배열에서 필요한 것들만 남김, 사본을 반환하며 새 배열에는 필요한 요소만 남음 map&filter12345678910111213141516171819202122232425262728293031323334353637383940//mapconst cart =[{name : 'Widget',price : 9.95},{name : 'Gadget',price : 22.95}];const names = cart.map(x =&gt; x.name); // ['Widget','Gadget'];const prices = cart.map(x =&gt; x.price); // [9.95,22.95];const disCountPrices = prices.map(x =&gt; x*0.8); //[7.96,18.36]; //filterconst cards = [];for(let suit of [\"H\",\"C\",\"D\",\"S\"]) for(let value=1; value&lt;=13; value++) cards.push({suit,value}); //value가 2인 카드cards.filter(c =&gt; c.value ===2);/*[0: {suit: \"H\", value: 2}1: {suit: \"C\", value: 2}2: {suit: \"D\", value: 2}3: {suit: \"S\", value: 2}]*/ //다이아몬드cards.filter(c =&gt; c.suit ===\"D\"); //length = 13 //킹,퀸,주니어cards.filter(c =&gt; c.value &gt; 10); //length = 12 //하트의 킹,퀸,주니어cards.filter(c =&gt; c.suit ===\"H\" &amp;&amp; c.value&gt; 10); //length = 12/*[0: {suit: \"H\", value: 11}1: {suit: \"H\", value: 12}2: {suit: \"H\", value: 13}length: 3]*/ 8.5 배열의 마법 reduce reduce(a,b,i) : 배열 자체를 변형, 배열을 값 하나로 줄이는데 쓰임 a : 누적값 b: 현재값 i : 인덱스 예) 배열에 들어있는 숫자를 더하거나, 평균을 구하는 것 배열의 값을 하나로 줄이는 동작 reduce가 반환하는 값 하나는 객체일 수도 있고, 다른 배열일 수도 있다. 1. map과 filter와 마찬가지로 콜백 함수를 받는다. 2. reduce가 받는 첫 번째 매개변수는 배열이 줄어드는 대상인 어큐물레이터이다. 3. reduce는 초기값도 옵션으로 받을 수 있다. reduce12const arr = [5,7,2,4];const sum = arr.reduce((a,x)=&gt; a +=x,0); //sum =18 reduce의 콜백함수는 매개변수로 누적값 a와 현재배열요소 x를 받음 누적값 : 0 으로 시작 12const arr = [5,7,2,4];const sum = arr.reduce((a,x)=&gt; a +=x); //sum =18 위 처럼 첫번째 배열 요소가 그대로 초기값이 될 경우에는 초기값을 생략해도된다. reduce는 보통 숫자나 원시 값을 누적값으로 사용하지만, 객체 또한 누적값이 될 수 있다. 예)영단어로 이뤄진 배열이 있고, 각 단어를 첫 글자에 따라 묶는 예제 12345678910111213141516//영단어로 이뤄진 배열이 있고, 각 단어를 첫 글자에 따라 묶는 예제 const words = [\"Beachball\",\"Redeo\",\"Angel\",\"Adrdvark\",\"Xylphone\"];const alphabetical = words.reduce((a,x) =&gt; { if(!a[x[0]]) a[x[0]] =[]; a[x[0]].push(x); return a;}, {}); /*{B: Array(1), R: Array(1), A: Array(2), X: Array(1)}A: (2) [\"Angel\", \"Adrdvark\"]B: [\"Beachball\"]R: [\"Redeo\"]X: [\"Xylphone\"] */ 1. 배열의 모든 요소에서 콜백 함수는 전 단계의 결과에 이 단어의 첫번째 글자인 프로퍼티가 있는지 확인 2. 그런 프로퍼티가 없다면 빈 배열을 추가 예) 문자열을 누적값으로 사용 123456789101112const words = [\"Beachball\",\"Redeo\",\"Angel\",\"Adrdvark\",\"Xylphone\"]; const longWords = words.reduce((a,w)=&gt; w.length &gt; 6 ? a + \" \" : a ,\"\" ).trim(); //trim() : 문자열 좌우 공백제거 메서드/* longWords \"Beachball Adrdvark Xylphone\" */ 8.6 삭제되거나 정의되지 않은 요소들&gt; Array 메서드에서, 삭제되거나 정의되지 않은 요소들에서 이상하게 동작하기도 한다. map,filter,reduce는 삭제되거나 정의되지 않는 요소들에서 콜백함수를 호출하지 않는다. 123456789//삭제되거나 정의되지 않은 요소들 const arr = Array(10).map(function(x){return 5}); /*//arr//(10) [empty × 10]*///arr는 전부 undefined 123456const arr = [1,2,3,4,5];delete arr[2]; //arr : (5) [1, 2, empty, 4, 5]arr.map(x =&gt; 0); //[0,0,undefined,0,0]//(5) [0, 0, empty, 0, 0]//배열 중간 요소를 삭제하고 map을 호출하면 가운데 구멍이 생김 8.7 문자열 병합 Array.prototype.join() : 매개변수로 구분자 하나를 받고 요소들을 하나로 합친 문자열을 반환 매개변수가 생략되면 기본값은 쉼표(,) 정의되지 않은 요소, 삭제된 요소,null,undefined 모두 빈 문자열로 취급한다. 123456//문자열 병합 const arr = [1,null,\"hello\",\"world\",true,undefined];delete arr[3];arr.join(); //\"1,,hello,,true,\" arr.join(''); //\"1hellotrue\"arr.join(' -- '); //\"1 -- -- hello -- -- true -- \" *8.8 요약 * 표 8-1 배열 함수의 매개변수(순서대로) 메서드설명reduce에만 적용누적값, 초깃값 또는 마지막 호출에서 반환한 값모든 메서드요소(현재 요소의 값)모든 메서드현재 요소의 인덱스모든 메서드배열 자체(그다지 쓸모는 없음) 콜백을 받는 메서드들은 옵션으로 콜백을 호출할 때 this로 사용한 값을 받을 수 있다. 표 8-2 배열 콘텐츠 조작 하고 싶은 일사용할 메서드수정 또는 사본스택(후입 선출)을 만들때push(바뀐 길이 반환), pop배열 수정큐(선입 선출)을 만들때&nbsp;unshift(바뀐 길이 반환),shift배열 수정여러 요소를 배열 마지막에 추가할 때concat사본 반환배열 일부가 필요할 때slice사본반환임위의 위치에 요소를 추가하거나 제거splice배열 수정배열 안에서 요소를 교체copyWithin배열 수정배열을 채울 때fill배열 수정배열 반대 정렬reverse배열 수정배열 정렬sort(정렬 함수 사용 가능)배열 수정&nbsp; 표 8-3 배열 검색 찾고자 하는 것사용할 메서드요소의 인덱스indexOf(단순한 값), findIndex(복잡한 값)인덱스를 뒤에서 부터 찾을 때lastIndexOf(단순한 값)요소 자체find조건을 만족하는 요소가 들어 있는지 확인some모든 요소가 그 조건을 만족하는지 확인every 표 8-4 배열 변형 하고 싶은 일사용할 메서드수정 또는 사본배열의 모든 요소를 변형map사본 반환조건에 맞는 요소만 남김fill사본 반환배열 전체를 다른 데이터 타입으로 변형reduce사본 반환요소를 문자열로 바꿔서 하나로 합침join&nbsp;사본 반환&nbsp; [##Image|kage@FQF0t/btqwDJ8nvzH/toKJ3Ysq9UFUuAszaHgM0k/img.jpg|alignCenter|data-filename=”B2328850940_l.jpg” width=”154” height=”198”|러닝 자바스크립트##]","link":"/2019/07/15/chapter8/"}],"tags":[{"name":"map","slug":"map","link":"/tags/map/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"이터레이터","slug":"이터레이터","link":"/tags/이터레이터/"},{"name":"제너레이터","slug":"제너레이터","link":"/tags/제너레이터/"},{"name":"git세팅","slug":"git세팅","link":"/tags/git세팅/"},{"name":"스코프","slug":"스코프","link":"/tags/스코프/"},{"name":"if","slug":"if","link":"/tags/if/"},{"name":"for","slug":"for","link":"/tags/for/"},{"name":"제어문","slug":"제어문","link":"/tags/제어문/"},{"name":"프로퍼티","slug":"프로퍼티","link":"/tags/프로퍼티/"},{"name":"클래스","slug":"클래스","link":"/tags/클래스/"},{"name":"인스턴스","slug":"인스턴스","link":"/tags/인스턴스/"},{"name":"배열","slug":"배열","link":"/tags/배열/"}],"categories":[{"name":"러닝자바스크립트","slug":"러닝자바스크립트","link":"/categories/러닝자바스크립트/"}]}