{"pages":[],"posts":[{"title":"chapter1. 첫 번째 에플리케이션","text":"1.2 사용할 프로그램 1) 문법 하이라이트2) 괄호 맞추기3) 코드접기4) 자동완성 1.3 주석에 관해12345//인라인주석/* 들여쓰기 블록주석*//* 들여쓰기 안한 주석 * 1.5 자바스크립트 콘솔1console.log(\"hello world\"); 1.6 제이쿼리12&lt;script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-3.4.1.min.js\"&gt;&lt;/script&gt;cs 1.7 단순한 그래픽 그리기index.html1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt; &lt;head&gt; &lt;link rel=\"stylesheet\" href=\"main.css\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=\"mainCanvas\"&gt;&lt;/canvas&gt; &lt;script type=\"text/javascript\" src=\"https://code.jquery.com/jquery-3.4.1.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/paper.js/0.9.25/paper-full.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"main.js?v=1.0\"&gt;&lt;/script&gt; &lt;script&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; main.js123456789101112131415$(document).ready(function(){ 'use strict'; paper.install(window); paper.setup(document.getElementById('mainCanvas')); //TODO var c = Shape.Circle(200,200,50); c.fillColor = 'green'; paper.view.draw(); console.log(\"main.js loaded\");}); 1.8 반복적인 작업 자동화하기1234567891011121314151617181920$(document).ready(function(){ 'use strict'; paper.install(window); paper.setup(document.getElementById('mainCanvas')); //TODO var c; for(var x=25; x&lt;400; x+=50){ for(var y=35; y&lt;400;y +=50){ c = Shape.Circle(x,y,20); c.fillColor ='green'; } } paper.view.draw(); //console.log(\"main.js loaded\");}); 1.9 사용자 입력 처리하기 비동기적 이벤트 : 이벤트가 언제 일어날지 프로그래머가 전혀 알 수 없는 이벤트사용자 입력은 항상 “비동기적”이다.ex) 사용자의 마우스 클릭 12345678910111213141516171819 $(document).ready(function(){ 'use strict'; paper.install(window); paper.setup(document.getElementById('mainCanvas')); //TODO var tool = new Tool(); //tool 객체 생성 tool.onMouseDown = function(event){ //onMouseDown 이벤트 핸들러 연결 var c = Shape.Circle(event.point.x, event.point.y, 20); c.fillColor =\"yellow\"; } paper.view.draw(); console.log(\"main.js loaded\");});","link":"/2019/06/24/es6_md/chapter1/"},{"title":"chapter10. 맵과 셋","text":"10.1 맵 ES6 이전에는 키와 값을 연결하려면 객체를 사용해야함, 여러 단점 생성 프로토타입 체인으로 인해 의도하지 않은 연결이 생길 수 있음 객체 안에 연결된 키와 값이 몇 개인지 쉽게 알수 없음 키는 반드시 문자열이나 심볼이여야 하므로 객체를 키로 써서 값과 연결할 수 없음 객체는 프로퍼티 순서를 보장하지 않음 map123456789101112131415161718192021222324//mapconst u1= {name : 'Cynthia'};const u2= {name : 'Jackson'};const u3= {name : 'Olive'};const u4= {name : 'James'};const userRoles = new Map(); //맵 생성//set()을 사용해 사용자 역할 할당//set()은 체인으로 연결 할 수 있음userRoles .set(u1,'User') .set(u2,'User') .set(u3,'Admin');//생성자에 배열의 배열을 넘기는 형태로 써도됨const userRoles = new Map([ [u1,'User'], [u2,'User'], [u3,'Admin'],]);//u2의 role은? get();userRoles.get(u2); //\"User\" 맵에 존재하지 않은 키에 get()을 호출하면 undefined를 반환has() : 맵에 키가 존재하는지 확인 get&has12345//get()과 has()userRoles.has(u1)//trueuserRoles.get(u1) //\"User\"userRoles.has(u4) //falseuserRoles.get(u4) //undefined 맵에 이미 존재하는 키에 set()을 호출하면 값이 교체 set()으로값교체1234//set()으로 값 교체userRoles.get(u1); //\"User\"userRoles.set(u1,\"Admin\"); userRoles.get(u1); //\"Admin\" size : 맵의 요소 숫자를 반환 size1userRoles.size; //3 keys() : 맵의 키value() : 값entries() : 첫번째 요소가 키이고 두번째 요소가 값인 배열 반환 모두 for…of 루프를 사용할 수 있다. keys,value,entries1234567891011121314151617181920212223242526272829303132333435363738394041424344454647for(let u of userRoles.keys()) console.log(u.name); /* Cynthia Jackson Olive */for(let r of userRoles.values()) console.log(r); /* Admin User Admin */for(let ur of userRoles.entries()) console.log(`${ur[0].name}:${ur[1]}`); /* Cynthia:Admin Jackson:User Olive:Admin *///맵도 분해 가능 for(let [u,r] of userRoles.entries()) console.log(`${u.name}:${r}`); /* Cynthia:Admin Jackson:User Olive:Admin *///entries() 메서드는 맵의 기본 이터레이터//단축 가능합니다.for(let[u,r] of userRoles) console.log(`${u.name}:${r}`); /* Cynthia:Admin Jackson:User Olive:Admin */ delete() : 맵의 요소를 지움 delete()123//delete() :맵의 요소를 지움userRoles.delete(u2);userRoles.size //2 clear() : 맵의 모든 요소를 지움 clear()123//clear() : 맵의 모든 요소를 지움userRoles.clear();userRoles.size //0 10.2 위크맵 WeakMap은 다음 차이점을 제외하면 Map과 완전히 같다. 키는 반드시 객체여야한다. WeakMap의 키는 가비지 콜렉션에 포함 될 수 있다. WeakMap은 이터러블이 아니며 clear() 메서드도 없다. 자바스크립트 코드는 코드 어디에서 객체를 참조하는한 객체를 메모리에서 계속 유지 WeakMap은 그렇지 않으므로, 객체 인스턴스의 전용(private)한 키를 저장하기에 알맞는다. WeakMap12345678910111213141516171819//WeakMapconst SecretHolder = (function(){ const secrets = new WeakMap(); return class{ setSecret(secret){ //비밀저장 secrets.set(this, secret); } getSecret(){ //비밀호출 return secrets.get(this); } }})();const a = new SecretHolder();const b = new SecretHolder();a.setSecret('secret A');b.setSecret('secret B');a.getSecret(); //secret A IIEF 내부에서 그 인스턴스의 비밀스러운 내용을 저장할 수 있는 SecretHolder 클래스를 얻게된다. 10.3 셋 Set() : 중복을 허용하지 않는 데이터 집합ㅊ set()123456789101112const roles = new Set();roles.add(\"User\"); //사용자 역할 추가 add();roles.add(\"Admin\"); //관리자 역할 추가 add();/*Set(2) {\"User\", \"Admin\"}*/roles.size; //2 roles.delete(\"User\"); //trueroles //Set(1) {\"Admin\"}roles.delete(\"User\"); //false 10.3 위크셋 WeakSet() : 객체만 포함 할 수 있으며, 이 객체들은 가비지 콜렉션의 대상이됨 이터러블이 아님 주어진 객체가 set 안에 존재하는지 아닌지 판단하는 정도 WeakSet()123456789101112131415161718const naughty = new WeakSet();const childen = [ {name:'Suzy'}, {name : 'Derek'},];naughty.add(childen[1]); //value: {name: \"Derek\"}for(let child of childen){ if(naughty.has(child)) console.log(`Coal for ${child.name}`) else console.log(`presents for ${child.name}`)} /*presents for SuzyCoal for Derek*/","link":"/2019/07/23/es6_md/chapter10/"},{"title":"chapter11. 예외와 예외 처리","text":"11.1 Error 객체 자바스크립트에는 내장된 Error 객체가 있고,이 객체는 에러 처리에 간편하게 사용할 수 있다.Error 인스턴스를 만들면서 에러 메시지를 지정 할 수 있다. error12const err = new Error(\"invalid Error\");//Error: invalid Error at &lt;anonymous&gt;:1:13 11.2 try/catch와 예외 처리 예외처리는 try…catch문을 사용 try...catch12345678910111213141516171819//유효한 이메일인지 체크function validateEmail(email){ return email.match(/@/) ? email : new Error(`invalid email :${email}`);}//try...catchconst email = 'a@d.com';try{ const validateEmail = validateEmail(email); if(validateEmail instanceof Error){ console.log(`Error ${validateEmail.message}`); }else{ console.log(`valid email ${validateEmail}`); }}catch(err){ console.error(`Error ${err.message}`); } 에러를 캐치했으므로 프로그램은 멈추지 않는다. 에러가 일어나면 즉시 catch 블록으로 이동함 validateEmail을 실행한 다음 if 문은 실행되지 않음 11.3 에러 일으키기 자바스크립트는 에러를 일으킬 떄 숫자나 문자열 등 어떤 값이든 catch절에 넘길 수 있다. 현금인출123456789//에러 일으키기/*계좌 잔고(balance)가 요청받은 금액보다 적다면 예외를 발생*/function billPay(amount,payee,account){ if(amount &gt; account.balance) throw new Error(\"insufficient funds\"); account.transfer(payee,amount);} throw를 호출하면 함수는 즉시 실행을 멈춤 따라서, account.transfer(payee,amount)는 실행되지 않는다. 11.4 예외 처리와 호출 스택 호출 스택 : 완료되지 않은 함수가 쌓이는 것 에러는 캐치 될 때까지 호출 스택을 따라 올라감 에러는 호출 스택 어디서든 캐치 할 수 있다. 에러를 캐치하지 않으면 자바스크립트 멈춤 =&gt;처리하지 않은 에러 or 캐치하지 않은 에러 stack 프로퍼티* : Error 인스턴스는 스택을 문자열로 표현한 stack 프로퍼티가 있다. 호출스택1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//에러 처리function a(){ console.log(\"a calling b\"); b(); console.log('a :done');}function b(){ console.log(\"b calling c\"); c(); console.log('b :done');}function c(){ console.log(\"c :throwing Error\"); throw new Error('e error'); console.log('c :done');}function d(){ console.log(\"d calling c\"); c(); console.log('d :done');}try{ a();}catch(err){ console.log(err.stack);}try{ d();}catch(err){ console.log(err.stack);}/*a calling bb calling cc :throwing ErrorError: e error at c (&lt;anonymous&gt;:17:11) at b (&lt;anonymous&gt;:11:5) at a (&lt;anonymous&gt;:5:5) at &lt;anonymous&gt;:28:5d calling cc :throwing ErrorError: e error at c (&lt;anonymous&gt;:17:11) at d (&lt;anonymous&gt;:23:5) at &lt;anonymous&gt;:34:5*/ 11.5 try…catch…finally try블록의 코드가 HTTP 연결이나 파일 같은 ‘자원’을 처리해야 할 때어느 시점에서 이 자원을 해제해야함 try는 에러가 일어나면 자원을 헤재할 기회가 사라질 수 있음 catch는 에러가 없으면 실행되지 않음 finally 에러 관계없이 반드시 호출됨 try...catch...finally123456789101112131415//try...catch...finallytry{ console.log(\"1.this line is executed..\"); throw new Error(\"whoops\"); console.log(\"2.this line is not..\");}catch(err){ console.log(\"3.there was an error...\");}finally{ console.log(\"4....always excuted\");}/*1.this line is executed..3.there was an error...4....always excuted*/","link":"/2019/07/24/es6_md/chapter11/"},{"title":"chapter16. Math","text":"자바스크립트의 숫자는 모두 IEEE 754 64비트 부동소수점 숫자이다.~기호는 그 값의 근삿값이라는 의미이다.Math 객체의 프로퍼티를 메서드라 부르지 않고 함수라고 칭할 것 16.1 숫자 형식 자바스크립트의 숫자 형식 메서드는 모두 숫자가 아닌 문자열을 반환한다.따라서 숫자 형식을 바꾸는 것은 실제로 표시하기 직전에 해아한다.숫자를 저장하거나 계산할 때는 따로 형식을 지정하지 않은 숫자 타입이여야 한다. 16.1.1 고정 소수점 소수점 뒤 자릿수를 지정한느 형식을 원한다면 toFIxed()를 사용이 숫자는 반올림이다. 12345const x = 19.51;x.toFixed(3); //\"19.510\"x.toFixed(2); //\"19.51\"x.toFixed(1); //19.5x.toFixed(0); //20 16.1.2 지수 표기법toExponential()을 사용, 마찬가지로 반올림 123456const x = 3800.5;x.toExponential(4); //3.8005e+3x.toExponential(3); //3.801e+3x.toExponential(2); //3.80e+3x.toExponential(1); //3.8e+3x.toExponential(0); //4e+3 16.1.3 고정 전체 자리수 소수점이 어디 나타나든 관계없이 숫자 몇 개로 표현하느냐가 중요하다면 toPrecison()을 사용반올림 1234567//## 16.1.3 고정 전체 자리수let x = 1000;x.toPrecision(5); //1000.0x.toPrecision(4); //1000x.toPrecision(3); //1.00e+3x.toPrecision(2); //1.0e+3x.toPrecision(1); //1e+3 16.1.4 다른 진수toString(): 2진수나 8진수 16진수 표현등을 할때 사용 123456const x = 12;x.toString(); //12x.toString(10); //12x.toString(16); //cx.toString(8); //14x.toString(2); //1100 16.1.5 고급 숫자 형식 다양한 형식으로 숫자를 표시해야할때 수천자리의 아주 큰 숫자 괄호를 쓰는 등 , 음수 표현을 다르게 해야 하는 경우 공학 표기법Numeral.js(link:http://numeraljs.com/) 라이브러리를 사용 16.2 상수 Math 객체에는 몇 가지 아주 중요한 상수가 프로퍼티로 내장되어 있다. 12345678910111213//기본적인 상수Math.E;Math.PI;//로그 관련 상수Math.LN2;Math.LN10;Math.LOG2E;Math.LOG10E;//대수 관련 상수Math.SQRT1_2;Math.SQRT2; 16.3 대수 함수16.3.1 거듭제곱 제곱 관련 기본 함수는 Math.pow이며 제곱근, 세제곱근, e의 거듭제곱 등 자주 쓰이는 연산에는 간편 함수가 있다. 16.3.2 로그 함수 자연로그 함수는 Math.log이다. 상용로그를 log , 자연로그를 ln이라고 표현하는 언어도 있으므로, 자바스크립트의 log는 자연로그라고 기억해야한다.ES6에서는 자주 쓰이는 상용로그 Math.log10 함수가 생김 표 16-2 함수 16.3.3 기타 함수 절댓값, 부호, 배열의 최솟값/최댓값 등 숫자 관련 기타 함수 16.3.4 의사 난수 생성 자바스크립트에서 의사 난수를 생성할 땐 Math.random()을 사용 0이상 1미만의 숫자를 반환 16.4 삼각함수 사인,코사인,탄젠트,아크 사인,아크 코사인,아크 탄젠트등자바스크립트의 삼각함수는 모두 라인 값을 기준으로 한다. 16.5 쌍곡선함수","link":"/2019/08/05/es6_md/chapter16/"},{"title":"chapter12. 이터레이터와 제너레이터","text":"이터레이터iterator : ‘지금 어디 있는지’ 파악할 수 있도록 도움 ex)배열 values() 메서드를 써서 이터레이터를 만들 수 있다. next() 메서드를 써서 호출할 수 있다. 이터레이터가 끝까지 진행하면 뒤로 돌아가서 다른 데이터를 제공할 수 없다. 이터레이터는 모두 독립적이다. 즉 새 이터레이터를 만들 때마다 처음에서 시작한다. 각각 다른 요소를 가리키는 이터레이터 여러 개를 동시에 사용 가능하다. 이터레이터1234567const book = [ \"1page\",\"2page\",\"3page\",\"4page\"];const it = book.values(); //이터레이터 생성it.next(); //이터레이터 호출 //{value: \"1page\", done: false}it.next(); // {value: \"2page\", done: false} 12.1 이터레이션 프로토콜 이터레이터 프로토콜은 모든 객체를 이터러블iterable 객체로 바꿀 수 있다. 이터레이션 프로토콜은 클래스에 심볼 메서드 Symbol.iterator가 있고,이 메서드가 이터레이터처럼 동작하는 객체, 즉 value와 done 프로퍼티가 있는 객체를 반환하는 next() 메서드를 가진 객체를 반환한다면 그 클래스의 인스턴스는 이터러블 객체란 뜻이다. 이터레이션_프로토콜1234567891011121314151617181920212223242526272829/*메시지에 타임스탬프를 붙이는 로그 클래스 */class Log{ constructor(){ this.messages = []; } add(message){ this.messages.push({message,timestamp:Date.now()}); } [Symbol.iterator](){ return this.messages.values(); }}const log = new Log();log.add(\"first\");log.add(\"second\");log.add(\"third\");for(let entry of log){ console.log(`${entry.message} @ ${entry.timestamp}`);}/*first @ 1563976491610second @ 1563976491610third @ 1563976491610*/ 이터레이터는 무한한 데이터에도 사용할 수 있다. 피보나치수열1234567891011121314151617181920212223242526272829303132//피보나치수열class FibonacciSequence{ [Symbol.iterator](){ let a = 0 , b = 1; return{ next(){ let rval = {value:b, done:false}; b += a; a = rval.value; return rval; } } }}const fib = new FibonacciSequence(); //인스턴스 생성let i = 0;for(let n of fib){ console.log(n); if(++i &gt;9) break; // 무한루프에서 벗어나게 10회 계산한뒤 빠져나옴}/* 1 2 3 5 8 13 21 34 55*/ 12.2 제너레이터 제너레이터 : 이터레이터를 사용해 자신의 실행을 제어하는 함수 제너레이터 만들때 function 키워드 뒤에 애스터리스크(*)를 붙인다. return 이외에 yield 키워드를 쓸 수 있다. 제너레이터의 두 가지 새로운 개념 1) 제너레이터는 함수의 실행을 개별적 단계로 나누어 함수의 실행을 제어한다. 2) 실행 중인 함수와 통신한다. 제너레이터의 두 가지 예외 1) 제너레이터는 언제든 호출자에게 제어권을 넘길 수 있다. 2) 제너레이터는 호출한 즉시 실행되지는 않는다. 대신 이터레이터를 반환하고, 이터레이터의 next() 메서드를 호출함에 따라 실행된다. 제너레이터12345678910111213141516171819202122232425/* 무지개 색깔을 반환하는 제너레이터 생성 */function* rainbow(){//* 기호는 제너레이터 문법 yield 'red'; yield 'orange'; yield 'yellow'; yield 'green'; yield 'blue'; yield 'indigo'; yield 'violet';}const it = rainbow(); //함수호출for(let color of it){ console.log(color);}/*redorangeyellowgreenblueindigoviolet*/ 제너레이터를 호출하면 이터레이터를 얻는다. 함수를 호출한 다음 이터레이터를 써서 단계별로 진행한다. 12.2.1 yield 표현식과 양뱡향 통신 yield 표현식을 통해 양뱡향 통신이 이뤄진다. yield 표현식의 값은 호출자가 제너레이터의 이터레이터에서 next를 호출할 때 제공하는 매개변수이다. 대화_이어나가기123456789101112// yield 표현식과 양뱡향 통신//대화_이어나가기 제너레이터 생성function* interrogate(){ const name = yield 'what is your name?'; //let it = itterrogate(); const color = yield 'what is your favorite color?'; return `${name}'s favorite color is ${color}`;}const it = interrogate();it.next(); //{value: \"what is your name?\", done: false}it.next(\"Ethan\"); //{value: \"what is your favorite color?\", done: false}it.next(\"red\"); //{value: \"Ethan's favorite color is red\", done: true} 제너레이터를 호출하면 호출자가 함수의 실행을 제어할 수 있다. 제너레이터는 화살표 표기법으로 만들 수 없으며 반드시 function*을 써야한다. 12.2.2 제너레이터와 return yield문은 제너레이터의 마지막 문이여서 제너레이터를 끝내지 않는다. 제너레이터에서 return 문을 사용하면, 그 위치와 관계없이 done은 true가 되고, value프로퍼티는 return이 반환하는 값이 된다. 제너레이터와_return1234567891011//제너레이터와 returnfunction* abc(){ yield 'a'; yield 'b'; return 'c';}const it = abc();it.next(); //{value: \"a\", done: false}it.next(); //{value: \"b\", done: false}it.next(); //{value: \"c\", done: true} 제너레이터에서 중요한 값을 return으로 반환하지 말아야한다.제너레이터가 반환한 값을 사용할 때는 yield로 쓰고,return은 제너레이터를 중간에 종료할 떄만 사용","link":"/2019/07/25/es6_md/chapter12/"},{"title":"chapter19. 제이쿼리","text":"제이쿼리는 DOM을 조작하거나, Ajax 요청을 실행할 때 널리 쓰이는 라이브러리이다. 제이쿼리는 3개의 장점 존재한다. 브라우저 호환성을 걱정하지 않아도 된다. 제이쿼리의 Ajax API는 매우 단순하다. 제이쿼리는 내장된 DOM API를 더 유용하고 단순하게 바꾼 메서드를 제공한다. 19.1 맥가이버 나이프, 달러 기호 제이쿼리는 자바스크립트에서 달러 기호를 식별자로 쓸 수 있다는 장점을 활용한 첫 번째 라이브러리 중 하나이다.프로젝트에서 제이쿼리를 사용할 때는 jQuery나 $를 사용한다. 19.2 제이쿼리 불러오기 CDN을 이용하여 불러올 수 있다. 1&lt;script src=\"http://code.jquery.com/jquery-latest.min.js\" /&gt; 19.3 DOM 기다리기 제이쿼리는 브라우저가 페이지를 완전히 읽고 DOM을 구축한 다음에만 호출되는 콜백 안에 코드를 작성한다. 12345678$(document).ready(function() { //여기 있는 코드는 html을 모두 불러오고 DOM이 구성된 다음에 실행된다.});//단축형$(function() { //여기 있는 코드는 html을 모두 불러오고 DOM이 구성된 다음에 실행된다.}); 위 코드는 여러 번 써도 안전하므로, 제이쿼리 코드를 몇 개로 나누어 써도 모두 DOM을 불러온 뒤에 실행된다. 19.4 제이쿼리로 감싼 DOM 요소 제이쿼리로 DOM을 조작 할 때 가장 많이 쓰는 방법은 제이쿼리로 DOM 요소를 감싸는 것제이쿼리 함수($)로 DOM 요소 셋을 감싼 것을 제이쿼리 객체로 부른다.제이쿼리 함수를 호출 할 때는 주로 css 선택자나 html을 사용한다. 이번장에 사용할 HTML 문서12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Simple html&lt;/title&gt; &lt;style&gt; .callout { border: 1px solid #ff0080; margin: 2px 4px; padding: 2px 6px; } .code { background: #ccc; margin: 1px 2px; padding: 1px 4px; font-family: monospace; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;Simple Html&lt;/h1&gt; &lt;/header&gt; &lt;div id=\"content\"&gt; &lt;p&gt;This is a &lt;i&gt;simple&lt;/i&gt; HTML file.&lt;/p&gt; &lt;div class=\"callout\"&gt; &lt;p&gt;this is as fancy as...we'll get!&lt;/p&gt; &lt;/div&gt; &lt;p&gt; IDs (such as &lt;span class=\"code\"&gt;#content&lt;/span&gt;) are unique (there can only be one per page). &lt;/p&gt; &lt;p&gt; Classes (such as &lt;span&gt;.callout&lt;/span&gt;) can be used on many elements &lt;/p&gt; &lt;div id=\"callout2\" class=\"callout fancy\"&gt; &lt;p&gt;A single HTML element can have multiple classes&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345678910$(document).ready(function() { const $paras = $(\"p\"); $paras.length; //5 typeof $paras; //\"object\" $paras instanceof $; //true $paras instanceof jQuery; //true});//html로 제이쿼리 호출const $newParas = $(\"&lt;p&gt;new created&lt;/p&gt;\"); 19.5 요소 조작 제이쿼리에는 text와 html 메서드가 있다.이들 요소는 각각 textContent, innerHTML 프로퍼티에 대응한다. 123// ## 요소 조작$(\"p\").text(\"All paragraphs replaced\");$(\"p\").html(\"&lt;i&gt;All&lt;/i&gt; paragraphs replaced\"); 제이쿼리는 쉽게 여러 요소를 동시에 수정 가능하다.제이쿼리는 기본적으로 제이쿼리 객체에 들어있는 모든 요소에 같은 작업을 하면서 루프 실행을 대신함특정 부분만 바꾸려면 제이쿼리의 eq 메서드를 사용 eq()1234567//특정 문단 조작$(\"p\") //p태그중에 .eq(2) //3번째 문단에 .html(\"&lt;i&gt;All&lt;/i&gt; paragraphs replaced\"); //html 조작//요소제거$(\"p\").remove(); 제이쿼리 메서드는 모두 제이쿼리 객체를 반환한다.따라서 반환된 객체에서 다시 메서드를 호출하는 식으로, 메서드 체인으로 연결 가능하다.체인을 사용하면 아주 간단히 여러 요소를 조작 가능하다. 삽입할 자리에서 호출 append() : 일치하는 요소에 자식을 추가before() 일치하는 요소 앞자리에 형제를 삽입after() : 일치하는 요소 뒷자리에 형제를 삽입 삽입할 요소에서 호출 appendTo() :insertBefore() &gt; insertAfter() : 1234567$(\"p\").append(\"&lt;sup&gt;*&lt;/sup&gt;\");$(\"p\").after(\"&lt;sup&gt;뒤형제&lt;/sup&gt;\");$(\"p\").before(\"&lt;sup&gt;앞형제&lt;/sup&gt;\");$(\"&lt;sup&gt;*&lt;/sup&gt;\").appendTo(\"p\"); //$(\"p\").append(\"&lt;sup&gt;*&lt;/sup&gt;\")과 같음$(\"&lt;hr/&gt;\").insertBefore(\"p\"); //$(\"p\").before(\"&lt;hr/&gt;\");$(\"&lt;hr/&gt;\").insertAfter(\"p\"); //$(\"p\").after(\"&lt;hr/&gt;\"); 제이쿼리에서는 요소의 스타일도 쉽게 변경 가능addClass() : 클래스 추가removeClass() : 클래스 제거toggleClass() : 클래스 토글filter() : 셋 요소 일치 선택자에 맞는 요소만 남도록 선택범위축소not() : filter()의 반대find() : 주어진 선택자에 일치하는 자손만 남김 12345678//홀수 문단만 빨간색으로$(\"p:odd\").css(\"color\", \"red\");//p태그뒤에 hr을 넣고 p태그 안에 각주를 넣고 홀수번째 p태그에 텍스트 빨간색$(\"p\") .after(\"&lt;hr/&gt;\") .append(\"&lt;sup&gt;*&lt;/sup&gt;\") .filter(\":odd\") .css(\"color\", \"red\"); 19.6 제이쿼리 취소 get(): 제이쿼리 객체로 감싼 것을 취소하고 dom 요소에 직접 접근하기 위해서는 get 메서드를 사용해야 한다. 123//## 19.6 제이쿼리 취소const para2 = $(\"p\").get(1); //두번째 &lt;p&gt;const paras = $(\"p\").get(); //모든 &lt;p&gt; 19.7 Ajax 제이쿼리에는 Ajax 호출을 간편하면서도 세밀히 컨트롤 할 수 있는 메서드가 있다. 가장 널리 쓰는 Ajax 호출을 간편하게 바꾼 get과 post 메서드가 있다. 이 메서드는 콜백을 지원하지만, 서버 응답을 처리할때 권장하는 방법인 프라미스를 반환하기도한다.","link":"/2019/08/13/es6_md/chapter19/"},{"title":"chapter2. 자바스크립트 개발 도구","text":"2.1 자바스크립트 개발 도구 1) 깃 (git) : 프로젝트가 커져도 쉽게 관리할 수 있고 다른 개발자와 협력할 수 있게 하는 버전 컨드롤 도구2) 노드(node): 브라우저 밖에서 자바스크립트를 실행 가능하게 하는 도구3) 걸프 (Gulp) : 반복적인 개발 작업을 자동화하는 빌드 도구4) 바벨 (babel) : ES6 -&gt;ES5 로 변환하는 트랜스컴파일러5) ES린트 (ESLint) :자주하는 실수를 피하고 더 나은 프로그래머가 되도록 돕는 린트 프로그램 2.2.1 GIT 설치 깃설치link: https://git-scm.com/downloads 2.2.2 gitbash 설치 \\ : 일반 윈도우에서는 /(역슬래시) 로 디렉터리를 표시하지만 gitbash에서는 (슬래시)로 ~ : 홈 디렉터리 cd : 다른 디렉터리로 이동 pwd : 현재 디렉터리 경로 출력 mkdir test : 현재 디렉터리에서 test 라는 서브 디렉터리를 만든다. cd .. : (..) 은 부모 디렉터리로 한 단계 위 디렉터리로 이동하게 2.2.6 걸프와 그런트 gulp : 반복 작업을 자동화 해주는 도구 1) 터미널에 각각 명령어를 입력해 걸프를 설치한다. bash12npm install -g gulpnpm install --save-dev gulp 2) 설치 후 프로젝트 루트에 gulpfile.js를 만든다. gulpfile.js123456const gulp = require('gulp');//걸프 의존성을 여기 씁니다. gulp.task('default', function() { //걸프 작업을 여기 씁니다.}); 2.3 트랜스컴파일러 - 바벨1) 바벨을 설치해준다. bash1npm install --save-dev gulp-babel @babel/core @babel/preset-env 2) 프리셋 설치 후에 프로젝트 루트에 .babelrc 파일을 만든다. .babelrc123{ \"presets\": [\"es2015\"] } #위와 같이 작성하는 프리셋내용도 아래와 같이 변경이 필요하다.{ \"presets\": [\"@babel/preset-env\"] } 2.3.1 바벨을 걸프와 함께 사용하기1) gulp-babel 패키지를 설치한다. bash1npm install --save-dev gulp-babel 2) gulpfile.js를 수정한다. bash123456789101112131415const gulp = require('gulp');const babel = require('gulp-babel'); gulp.task('default', function() { //노드소스 gulp.src('es6/**/*.js') .pipe(bable()) .pipe(gulp.dest('dist')); //브라우저 소스 gulp.src('public/es6/**/*.js') .pipe(babel()) .pipe(gulp.dest('public/dist')); done();}); 2.4 린트EsLint12npm install -g eslintnpm install --save-dev gulp-eslint","link":"/2019/06/24/es6_md/chapter2/"},{"title":"chapter3. 리터럴과 변수, 상수, 데이터타입","text":".. 제작 중입니다..","link":"/2019/06/25/es6_md/chapter3/"},{"title":"chapter6. 함수","text":"함수 : 하나의 단위로 실행되는 문의 집합 6.1 반환 값 return :함수를 즉시 종료하고 값을 반환return을 명시적으로 호출하지 않으면 반환 값은 undefined가 됨 함수 return12345function getGreeting() { return \"hello world\";}getGreeting(); 6.2 호출과 참조 함수 식별자 뒤에 ()를 쓰면 함수를 호출,괄호를 쓰지 않으면 함수를 참조하며 함수 실행되지 않는다. 호출과 참조1234567function getGreeting() { //함수 바디 중괄호 console.log(\"hello world\");}getGreeting(); // \"hello world\";getGreeting; // function getGreeting() 변수에 할당 123//변수에 할당const f = getGreeting;f(); //hello, world; 객체 프로퍼티에 할당 1234//객체 프로퍼티에 할당const o = {};o.f = getGreeting;o.f(); 배열 요소에 할당 1234//배열 요소에 할당const arr = {1,2,3};arr[1] = getGreeting;arr[1]();","link":"/2019/07/04/es6_md/chapter6/"},{"title":"ES6 Summary 2 - 클로저","text":"ES6 속성 정리 본 정리본은 인프런의모던 자바스크립트(javascript) 개발을 위한 ES6 강좌를 바탕으로 작성되었습니다. let, const const라고 해서 값 변경이 불가능하다는 것은 아니다. 1234567const array = [1, 2, 3, 4, 5];array.push(6); //가능할까?console.log(array);/*[ 1, 2, 3, 4, 5, 6 ]*/ es6 string에 새로운 메서드들 특정 문자열의 포함 여부를 알려주는 메서드들 1234let str = \"hello world ^^\";console.log(str.startsWith(\"hello\")); // trueconsole.log(str.endsWith(\"hello\")); // falseconsole.log(str.includes(\"world\")); // true for in 과 for of for in 12345678910111213141516const data = [1, 2, undefined, NaN, null, \"\"];Array.prototype.getIndex = function() {};for (let idx in data) { console.log(data[idx]);}/**12undefinedNaNnull[Function]**/ for in의 문제점자기가 가지고 있는 객체 이외의 상위의 프로토타입 객체가 나오게 되는 의도치 못한 결과가 발생할 수 있다.그래서 array 문에서는 for in을 안 쓰는 것을 권장 for of 1234567891011121314const data = [1, 2, undefined, NaN, null, \"\"];Array.prototype.getIndex = function() {};for (let value of data) { console.log(value);}/**12undefinedNaNnull**/ for of 를 배열이 아닌 문자 단위로도 순회 가능하다. 123456789101112131415161718const str = \"hello world\";for (let value of str) { console.log(value);}/*helloworld*/ spread operator(…) spread operator, 펼침 연산자 1234let newData = [...pre];console.log(newData); // [ 'apple', 'orange', 100 ]console.log(pre === newData); // false spread operator의 활용 배열 합치기가 쉽다. 1234let pre = [100, 200, \"hello\", undefined];let newData = [0, 1, 2, 3, ...pre, 4];console.log(newData); // [ 0, 1, 2, 3, 100, 200, 'hello', undefined, 4 ] spread operator 파라미터로 사용하기 123456function sum(a, b, c) { return console.log(a + b + c);}let array = [1, 2, 3];sum(...array); // 6 from 메서드","link":"/2020/01/14/es6_md/es6_summary_3/"},{"title":"ES6 Summary 2 - 클로저","text":"클로저 클로저란 외부함수(포함하고 있는)의 변수에 접근할 수 있는 내부 함수를 말한다. 외부함수 내부함수123456789function outer(){ var hello = \"hi\"; function inner(){ //이는 var inner = function(){}하고 같다. console.log(hello); } return inner();}outer(); //hi 여기서 outer()는 외부함수, inner()는 내부함수가 된다.또한 변수 hello는 외부함수 outer()의 지역변수가 된다.내부함수 innner()에서 외부함수 outer()의 hello의 지역변수에 접근할 수 있다. 이를 클로저라고 한다. 내부함수는 외부함수의 변수뿐만이 아니라 파라미터도 접근 가능하다. 내부함수가 외부함수 파라미터에 접근할 때123456789function outer(name){ var hello = \"hi\"; function inner(){ //이는 var inner = function(){}하고 같다. return name +\" \"+ hello; } return inner();}outer(\"somoong\"); //somoong hi; 클로저의 특징 클로저는 외부함수가 리턴된 이후에도 외부함수의 변수에 접근할수 있다. 내부함수는 외부함수의 지역변수에 접근 할 수 있다고 했는데, 특이한 점은 외부함수의 실행이 끝나서 외부함수가 return 된 이후에도 내부함수에서 외부함수 변수에 접근 할 수 있다는 것이다. 내부함수에서 리턴한 외부함수 변수에 접근하기12345678function outer(){ var hello = \"hi\"; return function(){ //익명함수 console.log(hello); }}var inner = outer();inner(); //hi 위 예제를 보면 7행에서 외부함수 outer()를 호출해 변수 inner에 담았다.그리고 outer는 익명함수를 return 한다. 그리고 8행에서 inner()를 호출하면, outer()는 실행이 끝났기 때문에(return) 소멸하고 외부함수의 지역변수 역시 소멸해야 한다. 하지만 8행에서 함수 inner를 실행했을때 “hi” 가 출력되었다는 것은 외부함수 outer의 지역변수 hello가 소멸되지 않았다는 것을 의미한다. 클로저는 외부함수의 지역변수를 사용하는 내부함수가 소멸되기 전까지 외부함수가 소멸되지 않게 한다. 동일한 외부함수 안에서 만들어진 내부함수나 메소드는 외부함수의 지역변수를 공유한다.그리고 이러한 특성을 이용해 Private한 속성을 사용할 수 있게 한다. 내부(private) 변수 예제1234567891011121314151617181920212223242526272829function movie(title){ return{ get_title : function(){ return title; }, set_title : function(newTitle){ title = newTitle; } }}/*get_title 메서드로 movie()의 title 변수를 참조, set_title 메서드에서 title 지역변수를 참조받아 newTitle에 저장 get_title : title 값을 결정set_title : title 값을 변경*/var blood = movie(\"금발이 너무해\");// 이 시점에, 외부함수 movie가 리턴된다.var joker = movie(\"조커\");// 이 시점에, 외부함수 movie가 리턴된다.console.log(blood.get_title()); //금발이 너무해console.log(joker.get_title()); //조커blood.set_title(\"금발이 너무하지 않아\");console.log(blood.get_title()); //금발이 너무하지 않아console.log(joker.get_title()); //조커 1) 클로저는 객체의 메소드에서도 사용할 수 있다. 위 예제에서 외부함수 movie()의 return 값 안에 있는 get_title과 set_title 메소드는 movie()의 파라미터 값으로 전달된 지역변수 title의 값을 참조할 수 있다. (지역변수 공유) 2) 그러나 똑같은 외부함수 movie()를 공유하고 있는 blood와 joker의 get_title 결과와 set_title결과는 서로 다르다. 그 것은 외부함수가 실행 될 때마다 새로운 지역변수를 포함하는 클로저가 생성되므로 blood와 joker는 서로 완전히 독립된다. 3) 그러므로 , 26행에서 blood의 title을 변경했다고 해서 jocker의 title에 영향을 미치지 못한다. 4) movie()의 지역변수 title은 movie()의 리턴 값에서 정의된 메서드인 get_title과 set_title에 의해서만 접근할 수 있다. title이란 변수를 아무나 수정할 수 없고, 외부에서 title을 다르게 사용한다고 해서 이 함수에 영향을 미치지 못하게 된다.private 속성은 객체 외부에서 접근할 수 없는 감춰진 속성을 말한다. javascript는 기본적으로 private한 속성을 지원하지 않지만, 클로저의 특성을 이용해서 private 한 속성을 사용할 수 있게 한다. 클로저를 통해 문제 해결하기1234567891011var arr = [];for(var i = 0; i &lt; 5; i++){ arr[i] = function(){ return i; }}for(var index in arr) { console.log(arr[index]());}//결과 ? 위 예제는 반복문이 0부터 4까지 총 다섯번을 돌면서 i 값을 arr 란 배열에 저장하고, 이를 다시 콘솔에 찍는 예제이다.위 예제의 결과를 0,1,2,3,4가 나온다고 기대할 수 있지만,실제로 값을 찍어보면 5가 다섯 번 나오게 된다. 우선, 클로저는 내부 함수가 외부 함수의 지역변수를 참조 할 수 있는 것이라고 햇는데 , 여기서 var i 는 함수 레벨 스코프 단위로 감싸지는 전역변수가 된다. 즉 지역변수가 되지 못한다. 또한, arr[i]에 저장되는 값은 i값이 아닌function(){ return i; }즉 함수 자체가 된다. arr[0] = function(){return i; //5} arr[1] = function(){return i; //5} …그리고 return 할때는 이미 반복문이 실행되어 i의 값이 5까지 올라간 상태가된다. 따라서 5가 5번 찍히는 것이다. 이 문제를 클로저를 통해 해결할 수 있다. 1234567891011var arr = []for(var i = 0; i &lt; 5; i++){ arr[i] = function(id) { return function(){ return id; } }(i); //즉시실행함수}for(var index in arr) { console.log(arr[index]());} 마찬가지로 arr[i]는 function(id) { //외부함수 return function(){ //내부함수 return id; }}(i); //매개변수로 i를 줌 의 값을 받는다. 여기서 외부함수의 매개변수로 i를 주고 외부함수는 id라고하는 매개변수(지역변수)를 갖게 된다. 그리고 내부함수(클로저)는 외부함수의 지역변수를 참조할 수 있으므로 외부함수 id 값을 참조하게 된다. 그 함수가 만들어지게 되는 시점에 i 값을 id라는 매개변수로 받고 이를 내부함수가 그 값을 참조할 수 있으므로 우리가 원하는 결과를 찍게 된다. 참고 링크 생활코딩 : https://opentutorials.org/course/743/6544 자바스크립트 클로저 쉽게 이해하기 : http://chanlee.github.io/2013/12/10/understand-javascript-closure/","link":"/2019/11/03/es6_md/es6_summary_2/"},{"title":"hexo 시작하기","text":"hexo 란 Hexo는 node.js 기반 정적 사이트 생성기(Static site generator)의 일종이다….사실 잘 모르겠고 간단하고 강력한 블로그 프레임 워크다 라고 하는게 더 이해가 쉬울듯하다.hexo 주소 : https://hexo.io/ hexo 설치 전 필수 사항크게 3가지가 필요하다. node.js 설치 https://nodejs.org/ko/git 설치 https://git-scm.com/github 계정생성 https://github.com node.js 설치node.js는 다운받아서 설치해주면 되는데 안전버전이랑, 최신버전으로 나뉜다.보통 안전버전을 많이 권하긴 한다. 노트를 설치한뒤에 cmd(터미널,명령 프롬프트)에 node -v를 입력하고 버전정보가 나오면 설치가 된 것이다. 12node -v//v10.15.3 git 설치사이트 url로 들어가면 오른쪽에 download 2.23.0 for windows 식으로 뜨는데 다운 받아 설치해주면 된다.git 설치 프로그램의 default 셋팅 그래로 설치한다.git을 설치하면 Git Bash 와 git GUI가 자동으로 같이 설치된다. git bash의 경우 vscode 에디터의 기본 터미널로 설정하면 편하다. 설정방법설정(하단 톱니바퀴) -&gt; 사용자 설정 -&gt; json 추가 사용자 설정1\"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\", //git bash를 기본 터미널로 사용 github 계정생성 및 repository 등록 일단 github에 가입을 한다. 가입 후 https://github.com/username 주소에서 본인 github가 나온다. Repository 탭의 new 버튼을 누르면 새로운 Repository가 생성된다. Repository name , Description(생략가능) , Public 체크, Initialize this repository with a README (생략가능) 을 선택하고 Create repository를 누르면 나만의 저장소가 생긴다. Repository를 생성하고 clone download 버튼을 누르면 주소가 나오는데 이를 복사해둔다. repository를 생성하면 사이트 url을 얻을 수 있는데 , setting 탭의하단의 스크롤을 해 GitHub Pages의 souce 의 select를 none에서 master branch로 바꾸면 url을 알 수 있다. hexo 설치모든 요구사항이 설치되면 npm(node 설치하면 자동으로 사용가능함) 과 함께 hexo 설치가 가능하다. 12npm install hexo-cli -ghexo -v hexo를 설치하고 hexo -v를 통해 hexo 버전이 나오면 설치가 된것이다.나의 경우에는 blog라는 루트폴더를 만들고 cd로 blog 경로로 들어가서 hexo를 설치했다. hexo 설치가 성공 12345678hexo init &lt;폴더명&gt;cd &lt;폴더명&gt;npm installex)hexo init blogcd blognpm install 설치가 성공하면 local 서버를 띄워서 확인해볼 수 있다. 1234567hexo s //로컬서버 구동 명령어INFO Checking dependenciesINFO Validating the configuration fileINFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 이런식으로 로컬서버가 나오면 성공 클릭시 hexo 기본테마인 landscape의 theme가 내 로컬서버에 나타난다. github repository와 연결이제 로컬말고 방금 만든 내 github와 연결하면 되는데, 루트 폴더 아래의_config.yml이라는 파일이 있다. 클릭 후 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: //아까 복사해놓은 내 repository 주소를 넣는다.(.git으로 끝남) branch: master 을 넣으면 내 github와 연결된다. 배포이제 github repository로 내 hexo 블로그를 배포해야한다. 12hexo cleanhexo d -g 가끔 배포가 안돼는 경우에 한번씩 clean 해주고 배포하면 잘 된다.배포 후 몇분 기다리면 github에 내 블로그가 올라간다. 확인아까 봤던 사이트 url로 들어가면 내 블로그가 들어가 있는것을 확인할 수 있다.","link":"/2019/10/20/hexo_md/hexo/"},{"title":"intelliJ 사용법","text":"intelliJ 사용하기 vscode(visual studio code), brackets, atom 등등 프론트 개발을 하기 위한 다양한 에디터들이 있다.intelliJ도 이와같은 에디터들 중에 하나이다.공식 사이트 주소 : https://www.jetbrains.com/ko-kr/idea이 intellij를 보다 효율적으로 사용하기 위한 단축키와 디버깅 방법을 정리해 보았다. 본 요약본은 인프런의 IntelliJ를 시작하시는 분들을 위한 IntelliJ 가이드라는 강의를 듣고 정리한 내용을 바탕으로 합니다. 단축키본 단축키는 window 기준이다. 생성, 실행 디렉터리, 패키지, 클래스 생성 목록보기 : Alt+ Insert 현재 포커스 실행(run) : Ctrl+ Shift+ f10 이전 포커스 실행(run) : Shift+ f10 라인 복제, 삭제, 합치기, 옮기기 라인 복제하기 : 그 라인 아무나 포커스 하고 Ctrl + D 라인 삭제하기 : 그 라인 아무나 포커스 하기 Ctrl + Y 라인 합치기 (문자열 같은 J는 Join의 약자) : Ctrl + Shift+ J 라인 옮기기1) 구문/문법에 관계없이 라인 이동: 위 Ctrl + shift + 방향키(위,아래)2) 구문/문법에 관계해서 이동(컴파일 오류와 관계없이) : 위 Shift + Alt + 방향키(좌,우) Element 옮기기 Ctrl + Shift + Alt + 방향키(좌,우) id와 name의 위치를 바꿈12&lt;h1 id=\"id\" name=\"name\"&gt;title&lt;/h1&gt;// Ctrl + Shift + Alt + 방향키(좌,우) 코드 즉시보기 , DOCS 문서 코드 즉시보기 : Ctrl + P 메서드의 구현 부분 보기 Ctrl + Shift + I: ultimate(유로버전)은 html에 있는 css나 js 코드 내용도 볼 수 있다고 함 각 메서드에 대한 설명 : Ctrl + Q: ultimate는 MDN 문서에 나와있는 Javascript docs 문서도 보여준다. 포커스 이동 단어별로 포커스 이동 : Ctrl + 방향키(좌,우) 단어별로 포커스 이동하면서 드래그 하기 : Ctrl + Shift + 방향키(좌,우) 라인의 맨 앞 / 끝으로 포커스 이동하기 : 맨 앞 이동 : Home / 맨 뒤 이동 : End 라인 전체 드래그 :1) 포커스 기준 앞 전체 선택 : Shift + Home2) 포커스 기준 뒤 전체 선택 : Shift + End 크게크게 포커스 이동하기Page Up / Page Down 검색 파일에서 text 검색 : Ctrl + F 파일에서 Text Replace : Ctrl + R 프로젝트 전체에서 검색 : Ctrl + Shift + F 프로젝트 전체에서 교체 : Ctrl + Shift + R 디렉토리의 구조를 바꿔야 할 때: html에서 import 한 css의 경로명 같은게 일괄 바뀌어야 할 때 리팩토링 코드 이쁘게 prettier : Ctrl + Alt + L 파일,컴포넌트 리팩토링 : Ctrl + F6 폴더/파일이름변경 : Shift + F6 디버깅 현재 포커스가 되어있는 메서드 디버그 하기 : 그 메서드 실행버튼(&gt;)클릭하고debug (메서드이름)누르면 됨 디버그 되어있는(남아있는) 메서드 다시 실행 : shift + F9 Resume / 다음 브레이크 포인트로 이동 : f9 Step Over / 현재 브레이크포인트에서 다음 한줄로 이동 : F8 Step Into / 브레이크가 걸려있는 채로 그 브레이크 걸린 메소드 안으로 들어가기 : F7 Step Out / 현재 메소드 밖으로 이동 : Shift + F8 Evaluate Expression / 브레이크 된 상태에서 코드 사용 (어떠한 특정 조건을 걸어서 값을 확인하고 싶을때 사용): Alt + F8 Watch / 브레이크 된 이후에 코드 변경 확인 현재 커서 위치에 브레이크 포인트 걸기 : ctrl + F8","link":"/2019/12/17/intelliJ/intelliJ/"},{"title":"vscode 에디터 단축키, 사용자 설정하기","text":"vscode 에디터의 기본 단축키 alt 를 누른상태에서 줄을 클릭하면 여러줄이 클릭된다.(여러줄 동시 수정할 때 유용) 커서가 깜빡이는 상태에서 ctrl + c를 누르면 커서가 있는 그 줄 전체 내용이 복사된다. 커서가 깜박이는 상태에서 alt키를 누르고 위아래 방향키를 누르면 그 줄이 위 아래로 이동한다. ctrl + /를 누르면 주석이 된다. vscode 설정 (사용자, 작업영역) 사용자 설정 : 내 vscode editor에 대한 기본 설정이며 주로 폰트, 탭간격, 줄바꿈 여부 등을 설정한다.한 번 설정시 전역으로 설정됩니다. 작업영역 설정 : 프로젝트에 대한 개별 설정 부분이다. 쉽게 말해서 사용자 설정은 vscode editor에 대한 설정값이고,작업영역은 각 개별 프로젝트 폴더 단위로 특정 설정값을 넣어주고 싶을 때 건드는 부분이다. vscode 에디터 하단 톱니바퀴 모양에서 설정을 클릭한다. setting.json 링크를 클릭한다. 왼쪽은 vscode에서 제공하는 설정들이고, 저 내용들 중 필요한 부분을 {} 안에 복붙해서 넣으면 에디터에서 원하는데로 사용자 설정이 가능하다. 현재 내 vscode의 사용자 설정 값은 다음과 같다. 사용자 설정123456789101112131415{ \"workbench.settings.useSplitJSON\": true, \"editor.fontSize\": 14, \"editor.renderWhitespace\": \"all\", \"editor.wordWrap\": \"on\", \"terminal.integrated.shell.windows\": \"C:\\\\Program Files\\\\Git\\\\bin\\\\bash.exe\", \"workbench.iconTheme\": \"material-icon-theme\", \"editor.fontFamily\": \"D2Coding, Consolas, 'Courier New', monospace\", \"editor.renderIndentGuides\": false, //prettier \"editor.formatOnSave\": true, \"tslint.autoFixOnSave\": true, \"eslint.autoFixOnSave\": true, \"liveServer.settings.donotShowInfoMsg\": true} 그런데 가끔 에디터 버전에 따라, 저 왼쪽 vscode에서 제공하는 설정이 안보이는 경우가 있는데,이럴경우 “workbench.settings.useSplitJSON”: true,를 사용자 설정 부분에 넣고 저장하면 보인다. “editor.fontSize”: 14, 에디터의 기본 폰트 사이즈를 14로 하겠다.“editor.renderWhitespace”: “all”, :탭이 몇칸 띄워져 있는지를 보여주는 것.“editor.wordWrap”: “on”, : 자동 줄 바꿈“terminal.integrated.shell.windows”: “C:\\Program Files\\Git\\bin\\bash.exe”,:터미널을 기본 gitbash로 설정하겠다.“workbench.iconTheme”: “material-icon-theme”, : (에디터 확장 플러그인에 material-icon-theme를 설치 한 뒤에 ) 이를 기본 아이콘 테마로 사용하겠다는 의미 “editor.fontFamily”: “D2Coding, Consolas, ‘Courier New’, monospace”, : 폰트 설정 네이버에서 제공하는 D2Coding 폰트를 기본으로 사용함 D2Coding 폰트 다운로드 ▼▼link : https://github.com/naver/d2codingfont //prettier“editor.formatOnSave”: true,“tslint.autoFixOnSave”: true,“eslint.autoFixOnSave”: true, :prettier 관련 설정인데 저장시 자동으로 코드가 정렬되게 함 이런식으로 사용자 설정을 내가 원하는 데로 커스텀 가능하다.","link":"/2019/10/08/scss_md/intro/"},{"title":"SCSS를 vscode 에디터에서 사용하기(플러그인 설치와 작업영역 설정하기)","text":"VSCODE 에디터에서 SCSS를 사용하는 방법을 알아본다. vscode 에디터에서 sass 확장 컴파일러 설치하기 확장(extensions)에서 sass를 검색한다. sass와 Live sass compiler와 sass Lint를 설치해준다.(live server은 Live sass compiler를 설치하면 자동으로 설치된다.) sass : sass 관련된 문법을 vscode에서 지원하도록 해준다. - Live sass compiler : 설치시 에디터 하단에 watching sass가 생기는데 이를 켜두면 a.scss -> a.css 이런식으로 변환이 가능하다. vscode 설정 (사용자, 작업영역) 사용자 설정 : 내 vscode editor에 대한 기본 설정이며 주로 폰트, 탭간격, 줄바꿈 여부 등을 설정한다.한 번 설정시 전역으로 설정됩니다작업영역 설정 : 이 프로젝트에 대한 개별 설정 부분이다. 위 부분이 이해가 안간다면 ? vscode 에디터 단축키, 사용자 설정하기 SASS 작업영역 설정하기sass 관련 작업영역 설정12345678910111213141516171819202122232425{ \"liveSassCompile.settings.formats\":[ // This is Default. { \"format\": \"expanded\", \"extensionName\": \".css\", \"savePath\": \"/css\" }, // You can add more .min.css { \"format\": \"compressed\", \"extensionName\": \".min.css\", \"savePath\": \"/dist/css\" }, ], \"liveSassCompile.settings.excludeList\": [ \"**/node_modules/**\", \".vscode/**\" ], \"liveSassCompile.settings.generateMap\":true, \"liveSassCompile.settings.autoprefix\": [ \"&gt; 1%\", \"last 2 versions\" ]} Live sass compiler에서 제공하는link : https://github.com/ritwickdey/vscode-live-sass-compiler/blob/master/docs/settings.md에서 들어가게되면 Example 부분에 SASS 컴파일러를 환경설정할수 있는 JSON이 보인다. 이걸 vscode 환경설정 작업영역에 복붙한다. Watching sass를 다시 껐다 키면 “savePath”: “/css” 라고 저장을 해놨기 때문에루트 폴더 바로 아래 css 폴더가 생성되고 그 안에 .css 파일이 생성되게된다 이제 sass/test.scss에서 저장했던 sass 파일이 css/test.css에 알아서 변환이 되어 저장된다. 작업할 때마다 Watching SASS를 킨 상태로 vscode의 작업 영역을 분할해서왼쪽은 test.scss 오른쪽은 test.css 이런식으로 비교하면실시간으로 scss -&gt; css 변환과정을 볼 수 있다. Watching..이라고 나오면 제대로 변환되고 있는 것이다.문제가 발생하면 저렇게 오류 구문을 띄워준다.","link":"/2019/10/09/scss_md/sass1/"},{"title":"chapter13. 함수와 추상적 사고","text":"13.1 서브루틴으로서의 함수 서브루틴 : 프로시저, 루틴, 서브프로그램, 매크로 등 다양하게 불린다.복잡한 코드를 간단하게 만드는 기초적인 수단이다.반복되는 작업의 일부를 떼어내서 이름을 붙이고 언제든지 이름을 부르면 실행된다. 1234567891011121314151617//오늘이 윤년인지 아닌지 판단하는 알고리즘const year = new Date().getFullYear();//console.log(year); //2019if(year % 4 !== 0) console.log(`${year} is not a leap year`);if(year % 100 !== 0) console.log(`${year} is not a leap year`);if(year % 400 !== 0) console.log(`${year} is not a leap year`);else console.log(`${year} is a leap year`);//오늘이 윤년인지 아닌지 판단하는 함수function printLeapYearStatus(){ const year = new Date().getFullYear(); //console.log(year); //2019 if(year % 4 !== 0) console.log(`${year} is not a leap year`); if(year % 100 !== 0) console.log(`${year} is not a leap year`); if(year % 400 !== 0) console.log(`${year} is not a leap year`); else console.log(`${year} is a leap year`);} 13.2 값을 반환하는 서브루틴으로서의 함수서브루틴 함수123456789101112function isCurrentYearLeapYear(){ const year = new Date().getFullYear(); if(year % 4 !== 0) return false; if(year % 100 !== 0) return false; if(year % 400 !== 0) return false; else return true;}//값 반환const dayInMonth = [31,isCurrentYearLeapYear() ? 29:28, 30,31,30,31,31,30,31,30,31];if(isCurrentYearLeapYear()) console.log('it is a leap year');console.log(dayInMonth); // [ 31, 28, 30, 31, 30, 31, 31, 30, 31, 30, 31 ] 13.3 함수로서의 함수 순수한 함수 : 입력이 같으면 결과도 반드시 같다.앞의 isCurrentYearLeapYear()는 언제 호출하느냐에 따라 값이 달라지므로 순수함수가 아니다. 순수함수에는 부수효과가 없다. 즉, 함수를 호출한다고 해서 프로그램의 상태가 바뀌면 안됌 순수함수 아닐때1234567// #순수함수 - 순수하지 않은 함수(레인보우)const colors = ['red','orrange','yellow','green','blue','indigo','violet'];let colorIndex = -1;function getNextRaindowColor(){ if(++colorIndex &gt;= colors.length) colorIndex = 0; return colors[colorIndex];} 이 함수는 순수함수의 두가지 정의를 모두 어긴다. 1. 입력이 같아도 결과가 항상 다르고, 2. 변수 colorIndex를 바꾸는 부수효과가 발생한다. (colorIndex는 getNextRaindowColor 함수에 속하지 않는데도 함수를 호출하면 바뀜 = > 부수효과 발생) 순수함수로 레인보우 수정123456789101112// #순수함수 - 순수한함수(레인보우)//이터레이터function getRainbowIterator(){ const colors = ['red','orrange','yellow','green','blue','indigo','violet']; let colorIndex = -1; return{ next(){ if(++colorIndex &gt;= colors.length) colorIndex = 0; return {value : colors[colorIndex], done : false} } }} 이 함수는 순수함수다. 1. 입력이 같으면 결과가 항상같다. 2. 부수효과가 발생하지 않는다. next() 메서드는 매번 다른 값을 반환할테니 순수함수가 아니지 않은가에 대한 해설 next()는 함수가 아니라 메서드이다. 메서드는 자신이 속한 객체라는 컨텍스트 안에서만 동작하므로, 메서드의 동작은 그 객체의 의해 좌우된다. 즉 다른부분에서 getRainbowIterator()를 호출해도 독립적인 이터레이터가 생성된다. 13.4 그래서? 함수의 세가지 측면 : 서브루틴, 값을 반환하는 서브루틴, 순수함수에 대해 서브루틴 : 반복을 없애준다. 순수한 함수 : 코드를 테스트하기 쉽고 이해하고 재사용하기 쉽다.순수함수는 부수효과를 발생시키지 않으므로 버그를 줄여준다. 13.4.1 함수도 객체다 자바스크립트 함수는 Function 객체의 인스턴스이다.typeof v =&gt; v가 함수일 때 “function”을 반환typeof array =&gt; array가 배열이면 “object”를 반환v instanceof object =&gt; true를 반환한다.그러므로 변수가 함수인지 확인하고 싶을 땐 typeof를 써보기 13.5 IIFE와 비동기적 코드 IIFE(즉시 호출하는 함수 표현식), 클로저를 만들 수 있음IIFE는 비동기적 코드가 정확히 동작할 수 있도록 새 변수를 스코프에 만든다. 1234567//5초에서 시작하고 카운트다운이 끝나면 \"GO\"를 표시하는 타이머var i;for(i = 5; i&gt;=0; i--){ setTimeout(function(){ console.log(i===0? \"GO\": i); }, (5-i)*1000);} //-1이 6번 출력 setTimeout에 전달된 함수가 루프 안에서 실행되지 않고 루프가 종료된 뒤에 실행되었다. 루프는 5에서 시작해 -1로 끝난다. -1이 되기 전에 콜백함수가 실행되지 않는다. 콜백함수가 호출되는 시점에서 i의 값은 -1이다. 그러므로 -1이 6번 출력된다. 12345678910111213141516171819202122232425262728293031//5초에서 시작하고 카운트다운이 끝나면 \"GO\"를 표시하는 타이머//위에 함수로 감쌈function loopBody(i){ setTimeout(function(){ console.log(i===0? \"GO\": i); }, (5-i)*1000);}var i;for(i = 5; i&gt;=0; i--){ loopBody(i);} /*54321GO*///IIFE로 고쳐쓰기 /*한번쓰고 버릴 함수는 이름을 붙이는게 성가심*/var i;for(i = 5; i&gt;=0; i--){ (function(i){ setTimeout(function(){ console.log(i===0? \"GO\" :i); }, (5-i)*1000); })(i);} 13.6 변수로서의 함수 함수를 가리키는 변수를 만들어 별명을 정할 수 있다. 배열에 함수를 넣을 수 있다. 물론 다른 타입의 데이터와 섞일 수 있다. 함수를 객체의 프로퍼티로 사용할 수 있다. 함수를 함수에 전달할 수 있다. 함수가 함수를 반환할 수 있다. 함수를 매개변수로 받는 함수를 반환하는 것도 가능하다. 함수에 별명정하기123456789//함수를 가리키는 변수를 만들어 별명을 정할 수 있다.function addThreeSquareAddFiveTakeSqureRoot(x){ return Math.sqrt(Math.pow(x+3,2)+5);}//별명쓰기const f = addThreeSquareAddFiveTakeSqureRoot;const answer = (f(5) + f(2)) / f(7);//7.3484692283495345 별명을 지을 때 addThreeSquareAddFiveTakeSqureRoot에 괄호를 붙이지 않음 괄호를 붙이면 함수를 호출하고, 호출 결과가 저장되게됨 13.6.1 배열 안의 함수 배열 안의 함수를 쓰는것은 유용하다.자주 하는 일을 한 셋으로 묶는 파이프라인이 좋은 예 13.6.2 함수에 함수 전달 비동기적 프로그래밍콜백함수 : 자신을 감싼 함수가 실행을 마쳤을 때 호출함수에 함수를 전달하는 방식 함수전달1234567function sum(arr,f){ //함수가 전달되지 않았으면 매개변수를 그대로 반환하는 null 함수를 씁니다. if(typeof f !='function') f = x=&gt;x; return arr.reduce((a,x) =&gt; a += f(x),0);}sum([1,2,3]);//6sum([1,2,3], x =&gt; x*x);//14 13.6.3 함수를 반환하는 함수함수반환123456789101112131415function sum(arr,f){ //함수가 전달되지 않았으면 매개변수를 그대로 반환하는 null 함수를 씁니다. if(typeof f !='function') f = x=&gt;x; return arr.reduce((a,x) =&gt; a += f(x),0);}sum([1,2,3]);//6sum([1,2,3], x =&gt; x*x);//14function newSummer(f){ return arr =&gt; sum(arr,f);}const sumOfSquares = newSummer(x =&gt; x*x);const sumOfCubs = newSummer(x =&gt; Math.pow(x,3));sumOfSquares([1,2,3]); //14sumOfCubs([1,2,3]); //36 13.7 재귀 재귀함수 : 자기 자신을 호출하는 함수같은 일을 반복하면서 그 대상이 점차 줄어드는 상황에서 재귀를 유용하게 쓸 수 있다. 재귀 함수에는 종료 조건이 있어야한다. 1234567891011121314151617181920212223//건초더비에서 바늘을 찾아야하는 예제function findNeedle(haystack){ if(haystack.length===0) return \"no haystack here\"; if(haystack.shift() === 'needle') return \"found it\" return findNeedle(haystack)//건초더미의 건초가 하나 줄었다.}findNeedle(['hay','hay','hay','hay','needle','hay','hay',]);/*\"no haystack here\"\"no haystack here\"\"no haystack here\"\"no haystack here\"\"found it\"\"no haystack here\"\"no haystack here\"*///숫자의 계승을 찾는 예제function fact(n){ if(n === 1) return 1; return n * fact(n-1);}","link":"/2019/07/31/es6_md/chapter13/"},{"title":"chapter15. 날짜와 시간","text":"자바스크립트의 Date 객체는 원래 넷스케이프 프로그래머 켄 스미스가 만들었다.사실 자바의 java.util.Date를 가져온 것 15.1 날짜, 타임존, 타임스탬프, 유닉스 시간0초(UTC: 1970년 1월 1일 0시 0분 0초)타임존(UTC, 때때로 그리니치 표준시 GMT)라고도 불린다.타임존이란?타임존은 동일한 로컬 시간을 따르는 지역을 의미하며, 주로 해당 국가에 의해 법적으로 지정된다. 보통 국가별로 각자의 고유한 타임존을 사용하고 있으며, 미국이나 캐나다처럼 면적이 넓은 나라인 경우 지역별로 각기 다른 타임존을 사용하기도 한다. GMT한국의 타임존은 보통 GMT+09:00 으로 표현된다. 여기서 GMT는 Greenwich Mean Time의 약자로서 경도 0도에 위치한 영국 그리니치 천문대를 기준으로 하는 태양 시간을 의미한다. GMT 시간은 1925년 2월 5일부터 사용하기 시작하였으며, 1972년 1월 1일까지 세계 표준시로 사용되었다.UTCUTC는 지구 자전주기의 흐름이 늦어지고 있는 문제를 해결하기 위해 1972년에 세슘 원자의 진동수에 기반한 국제 원자시를 기준으로 다시 지정된 시간대이다. 즉, UTC는 좀더 정확한 시간측정을 위해서 GMT를 대체하기 위해 제정된 새로운 표준이며,시간적으로는 둘 사이에 아주 미세한 차이밖에 없지만, 소프트웨어에서 사용할 때는 UTC라고 하는 것이 더 정확한 표현일 것이다자바스크립트는 보통 이 숫자를 사람이 읽기 편한 그레고리력 날짜로 변환한다.자바스크립트의 Date 인스턴스는 모두 유닉스 시간 원점으로부터 몇 밀리초가 지났는지를 나타내는 숫자이다.숫자형 표현이 필요하면 valueOf() 메서드를 사용한다. 1234// ## 15.1 날짜, 타임존, 타임스탬프, 유닉스 시간const d = new Date();console.log(d); //2019-08-04T12:36:34.573Zconsole.log(d.valueOf()); //1564922215240 15.2 Date 객체 만들기 Date 객체는 네 가지 방법으로 만들 수 있다.매개변수 없이 호출하면 현재 날짜에 해당하는 Date 객체를 반환문자열을 제공하면 그 문자열을 해석해서 그에 맞는 날짜를 반환숫자를 넣으면 유닉스 타임스탬프로 해석 12345678910111213//자바스크립트 월은 0으로 시작, 0은 1월이고, 1은 2월new Date(2015,0); //Thu Jan 01 2015 00:00:00 GMT+0900 (한국 표준시)new Date(2015,1); //Sun Feb 01 2015 00:00:00 GMT+0900 (한국 표준시)new Date(2015,1,14); //2015년 2월 14일 0시new Date(2015,1,14,13); ////2015년 2월 14일 1시new Date(2015,1,14,13,30,5); //Sat Feb 14 2015 13:30:05 GMT+0900 (한국 표준시)//유닉스 타임스탬프로 날짜 생성new Date(0); //Thu Jan 01 1970 09:00:00 GMT+0900 (한국 표준시)new Date(1000);//날짜 문자열 해석new Date('June 14,2013'); //Fri Jun 14 2013 00:00:00 GMT+0900 (한국 표준시) 리스본이나 그리니치 등 UTC 지역에 살지 않는 한, 예제에서 UTC로 표기한 시각은 독자의 콘솔에 표시되는 내용과 다르다. 즉 타임존을 명시할 방법이 없다. Date 객체는 항상 UTC 기준으로 저장하고, 출력 시 운영제체에 에서 정의한 표준시에 맞게 변환 15.3 Moment.js Moment.js는 타임존을 지원하는 버전과 지원하지 않는 버전 2가지가 있다. Moment.js 호출1234567//웹 기반 프로젝트시 &lt;script src=\"http:////cdnjs.cloudflare.com/ajax/libs/moment-timezone/0.4.0/moment-timezone.min.js\"&gt;&lt;/script&gt;//노드에서 사용하기npm install moment --save moment-timezone//불러오기const moment = require('moment-timezone'); 15.5 날짜 데이터 만들기 Date 객체를 써서 날짜를 만들어도 되긴 하지만, 타임존을 명시하지 않고 날짜를 생성할 때는 어느 타임존이 사용되는지 생각해야하고, 어느 지역에서 날짜를 생성하느냐에 따라 달라지게 된다.예) 버지니아 앨링턴의 서버에서 날짜 관련 코드를 만들면, 캘리포니아 로스앤잴레스의 사용자 브라우저에서는 3시간의 차이가 발생 15.5.1 서버에서 날짜 생성하기 서버에서 날짜를 생성할 땐 UTC를 사용하거나 타임존을 명시하는 편이 좋다.UTC 날짜를 사용할 수 있는 환경이라면 Date 객체의 UTC 메서드를 사용하라 1234const d = new Date(Date.UTC(2016,4,27)); console.log(d);/*Fri May 27 2016 09:00:00 GMT+0900 (한국 표준시)*/ Date.UTC는 Date의 매개변수를 똑같이 받지만, 새 Date 인스턴스를 반환하지 않고 해당 날짜의 숫자형 값을 반환한다. 이 숫자를 Date 생성자에 넘기면 날짜 인스턴스를 얻을 수 있다. 특정 타임존에 있는 서버에서 날짜를 생성할 땐 moment.tz를 써서 Date 인스턴스를 만들면 타임존을 손으로 변환할 필요가 없다. moment.tz1234//특정 타임존에 있는 서버에서 날짜를 생성const moment = require('moment-timezone');const d = moment.tz([2016,3,27,9,19],'America/Los_Angeles').toDate();console.log(d); //2016-04-27T16:19:00.000Z 15.6 날짜 데이터 전송하기 일반적으로 Date 객체를 그냥 전송해도 안전하지만,자바스크립트에서 날짜를 전송하는 가장 확실한 방법은 JSON을 사용하는 것날짜는 JSON에서 1:1 대칭이 되게끔 파싱할 수 없으므로, JSON 명세에는 날짜에 대한 데이터 타입을 정의하지 않는다. 1234567// ## 15.6 날짜 데이터 전송하기const before = { d: new Date() };before.d instanceof Date //trueconst json = JSON.stringify(before);const after = JSON.parse(json);after.d instanceof Date; //falsetypeof after.d; // \"string\" 즉, JSON으로 바로 날짜를 다룰 수는 없지만, 전송된 문자열에서 날짜를 ‘복구’하는 것은 가능하다. 123//전송된 문자열에서 날짜 복구하기after.d = new Date(after.d);after.d instanceof Date; //true 원래 날짜가 어느 타임존에 있던, 일단 JSON으로 인코드된 날짜는 UTC이다. 그리고 JSON으로 인코드된 문자열을 Date 생성자에 넘겨서 얻은 날짜는 사용자의 타임존을 기준으로 표시된다. 문자를 인코드하지 않고 valueOf() 메서드로 얻은 숫자를 그냥 전송해도 된다. 1234567const before = { d: new Date() };typeof before.d //\"object\"const json = JSON.stringify(before);const after = JSON.parse(json);typeof after.d //\"string\"const d = new Date(after.d);// console.log(d); /Sun Aug 04 2019 22:54:52 GMT+0900 15.7 날짜 형식 Moment.js의 format 메서드를 서서 날짜를 원하는 형식으로 만들 수 있다.예를 들어 문자열 YYYY는 네 자리 연도로 바뀐다. 1234567891011const moment = require('moment-timezone');const d = new Date(Date.UTC(1093,4,10));//다음 기준은 로스앤잴리스에 사는 사람 기준d.toLocaleDateString(); //\"1093. 5. 10.\"d.toLocalFormat();//d.toLocaleTimeString();d.toTimeString();d.toUTCString();moment(d).format(\"YYYY-MM-DD\");//console.log(d); //1093-05-10 15.8 날짜의 구성 요소 Date 인스턴스의 각 구성 요소에 접근할 땐 다음 메서드를 사용한다. 1234567891011121314151617const d = new Date(Date.UTC(1815,9,10));//지금 시각 2019 - 08 - 04 오후 11시 11분 기준//다음 결과는 로스앤젤리스 기준d.getFullYear();//1815d.getMonth(); // 9d.getDate(); //10d.getDay(); //2 - (화요일)d.getHours(); //8 d.getMinutes(); //27d.getSeconds(); //52d.getMilliseconds(); //0//UTC 기준 메서드d.getUTCFullYear(); //1815d.getUTCMonth(); //9d.getUTCDate(); //10//etc... 15.9 날짜 비교 날짜 A와 날짜 B중 어느 쪽이 더 앞인가 하는 단순 날짜 비교 때는 자바스크립트에 내장된 비교 연산자를 통해 할 수 있다.Date 인스턴스는 날짜를 숫자로 지정하므로, 숫자에 쓸 수 있는 비교 연산자를 그대로 사용하면 된다. 12345const d1 = new Date(1996,2,1);const d2 = new Date(2009,4,27);d1 &gt; d2//false;d1 &lt; d2//true; 15.10 날짜 연산 날짜는 숫자이므로 날짜에서 날짜를 빼면 몇 밀리초가 지났는지 알 수 있다. 12345const d1 = new Date(1996,2,1);const d2 = new Date(2009,4,27);const msDiff = d2- d1 //417744000000const daysDiff = msDiff/1000/60/60/24; //4835 Array.prototype.sort를 써서 날짜를 정렬 할 수도 있다. 12345678910111213const dates = [];const min = new Date(2017,0,1).valueOf();const delta = new Date(2020,0,1).valueOf() - min;for(let i =0; i &lt;10 ; i++) dates.push(new Date(min + delta*Math.random()));//dates 배열은 랜덤으로 만들었으므로 뒤죽박죽일것//날짜순으로 정렬하기dates.sort((a,b) =&gt; a-b);/*dates(10) [Thu Jan 12 2017 07:13:33 GMT+0900 (한국 표준시), Sat Jan 14 2017 15:30:06 GMT+0900 (한국 표준시), Tue Jan 31 2017 07:46:50 GMT+0900 (한국 표준시), Sun Apr 23 2017 02:13:01 GMT+0900 (한국 표준시), Mon Sep 18 2017 06:02:23 GMT+0900 (한국 표준시), Thu Dec 07 2017 16:38:18 GMT+0900 (한국 표준시), Sun Dec 17 2017 19:38:32 GMT+0900 (한국 표준시), Mon Apr 02 2018 11:27:48 GMT+0900 (한국 표준시), Mon Jun 03 2019 09:55:56 GMT+0900 (한국 표준시), Fri Dec 27 2019 00:38:29 GMT+0900 (한국 표준시)]*/ 15.11 사용자가 알기 쉬운 상대적 날짜 Moment.js에서 제공하는 목록 날짜를 더하거나 빼는 메서드 메서드를 체인으로 연결하기 ‘3일전’과 같이 상대적으로 날짜 표현하기 123456789101112131415161718//Moment.js에서 제공하는 목록입니다.let m = moment(); //현재m.add(3,\"days\");//m은 이제 3일 뒤m.subtract(2,\"years\"); //m은 이제 2년 전으로부터 3일이 지난 날짜m = moment();//리셋m.startOf(\"year\"); // m은 이제 올해 1월 1일m.endOf(\"month\");//m은 이제 올해 1월 31일//메서드를 체인으로 연결let m = moment().add(10,\"hours\").subtract(3,\"days\").endOf(\"month\");//m은 이제 3일전으로부터 10시간 뒤인 달의 마지막 순간//상대적 날짜m.subtract(10,\"seconds\").fromNow(); //","link":"/2019/08/04/es6_md/chapter15/"},{"title":"chapter17. 정규표현식","text":"17.1 부분 문자열 검색과 대체 정규표현식(정규식)으로 하는 일은 문자열 속에서 부분 문자열을 찾는 일이며찾은 부분을 교체할 때도 있다.다만 그 전에, 정규식을 쓰지 않고 검색하고 교체하는 방법인String.prototype 메서드 검색을 살펴본다,큰 문자열 안에 원하는 부분 문자열이 존재하는지 여부를 찾을 때 사용 String.prototype12345678910const input = \"AS I was going to Saint Ives\";input.startsWith(\"AS\"); //trueinput.endsWith(\"Ives\"); //trueinput.startsWith(\"going\", 9); //true - index 9에서 시작하느냐input.endsWith(\"going\", 14); //true - 끝에서 부터 14번째에input.includes(\"going\"); //true;input.includes(\"going\", 10); //false - index 10에서 시작하면 going 이 없다.input.indexOf(\"going\"); // 9 ;input.indexOf(\"going\", 10); // -1;input.indexOf(\"nope\"); // -1; 이들 메서드는 모두 대소문자를 구분한다. 따라서 input.startsWith(\"as\")는 false 이다. 대소문자를 구분하지 않고 비교하려면 소문자고 바꿔서 비교하면 된다. String.prototype12const input = \"AS I was going to Saint Ives\";input.toLowerCase().startsWith(\"as\"); //true String.prototype.toLowerCase는 원래 문자열은 그대로 두고 새 문자열을 반환한다.자바스크립트 문자열은 항상 불변이다.부분 문자열을 찾아 교체하려면 String.prototype.replace 사용 String.prototype.replace1234567891011//String.prototype.replaceconst input = \"AS I was going to Saint Ives\";const output = input.replace(\"going\", \"walking\");/*//원래 문자열은 바뀌지 않는다.console.log(input);\"AS I was going to Saint Ives\"console.log(output);\"AS I was walking to Saint Ives\"*/ 17.2 정규식 만들기 자바스크립트 정규식은 RegExp 클래스이다. RegExp 생성자로도 정규식을 만들 수 있지만, 간편한 리터럴 문법도 있다.정규식 리터럴은 슬래시(/)로 감싼 형태이다. 정규식 만들기12const rel1 = /going/; //단어 going을 찾을 수 있는 정규식const rel2 = new RegExp(\"going\"); //생성자를 사용했지만 결과는 같다. 17.3 정규식 검색 정규식이 만들어지면 다양한 옵션으로 문자열을 검색 할 수 있다.예) /\\w{3,}/ig =&gt; 세 글자 이상인 단어에 모두 일치하고, 대소문자를 가리지 않음 정규식 검색1234567891011121314151617181920const input = \"AS I was going to Saint Ives\";const re = /\\w{3,}/gi;//문자열(input)의 메서드를 사용할 때input.match(re); //(4) [\"was\", \"going\", \"Saint\", \"Ives\"]input.search(re); //5 세글자 이상으로 된 단어의 첫번쨰 인덱스는 5이다.//정규식(re)의 메서드를 사용할 때re.exec(input); //[\"was\", index: 5, input: \"AS I was going to Saint Ives\", groups: undefined]re.exec(input); //goingre.exec(input); //Saintre.exec(input); //Ivesre.exec(input); //null - 일치하는 것이 더이상 없다.re.test(input); //true - input에는 세 글자 이상으로 된 단어가 한 개 이상 있다.//정규식 리터럴을 사용시input.match(/\\w{3,}/gi);input.search(/\\w{3,}/gi);/\\w{3,}/gi.exec(input);/\\w{3,}/gi.test(input); 17.4 정규식을 사용한 문자열 교체 String.prototype.replace 메서드에도 정규식을 쓸 수 있다. 123456//네 글자 이상으로 된 단어를 모두 교체const input = \"AS I was going to Saint Ives\";const output = input.replace(/\\w{4,}/gi, \"****\");/*\"AS I was **** to **** ****\"*/ 17.5 입력 소비 정규식이 입력 문자열을 소비하는 패턴이라고 생각하는 것정규식이 문자열을 소비할 떄 사용하는 알고리즘 문자열 왼쪽에서 오른쪽으로 진행 일단 소비한 글자에 다시 돌아오지 않는다 한 번에 한 글자씩 움직이며 일치하는 것이 있는지 확인한다. 일치하는 것을 찾으면 해당하는 글자를 한꺼번에 소비 후 다음 글자로 진행 17.6 대체1234567//html 페이지를 문자열에 담고, 이 문자열에서 &lt;a&gt;,&lt;area&gt;,&lt;link&gt;,&lt;script&gt;등등을 찾고 싶을 때, 대소문자 상관없이 찾고싶을 때const html = 'HTML With &lt;a href=\"one\"&gt;one link&lt;/a&gt; and some JavaScript' + '&lt;script src=\"stuff.js\"&gt;';const matches = html.match(/area|a|link|script|source/gi); //첫 시도//(8) [\"a\", \"link\", \"a\", \"a\", \"a\", \"a\", \"Script\", \"script\"] 파이프(|)는 대체를 뜻하는 메타 문자이다.ig는 대소문자를 가리지 않고 전체를 검색하라는 의미이다.문자열이 겹치는 것이 있을 때는 더 큰것을 먼저 써야한다. 17.7 HTML 찾기 정규식으로는 HTML을 분석할 수 없습니다.p 태그 안에 a 태그가 존재하는 등의 계층적 구조에 취약합니다. 17.8 문자셋 문자셋은 글자 하나를 다른 것으로 대체하는 방법을 줄인 것 문자셋123456789101112131415const beer99 = \"99 bottles of beer on the wall\" + \"take 1 down and pass it around-- \" + \"98 bottles of bear on the wall\";const matches = beer99.match(/|0|1|2|3|4|5|6|7|8|9/g);// 문자셋은 이러한 문자들이 들어갈 수 있다는 것을 간략하게 표시할 수 있다.const m1 = beer99.match(/[0123456789]/g);const m2 = beer99.match(/[0-9]/g);//범위 결합도 가능합니다.const match = beer99.match(/[\\-0-9a-z.]/gi);//특정 문자 범위를 제외하고도 찾을 수 있다. 문자열 제외시 캐럿(^)을 맨 앞에 붙임const match = beer99.match(/^[\\-0-9a-z.]/gi); 17.9 자주 쓰는 문자셋 매우 자주 쓰이는 일부 문자셋은 단축 표기가 있다.이를 클래스라고 부르기도 한다. 공백문자셋 \\s을 써서 줄을 맞출 때가 많습니다. 공백12345678const stuff = \"hight: 9\\n\" + \"medium : 5\\n\" + \"low : 2\\n\";const levels = stuff.match(/:\\s*[0-9]/g);//전화번호 양식 맞추기const messyPhone = `(505) 555 - 1515`;const neatPhone = messyPhone.replace(/\\D/g, \"\");//neatPhone//\"5055551515\" 17.10 반복 반복 메타문자는 얼마나 많이 일치해야하는지 지정할 떄 사용문자셋 다음의 +는 그 앞에 있는 요소가 하나 이상 있어야한다는 뜻반복 메타 문자는 그 자체로는 별 의미가 없다. 반복123456//숫자 여러개를 찾는 예제//기존verconst match = beer99.match(/[0-9][0-9][0-9][0-9][0-9][0-9]/);//반복 메타 문자로 수정const match = beer99.match(/[0-9]+/); 17.11 마침표와 이스케이프 정규식에서 마침표(.)는 줄바꿈 문자를 제외한 모든 문자에 일치하는 특수문자입니다.이 메타문자는 입력이 어떤 문자이든 상관하지 않고 소비하려고 할때 사용 1234567891011//문자열에서 우편번호만 필요하고 다른것은 필요 없을 때const input = \"Address : 333 Main St., Anywhere, NY, 55532. Phone : 555 -555-2525.\";const match = input.match(/\\d{5}.*/);/*[\"55532. Phone : 555 -555-2525.\", index: 38, input: \"Address : 333 Main St., Anywhere, NY, 55532. Phone : 555 -555-2525.\", groups: undefined]*///마침표 자체가 필요할 때const equation = \"(2 + 3.5 ) * 7\";const match = equation.match(/\\(\\d \\+ \\d\\.\\d\\) \\* \\d/); 17.11.1 진정한 와일드 카드 마침표가 줄바꿈을 제외한 모든 문자에 일치하면, 줄바꿈 문자를 포함해서 모든 문자에 일치하는 것은 바로 [\\s\\S]이다. 17.12 그룹 그룹을 사용하면 하위 표현식을 만들고 단위 하나로 취급할 수 있다.그 그룹에 일치하는 결과를 나중에 사용하도록 캡쳐할 수도 있다.그룹은 괄호로 만든다. 캡쳐하지 않은 그룹은 (? :[subexpression]) 형태이고, 여기서 [subexpression]이 일치시키려는 패턴이다. 17.13 소극적 일치, 적극적 일치 정규식은 기본적으로 적극적이다. 검색을 멈추기 전에 일치하려는 것을 최대한 많이 찾으려고 한다. 적극적 일치12345678910111213141516171819//&lt;i&gt;태그를 &lt;strong&gt; 태그로 바꿀때//적극적 일치const input = \"Regex pros konw the difference between\\n\" + \"&lt;i&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/i&gt; matching.\";var a = input.replace(/&lt;i&gt;(.*)&lt;\\/i&gt;/gi, \"&lt;strong&gt;$1&lt;/strong&gt;\");/*a를 콘솔에 입력\"Regex pros konw the difference between&lt;strong&gt;greedy&lt;/i&gt; and &lt;i&gt;lazy&lt;/strong&gt; matching.\"*///소극적 일치var b = input.replace(/&lt;i&gt;(.*?)&lt;\\/i&gt;/gi, \"&lt;strong&gt;$1&lt;/strong&gt;\");/*\"Regex pros konw the difference between&lt;strong&gt;greedy&lt;/strong&gt; and &lt;strong&gt;lazy&lt;/strong&gt; matching.\"*/ 정규식은 일치할 가능성이 있는 동안 문자를 소비하지 않고 계속 넘어간다 정규식은 를 만나면 를 더 찾을 수 없을 때까지 소비하지 않고 계속 진행한다. 원래 문자열에는 가 두개 있으므로, 정규식은 첫번째 것을 무시하고 그대로 진행 반복 메타 문자 *를 소극적으로 바꾸려면 뒤에 ?를 붙이면된다 17.14 역참조 그룹을 사용하면 역참조라는 테그닉을 사용 가능서브 그룹을 포함해 , 정규식의 각 그룹은 숫자를 할당 받음숫자는 맨 왼쪽이 1번에서 시작해서 오른쪽으로 갈수록 1씩 늘어남역슬래시 뒤에 숫자를 써서 이 그룹을 참조 할 수 있다.즉, \\1은 맨 처음 일치한 그룹이 된다.따욤표의 짝을 맞출 때 등 사용 17.15 그룹 교체 그룹을 사용하면 문자열 교체도 더 다양한 방법으로 사용가능 17.16 함수를 이용한 교체 함수를 사용하면 복잡한 정규식을 단순화 할 수 있다. 17.17 위치 지정 ‘–으로 시작하는 문자열’, ‘–로 끝나는 문자열’ 등을 정규식의 앵커라고 부른다. ^는 문자열의 처음 $는 문자열의 마지막 123456789// ## 17.17 위치 지정const input = \"it was the best of times, it was the worst of times\";const beginning = input.match(/^\\w+/g); //[\"it\"]const end = input.match(/\\w+$/g); //[\"times\"]//문자열의 줄바꿈이 들어 갔을 때 각 줄의 처음과 끝을 찾으면 m 플래그 사용const input = \"one line\\ntwo line\\nthree line\\nfour\";const beginning = input.match(/^\\w+/gm); //[\"one\", \"two\", \"three\", \"four\"]const end = input.match(/\\w+$/gm); // [\"line\", \"line\", \"line\", \"four\"] 17.18 단어 경계 일치 단어 경계 메타 문자인 \\b 와 \\B는 앵커와 마찬가지로 입력을 소비하지 않는다.단어 경계는 알파벳 또는 숫자(\\w)로 시작하는 부분, 알파벳이나 숫자가 아닌 문자(\\W)로 시작하는 부분, 또는 문자열의 시작과 끝에 일치한다. 17.19 룩어헤드 룩어헤드는 입력을 소비하지 않는다.룩어헤드를 쓰면 정규식 하나로 비밀번호의 유효성을 검사가능하다. 룩어헤드123456789/* * 비밀번호가 규칙에 맞도록 검사해서 * 비밀번호에 대문자와 소문자, 숫자가 최소 하나씩 포함되어야하고, * 글자도 아니고 숫자도 아닌 문자는 들어갈 수 없다. *///룩어헤드로 비밀번호 유효성 체크하기function vaildPassword(p) { return /(?=.*[A-Z])(?=.*[0-9])(?=.*[a-z])(?!.*[^a-zA-Z0-9])/.test(p);}","link":"/2019/08/07/es6_md/chapter17/"},{"title":"chapter21. 객체 프로퍼티 설정과 프락시","text":"객체 프로퍼티에는 데이터 프로퍼티와 접근자 프로퍼티 두 가지가 있다.접근자 프로퍼티는 메서드와 비슷한데, 1. getter와 setter 두 가지 함수로 구성된 점과 2.접근했을때 함수라기보단 데이터 프로퍼티와 비슷하게 동작한다는 점에서 조금 다르다. 이런 점에서 접근자 프로퍼티를 동적 프로퍼티라고 부르기도 한다. 이메일 주소 체크12345678910111213141516171819202122// setEmail과 getEmail메서드가 있다.//@가 들어있는 문자열은 모두 유효한 이메일 주소라고 간주const USER_EMAIL = Symbol();class User { setEmail(value) { if (!/@/.test(value)) throw new Error(`invalid email ${value}`); this[USER_EMAIL] = value; } getEmail() { return this[USER_EMAIL]; }}//이 클래스는 다음과 같은 방식으로 사용해야함const u = new User();u.setEmail(\"join@dot.com\");console.log(`${u.getEmail()}`);//그러나 우리는 이 방식을 더 자연스럽게 느낌const u = new User();u.email = \"join@dot.com\";console.log(`${u.getEmail()}`); USER_EMAIL 프로퍼티 대신 두 가지 메서드(setEmail,getEmail)을 쓴 이유는 잘못된 이메일 주소가 저장되는 것을 방지하려고함. 프로퍼티에는 심볼을 서 실수로 직접 접근하는 것을 방지 접근차 프로퍼티를 사용하면 후자의 자연스러운 문법을 사용하면서도, 부주의한 접근을 차단하는 전자의 장점을 누릴수 있다. 접근자 프로퍼티를 사용하여 이메일 체크1234567891011//접근자 프로퍼티를 사용하여 이메일 체크const USER_EMAIL = Symbol();class User { set email(value) { if (!/@/.test(value)) throw new Error(`invalid email ${value}`); this[USER_EMAIL] = value; } get email(value){ return this[USER_EMAIL]; }} 함수 두 개(set,get)을 사용했지만 두 함수는 email 프로퍼티 하나에 묶였다. 프로퍼티를 할당할때는 setter 가 호출되고, 할당하는 값이 첫 번째 매개변수로 전달된다. 프로퍼티를 평가할 때는 getter가 호출된다. setter없이 getter만 만들수도 있다. 123456789class Rectangle { constructor(width, height) { this.width = width; this.height = height; } get perimeter() { return this.width * 2 + this.height * 2; }} 21.2 객체 프로퍼티 속성 프로퍼티에는 항상 키가 있고, 키는 문자열이나 심볼일 수 있다.프로퍼티의 값은 어떤 타입이든 괜찮다.배열이나 맵과 달리 객체의 프로퍼티에는 순서가 없다.객체 프로퍼티에 접근 할 떄는 점(.)연산자나 대괄호 연산자([])를 사용한다.객체 프로퍼티는 식별자를 키로 사용하는 일반적인 프로퍼티, 심볼이나 표현식을 사용하는 계산된 프로퍼티, 메서드 단축 표기의 세 가지가 있다.프로퍼티에는 자신이 속한 객체 안에서 어떻게 동작할지 결정하는 속성이 있다.우리가 아는 방식으로 프로퍼티를 만들고, Object.getOwnPropertyDescriptor을 서서 속성을 알아보자. 123const obj = { foo: \"bar\" };Object.getOwnPropertyDescriptor(obj, \"foo\");//{value: \"bar\", writable: true, enumerable: true, configurable: true} 프로퍼티 속성 3가지가 모두 나타남 쓰기 가능한지(writable)프로퍼티 값을 바꿀 수 있는지 아닌지 판단 나열 가능한지(enumerable)for…in문이나 Object.keys, 확산 연산자에서 객체 프로퍼티를 나열할 때 해당 프로퍼티가 포함될지 아닐지 판단 설정 가능한지(configurable)프로퍼티를 객체에서 삭제하거나 속성을 수정할 수 있는지 Object.defineProperty로는 프로퍼티 속성을 컨트롤하거나, 새 프로퍼티를 만들 수 있다. 12345678//읽기 전용 프로퍼티에 값을 할당하려고할 때 에러가 발생하는것은 스트릭트 모드에서 뿐이다.\"use strict\";Object.defineProperty(obj, \"foo\", { writable: false });//foo에 값을 할당하려고 하면 오류가 난다.obj.foo = 3;//VM121:7 Uncaught TypeError: Cannot assign to read only property 'foo' of object '#&lt;Object&gt;' Object.defineProperty를 써서 객체에 새 프로퍼티를 추가 할 수도 있다.일반적인 데이터 프로퍼티와 달리, 객체가 일단 생성된 뒤에는 접근자 프로퍼티를 추가할 다른 방법이 없다. 1234567891011121314//obj에 color프로퍼티를 추가해보기Object.defineProperty(obj, \"color\", { get: function() { return this._color; }, set: function(value) { this._color = value; }});obj.color = \"red\";console.log(obj);//{foo: \"bar\", _color: \"red\"} Object.defineProperty로 데이터 프로퍼티를 추가 할 때는 value프로퍼티를 사용한다. 123456789101112//obj에 name 과 greet 프로퍼티를 추가해보기Object.defineProperty(obj, \"name\", { value: \"cynthia\"});Object.defineProperty(obj, \"greet\", { value: function() { return `hello my name is ${obj.name}`; }});console.log(obj.name); //cynthiaconsole.log(obj.greet()); //hello my name is cynthia Object.defineProperty는 배열 프로퍼티를 나열할 수 없게 만들때 주로 사용한다.배열은 원래 프로퍼티를 사용하지 않도록 설계되었으므로 문자열이나 심볼 프로퍼티는 사용하지 않는 편이 좋다.배열에서 for…in이나 Object.keys를 사용하는 것 역시 권장하지 않는다.따라서 배열에 숫자형 프로퍼티가 아닌 다른 프로퍼티를 추가한다면 , 그 배열에서 for…in이나 Object.keys를 사용했을때 노출되지 않도록 나열할 수 없게 만들어야 함 1234567891011121314//배열에 sum와 avg 메서드를 추가하는 경우const arr = [3, 1.5, 9, 2, 5.2];arr.sum = function() { return this.reduce((a, x) =&gt; a + x);};arr.avg = function() { return this.sum() / this.length;};// for...in문이나 Object.keys, 확산 연산자에서 객체 프로퍼티를 나열할 때 해당 프로퍼티가 포함될지 아닐지 판단Object.defineProperty(arr, \"sum\", { enumerable: false });Object.defineProperty(arr, \"avg\", { enumerable: false });Object.keys(arr); Object.defineProperties : 객체 프로퍼티 이름과 프로퍼티 정의를 서로 연결 12345678910111213141516//Object.definePropertiesconst arr = [3, 1.5, 9, 2, 5.2];Object.defineProperties(arr, { sum: { value: function() { return this.reduce((a, x) =&gt; a + x); }, enumerable: false }, avg: { function() { return this.sum() / this.length; }, enumerable: false }}); 21.3 객체 보호 : 동결, 봉인, 확장 금지 자바스크립트에는 객체를 보호해서 의도하지 않은 수정을 막고, 의도적인 공격은 더 어렵게 만드는 세 가지 메커니즘이 있다. 동결(freezing),봉인(sealing),확장금지(preventing extension)이다. 객체동결 :동결된 객체는 수정할 방법이 없다. 일단 객체를 동결하면 다음과 같은 작업이 불가능해진다.객체를 동결하면 그 객체는 문자열이나 숫자처럼 불변이된다.Object.freeze를 사용하고, 객체가 동결됐는지 확인 할 때는 Object.isFrozen을 사용한다. 프로퍼티 값 수정 또는 할당 프로퍼티 값을 수정하는 메서드 호출 setter 호출 새 프로퍼티 추가 새 메서드 추가 기존 프로퍼티나 메서드의 설정 변경 객체동결123456789101112131415161718192021222324//## 21.3 객체 보호 : 동결, 봉인, 확장 금지\"use strict\";const appInfo = { company: \"white knight software, Inc\", version: \"1.3.5\", buildId: \"padddddddddddddddddd\", //이 함수는 getter이므로 동결한 상태에서도 계속 동작한다. copyright() { return `${new Date().getFullYear()},${this.company}`; }};Object.freeze(appInfo); //동결Object.isFrozen(appInfo); //trueappInfo.newPro = \"test\";//VM3275:16 Uncaught TypeError: Cannot add property newPro, object is not extensibledelete appInfo.company;appInfo.company; //\"white knight software, Inc\"Object.defineProperty(appInfo, \"company\", { enumerable: false });//VM3316:2 Uncaught TypeError: Cannot redefine property: company... 객체 봉인 :객체를 봉인하면 새 프로퍼티를 추가하거나 기존 프로퍼티를 변경 , 삭제할 수 없습니다. (프로퍼티의 값을 변경하는 것은 가능)클래스의 인스턴스를 사용하면서, 인스턴스의 프로퍼티를 수정하는 메서드가 동작하도록 할때 봉인을 사용할 수 있습니다.Object.seal로 객체를 봉인하고, 확인할때는 Object.isSealed를 사용한다. 객체 봉인1234567891011121314151617181920212223242526272829//객체 봉인class Logger { constructor(name) { this.name = name; this.log = []; } add(entry) { this.log.push({ log: entry, timestamp: Date.now() }); }}const log = new Logger(\"Logs\");Object.seal(log);Object.isSealed(log); //truelog.name = \"capting boring log\"; //oklog.add(\"another boring day at sea...\"); //oklog.newPro = \"test\";//TypeError: Cannot add property newPro, object is not extensiblelog.name = \"test\";delete log.name; //VM4096:23 Uncaught TypeError: Cannot delete property 'name' of #&lt;Logger&gt;Object.defineProperty(log, \"log\", { enumerable: false });//Uncaught TypeError: Cannot redefine property: log... 확장 금지 : 객체에 새 프로퍼티를 추가하는 것만 금지된다.프로퍼티에 값을 할당하거나 , 삭제하거나, 속성을 변경하는 작업은 모두 허용된다.확장을 금지할땐 Object.preventExtensions, 확장 금지를 확인할때는 Object.isExtensible을 사용한다. 확장금지1234567891011121314151617181920212223242526\"use strict\";class Logger { constructor(name) { this.name = name; this.log = []; } add(entry) { this.log.push({ log: entry, timestamp: Date.now() }); }}const log2 = new Logger(\"First Mate's log\");Object.preventExtensions(log2);Object.isExtensible(log2); //falselog2.name = \"first..\"; //truelog2.add(\"another...\"); //truelog2.newPro = \"test\"; //VM5050:18 Uncaught TypeError: Cannot add property newPro, object is not extensiblelog2.name = \"test..\"; //truedelete log2.name; //trueObject.defineProperty(log, \"log\", { enumerable: false });// Uncaught TypeError: Cannot redefine property: log... 21.4 프락시 프락시(proxies)는 ES6에서 새로 추가된 메타프로그래밍 기능이다.메타프로그래밍이란 자기 자신을 수정하는 것을 말한다.객체 프락시는 객체에 대한 작업을 가로채고, 필요하다면 작업 자체를 수정하는 기능이다. 프락시12345678910111213141516171819202122232425262728293031323334353637383940414243444546const cofficients = { a: 1, b: 2, c: 5};//이 객체의 프로퍼티가 수학의 계수라면function evaluate(x, co) { return co.a + co.b + co.c * Math.pow(x, 2);}evaluate(4, cofficients); //83//그런데,//계수 일부가 빠진 객체를 가지고 계산해야한다면?const cofficients = { a: 1, c: 5};evaluate(4, cofficients); //NaN//cofficients.b에 0을 할당하면 문제를 해결할수 있지만 프락시를 쓰는 게 더 낫다.//프락시는 정의되지 않은 프로퍼티는 항상 0을 반환하게 만들 수 있다.//cofficients에 객체의 프락시 생성const betterCofficients = new Proxy(cofficients, { get(target, key) { return target[key] || 0; }});evaluate(4, cofficients); //NaNevaluate(4, betterCofficients); //81//betterCofficients 객체의 프락시에는 무한한 프로퍼티가 있고,//직접 정의한 프로퍼티를 제외하면 값이 0인것과 마찬가지이다.betterCofficients.a; //1betterCofficients.b; //0betterCofficients.c; //5betterCofficients.d; //0//키로 소문자 한 글자만 받았을때 프락시가 동작하게 할 수도 있다.const betterCofficients = new Proxy(cofficients, { get(target, key) { if (!/^[a-z]&amp;/.text(key)) return target[key]; return target[key] || 0; }}); Proxy 생성자에 넘기는 첫 번째 매개변수는 타켓, 즉 프락시 할 객체이다. 두번째 매게변수는 가로챌 동작을 가리키는 핸들러이다. 여기서 프로퍼티에 접근하는 동작만 가로챘으며, get 함수가 핸들러이다. get 함수는 매개변수로 타켓, 프로퍼티키(문자열 또는 심볼), 수신자(프락시 자체 또는 프락시에서 파생되는 것)을 받는다.해당 키가 타켓에 있는지 확인하고, 없으면 o을 반환한다. 마찬가지로, 프로퍼티에 값을 할당하려고 할 때 set 핸들러로 가로챌 수 있다. 123456789101112131415161718192021222324//객체에 위험한 프로퍼티가 있어서,//한 단계를 더 거치지 않으면 값을 할당하거나 메서드를 호출할수 없게함const cook = { name: \"Wait\", redPhosphours: 100, //위험하다고 water: 500 //안전하다고};const protectCook = new Proxy(cook, { set(target, key, value) { if (key === \"redPhosphours\") { if (target.allowDangerousOperations) return (target.redPhosphours = value); else return console.log(\"Too dangerous\"); } //다른 프로퍼티는 모두 안전함 target[key] == value; }});protectCook.water; //500protectCook.redPhosphours; //100protectCook.redPhosphours = 150; //Too dangerousprotectCook.allowDangerousOperations = true; // true","link":"/2019/08/29/es6_md/chapter21/"},{"title":"chapter18. 브라우저의 자바스크립트","text":"18.1 ES5와 ES6 서버에서는 ES6 기능 중 무엇이 지원되는지 확실히 알 수 있고, 자바스크립트 엔진을 선택할 수 있습니다.반면 웹에서는 작성한 코드를 실행할 자바스크립트 엔진을 선택하는 것은 불가능하고, 어떤 브라우저인지 알 수 있는 믿을 만한 정보조차 없습니다.사용자의 환경을 컨트롤 하지 않는 한 ES5를 사용해야 합니다.트랜스컴파일을 통해 ES6를 ES5로 바꾸면됩니다. 18.2 문서 객체 모델 DOM 즉 문서객체모델은 HTML 문서의 구조를 나타내는 표기법인 동시에 브라우저가 HTML 문서를 조작하는 핵심입니다.DOM은 트리 구조로 표현합니다. DOM 트리는 노드(node)로 구성됩니다.루트 노트를 제외한 모든 노드엔 부모가 있고, 자식노드는 있어도 되고 없어도 됩니다.루트 노트는 문서(document)이며, 자식 노드는 html요소 하나 뿐입니다.DOM 트리의 모든 노드는 Node 클래스의 인스턴스 입니다. Node 객체에는 트리 구조를 나타내는 parentNode와 childNodes 프로퍼티, 자신에 대한 프로퍼티인 nodeName과 nodeType 프로터피가 있습니다.DOM은 노드로만 구성됩니다. 하지만 모든 노드가 html 요소는 아닙니다. 예를 들어, 문단 태그 p는 html 요소지만, p태그의 텍스트는 텍스트 노드입니다. 노드는 거의 html 요소이고, ‘요소’라고 하면 그건 ‘요소 노드’를 가리킵니다. 이번장에 사용할 HTML 문서12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Simple html&lt;/title&gt; &lt;style&gt; .callout { border: 1px solid #ff0080; margin: 2px 4px; padding: 2px 6px; } .code { background: #ccc; margin: 1px 2px; padding: 1px 4px; font-family: monospace; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;header&gt; &lt;h1&gt;Simple Html&lt;/h1&gt; &lt;/header&gt; &lt;div id=\"content\"&gt; &lt;p&gt;This is a &lt;i&gt;simple&lt;/i&gt; HTML file.&lt;/p&gt; &lt;div class=\"callout\"&gt; &lt;p&gt;this is as fancy as...we'll get!&lt;/p&gt; &lt;/div&gt; &lt;p&gt; IDs (such as &lt;span class=\"code\"&gt;#content&lt;/span&gt;) are unique (there can only be one per page). &lt;/p&gt; &lt;p&gt; Classes (such as &lt;span&gt;.callout&lt;/span&gt;) can be used on many elements &lt;/p&gt; &lt;div id=\"callout2\" class=\"callout fancy\"&gt; &lt;p&gt;A single HTML element can have multiple classes&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 12345678//document에서 시작해서 DOM 전체를 순회하며 콘솔출력function printDOM(node, prefix) { console.log(prefix + node.nodeName); for (let i = 0; i &lt; node.childNodes.length; i++) { printDOM(node.childNodes[i], prefix + \"\\t\"); }}printDOM(document, \"\"); 모든 노드에는 nodeType, nodeName 프로퍼티가 있다.nodeType은 그 노드가 어떤 타입인지 나타내는 정수입니다. 18.3 용어 사용 부모 노드는 직접적인 부모 즉 바로 윗 단계를 말한다.자식 노드 역시 직접적인 자식이다.자손은 자식, 자식의 자식등을 발한다.조상은 부모, 부모의 부모 등을 말한다. 18.4 get 메서드 document.getElementById는 id를 이용해 요소를 찾는다.document.getElementsByClassName는 주어진 클래스 이름에 해당하는 요소를 찾는다.document.getElementsByTagName은 주어진 태그 이름에 해당하는 요소를 찾는다. 18.5 DOM 요소 쿼리 document.querySelector와 document.querySelectorAll은 css 선택자를 사용해 요소를 찾는 메서드이다. 18.6 DOM 요소 조작 모든 요소에는 textContent와 innerHTML 프로퍼티가 있다.이 프로퍼티를 통해 요소의 콘텐츠에 접근하거나 수정 할 수 있다.textContent는 HTN 태그를 제거한 순수한 텍스트 데이터만 제공하며,innerHTML을 통해 HTML 태그를 수정하면 DOM이 그에 맞게 변경된다. 123456// ## 18.6 DOM 요소 조작const para1 = document.getElementsByTagName(\"p\")[0];para1.textContent; //\"This is simple HTML...\"para1.innerHTML; //\"This is simple HTML...\"\"para1.textContent = \"Modified HTML file\";para1.innerHTML = \"Modified HTML file\"; 18.7 새 DOM 요소 만들기 document.createElement로 새 노드를 만들 수 있다.이 메서드는 새 요소를 만들지만 DOM 요소에 추가하지는 않습니다.DOM에 추가하는건 따로 해야한다.insertBefore과 appendChild 메서드를 사용해 DOM에 추가한다. 12345678910111213//요소 생성const p1 = document.createElement(\"p\");const p2 = document.createElement(\"p\");//요소에 텍스트 생성p1.textContent = \"i was created dynamically\";p2.textContent = \"i was also created dynamically\";//DOM에 추가const parent = document.getElementById(\"content\");const firstChild = parent.childNodes[0];parent.insertBefore(p1, firstChild);parent.appendChild(p2); 18.8 요소 스타일링 요소의 스타일을 바꿀땐 그에 맞는 css 클래스를 새로 만들고, 그 클래스를 원하는 요소에 지정classList.add 메서드로 클래스 추가 가능classList.remove 메서드로 클래스 제거 가능 12345678910111213141516171819function highlightParas(containing) { if (typeof containing === \"string\") containing = new RegExp(`\\\\b${containing}\\\\b`, \"i\"); const paras = document.getElementsByTagName(\"p\"); console.log(paras); for (let p of paras) { if (!containing.test(p.textContent)) continue; p.classList.add(\"highlight\"); }}highlightParas(\"unique\");//클래스 제거function removeParaHighlights() { const paras = document.querySelectorAll(\"p.highlight\"); for (let p of paras) { p.classList.remove(\"highlight\"); }} 18.9 데이터 속성 html5에서는 데이터(data-)속성을 도입html 요소에 임의의 데이터를 추가 가능 12345&lt;!--버튼 추가--&gt;&lt;button data-action=\"highlight\" data-containing=\"unique\"&gt; Highlight paragraphs containing \"unique\"&lt;/button&gt;&lt;button data-action=\"removeHighlights\"&gt;Remove highlight&lt;/button&gt; 1234// ## 18.9 데이터 속성const highlightActions = document.querySelectorAll('[data-action=\"highlight\"]');highlightActions[0].dataset;// DOMStringMap {action: \"highlight\", containing: \"unique\"} 18.10 이벤트 모든 요소에는 addEventListener라는 메서드가 있다.이 메서드를 통해 이벤트가 일어났을 때 호출할 함수를 저장할 수 있다.호출할 함수는 Event 타입의 객체 하나만을 매개변수로 받는다.이벤트 객체에는 해당 이벤트에 관한 정보가 모두 존재click 이벤틍[는 클릭한 좌표를 나타내는 clinetX, clientY 프로퍼티가 있고, 이벤트가 일어난 요소를 나타내는 target 프로퍼티가 있다.기본 핸들로가 지정된 이벤트도 있다. 링크 등이 그 예제이런 기본 이벤트 핸들러를 막기위해선 preventDefault()를 사용 18.10.1 이벤트 버블링과 캡쳐링 html은 계층적이므로 이벤트를 꼭 한곳에만 처리해야하는 건 아니다.먼 조상부터 시작하는 캡쳐링과 이벤트가 일어난 요소에서 시작해 거슬러 올라가는 버블링이 있다.이벤트 핸들러에는 다른 핸들러가 어떻게 호출될지 영향을 주는 세 가지 방법이 있다.preventDefault : 이벤트를 취소한다. 취소된 이벤트가 전달은 되지만 defaultPrevented 프로퍼티가 true로 바뀐째 전달되고, 브라우저는 defaultPrevented :true로 바뀐 이벤트를 무시하므로 아무일도 일어나지 않는다.stopPropagation : 이벤트를 현재 요소에서 끝내고 더는 전달되지 않게 막는다. 즉 해당 요소에 연결된 이벤트 핸들러는 동작하지만, 다른 요소에 연결된 이벤트 핸들러는 동작하지 않습니다.stopImmediatePropagation : 다른 이벤트 핸들러, 심지어 현재 요소에 연결된 이벤트 핸들러도 동작하지 않게 막는다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;event&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;button&gt;click me&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function logEvent(handlerName, type, cancel, stop, stopImmediate) { //실제 이벤트 핸들러 return function(evt) { if (cancel) evt.preventDefault(); if (stop) evt.stopPropagation(); if (stopImmediate) evt.stopImmediatePropagation(); console.log( `${type} : ${handlerName}` + (evt.defaultPrevented ? \"(calceled)\" : \"\") ); }; } //이벤트 핸들러를 요소에 추가 function addEventLogger(elt, type, action) { const capture = type === \"capture\"; elt.addEventListener( \"click\", logEvent( elt.tagName, type, action === \"cancel\", action === \"stop\", action === \"stop!\" ), capture ); } const body = document.querySelector(\"body\"); const div = document.querySelector(\"div\"); const button = document.querySelector(\"button\"); addEventLogger(body, \"capture\"); addEventLogger(body, \"bubble\"); addEventLogger(div, \"capture\"); addEventLogger(div, \"bubble\"); addEventLogger(button, \"capture\"); addEventLogger(button, \"bubble\"); /* //1. 버튼을 눌렀을때 결과 capture : BODY capture : DIV capture : BUTTON bubble : BUTTON bubble : DIV bubble : BODY */ //1. 결론 : 캡쳐링이 먼저 시작되고 그 후에 버블링이 일어난다. //2.이벤트 취소 addEventLogger(body, \"capture\"); addEventLogger(body, \"bubble\"); addEventLogger(div, \"capture\", \"cancel\"); addEventLogger(div, \"bubble\"); addEventLogger(button, \"capture\"); addEventLogger(button, \"bubble\"); /* //2.버튼을 눌렀을때 결과 capture : BODY capture : DIV(calceled) capture : BUTTON(calceled) bubble : BUTTON(calceled) bubble : DIV(calceled) bubble : BODY(calceled) */ //2.결론 : 이벤트 전달은 계속되지만, 이벤트가 취소되었다고 기록됨 //3.버튼 캡쳐 단계에서 이벤트 전달을 중지해보자 addEventLogger(body, \"capture\"); addEventLogger(body, \"bubble\"); addEventLogger(div, \"capture\", \"cancel\"); addEventLogger(div, \"bubble\"); addEventLogger(button, \"capture\", \"stop\"); addEventLogger(button, \"bubble\"); /* //3.버튼을 눌렀을때 결과 capture : BODY capture : DIV(calceled) capture : BUTTON(calceled) bubble : BUTTON(calceled) */ //3.결론 : 버튼 요소에서 이벤트 전달이 멈춤 캡쳐링까지는 진행하고 멈추게 했지만, 버튼의 버블링 이벤트는 여전히 발생한다. 다만 div나 body 요소는 이벤트 버블링을 받지 못한다. //4.버튼의 캡쳐단계에서 즉시 멈추게 만들기 addEventLogger(body, \"capture\"); addEventLogger(body, \"bubble\"); addEventLogger(div, \"capture\", \"cancel\"); addEventLogger(div, \"bubble\"); addEventLogger(button, \"capture\", \"stop!\"); addEventLogger(button, \"bubble\"); /* //4.버튼을 눌렀을때 결과 capture : BODY capture : DIV(calceled) capture : BUTTON(calceled) */ //4.결론 : 캡쳐 단계에서 이벤트 전달이 완전히 멈춰서 그 후로는 아무일도 발생하지 않는다. &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 18.10.2 이벤트 카테고리 드래그 이벤트 : dragstart, drag, dragend, drop 등의 이벤트를 통해 드래그 앤 드롭 인터페이스를 만들 수 있다. 포커스 이벤트 : 사용자가 폼 필드 같은 편집 가능한 요소를 조작하려 할때 사용focus : 필드에 들어갈 때 사용blur : 필드에서 나올 때 사용change :사용자가 필드의 내용을 바꿀때 폼 이벤트 : 사용자가 전송 버튼을 클릭하거나, 엔터를 눌러서 폼을 전송할 때 submit 이벤트가 발생 입력 장치 이벤트 :마우스 이벤트 : click외에도 mousedown, move, mouseup, mouseenter, mouseleave, mouseover, mousewheel 이벤트 등키보드 이벤트 : keydown, keypress ,keyup터치 이벤트 : 터치 장치의 터치 이벤트는 마우스 이벤트보다 우선 미디어 이벤트 : html 비디오, 오디오 플레이어에 관련한 이벤트로 pause, play 등 진행 이벤트 : 브라우저가 콘텐츠를 불러오는 과정에서 발생load : 브라우저가 요소와 그에 연관된 자원을 모두 불러올 떄 발생 터치 이벤트 : 이벤트의 touches프로퍼티를 통해 터치를 지원 18.11 Ajax 비동기적 자바스크립트와 XML의 약어Ajax를 통해 서버와 비동기적으로 통신하면 페이지 전체를 새로 고칠 필요 없이 서버에서 데이터를 받아 올 수 있다.","link":"/2019/08/11/es6_md/chapter18/"},{"title":"chapter4. 제어문","text":"4.1.2 블록문 여러 개의 중괄호로 묶은 것제어문에는 블록을 쓰는 것이 일반적 12345let funds = 50; //시작조건while(funds&gt;1 &amp;&amp; funds &lt;100){ funds = funds +2; funds = funds -1;} 4.1.3 공백블록이 없는 경우 12345let funds = 50; //시작조건while(funds&gt;1 &amp;&amp; funds &lt;100) funds = funds +2; //while 루프 바디 funds = funds -1; //while 루프 끝난 후 실행 4.1.4 보조 함수123456789//m 이상 n 이하의 무작위 정수를 반환한다.function rand(m,n){ return m + Math.floor((n - m +1) * Math.random());} //크라운 앤 랭커 게임의 여섯 가지 도형 중 하나를 무작위로 반환한다.function randFace(){ return [\"crown\",\"anchor\",\"heart\",\"spade\",\"Club\",\"diamond\"][rand(0,5)];} 4.1.5 if else 문123456789const bets = {crown:0, anchor:0, heart:0, spade:0, club:0, diamond:0}; //토마스가 베팅할 카드 목록 {카드:얼마}let totalBet = rand(1,funds);if(totalBet===7){ //만약 돈을 7펜스를 뽑으면 totalBet = funds; //남은 돈을 다 건다. bets.heart = totalBet; //하트에 건다.}else{ //그 판에 걸 돈을 분배}funds = funds - totalBet; // 남은돈 = 기존판에 남은돈 - 건 돈의 총액 4.1.6 do while 루프 while과 다르게 시작하면서 조건을 검사하지 않고 마지막에 검사한다.루프바디를 최소 한 번은 실행하려 할 때 사용 1234567let remaining = totalBet; //남은돈 = 걸 돈 총액;do{ let bet = rand(1,remaining); let face = randFace(); bets[face] = bets[face] + bet; remaining = remaining - bet;}while(remaining&gt;0); 4.1.7 for 루프 어떤 일을 정해진 숫자만큼 반복할 때 1234const hand =[];for(let roll=0; roll &lt;3; roll++){ hand.push(randFace());} 4.1.8 if문123456let winnings = 0; for(let die=0; die&lt;hand.length; die++){//hand.length ==3 (주사위를 세 번 굴린다.) let face = hand[die]; if(bets[face] &gt; 0) winnings = winnings + bets[face]; } funds = funds +winnings; 4.1.9 하나로합치기크라운앤앵커게임1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*[규칙]1. 크라운, 앵커, 하트, 클럽, 스페이드, 다이아몬드 그림이 있고 선원이 무작위로 돈을 건다.2. 6면체 주사위 세개를 굴린다. 3. 주사위가 사각형 번호에 일치하는 숫자에 멈추면 선원은 거기 건 만큼의 돈을 따게된다.4. 예외 -&gt; 토마스(선원)에게는 몇가지 규칙이 있다.4-1)*///m 이상 n 이하의 무작위 정수를 반환합니다.function rand(m,n){ return m + Math.floor((n - m + 1) * Math.random());} //rand(0,5) = &gt; 0~5까지의 무작위 수를 반환.//크라운 앤 앵커 게임의 여섯 그림 중 하나에 해당하는 문자열을 무작위로 반환합니다.function randFace(){ return [\"crown\",\"anchor\",\"heart\",\"spade\",\"club\",\"diamond\"][rand(0,5)];} // randFace() =&gt; \"crown\"randFace();let funds = 50; //선원이 가진 초기자본 = 50펜스let round = 0; //게임 라운드while(funds &gt; 1 &amp;&amp; funds &lt; 100){ //선원 규칙 100펜스,0펜스가 되면 게임종료 즉 게임을 계속할때 round++; //게임 라운드가 1 올라가고 console.log('round ${round}:'); //돈을 건다. let bets = {crown :0 ,anchor:0,heart:0,spade:0,club:0,diamond:0}; let totalBet = rand(1,funds); //1~99까지의 무작위 금액을 거는 것에 대한 토탈 배팅 금액 console.log(totalBet); //선원의 조건 if(totalBet ===7){ //뽑은 돈이 7펜스면 totalBet == funds; //남은 돈을 다 배팅 bets.heart = totalBet //현재는 0 인데 남은 돈 하트에 걸어버림 }else{ //판돈 나누기 let remaining = totalBet; do{ let bet = rand(1,remaining); //1~남은돈까지의 무작위 금액을 거는 것에 대한 배팅 금액 let face = randFace();// randFace() =&gt; \"crown\" bets[face] = bets[face] + bet; //0 = 0 + (1~남은돈까지의 무작위 금액을 거는 것에 대한 배팅 금액) remaining = remaining -bet //남은돈 = 남은돈 - (1~남은돈까지의 무작위 금액을 거는 것에 대한 배팅 금액) }while(remaining&gt;0)//남은 돈이 0보다 클 때까지 do 구문을 계속 반복 } funds = funds - totalBet; //자본 = 자본 - 건돈 총액 //주사위 굴리기 contst hand =[]; for(let roll = 0; roll&lt;3; roll++ ){ //3개의 주사위를 굴림 hand.push(randFace()); // hand 배열에 \"crown\" 넣음 } //딴 돈을 가져옴 let winnings = 0; for(let die=0; die&lt;hand.length; die++){ let face = hand[die]; if(bets[face] &gt;0) winnings = winnings + bets[face]; } funds = funds + winnings;} 4.2 자바스크립트 제어문 조건문ifif elseswitch 반복문whiledo whilefor 4.2.1 제어문의 예외 제어문의 실행 방식을 바꿈break :루프 중간에 빠져나감continue : 루프 다음 단계로 바로 건너뜀return : 루프문 무시 함수 빠져나감throw : 반드시 처리해야할 예외를 발생(제어문 밖에서도 작용) 4.2.2. if else 문을 체인으로 연결하기12345678//수요일을 싫어해서 배팅 1 if(new Date().getDay()===3){ //new Date().getDay() 요일 반환 0은 일요일 totalBet === 1;}else if(totalBet===7){ //7펜스를 뽑으면 전부 배팅 totalBet === funds;}else{ console.log(\"no supersitition here\");}; 4.2.3 메타문법 다른 문법을 설명하는 문법, 자바스크립트 제어문을 간결하게 표현대괄호([]) : 옵션생략 부호 (…) : ‘여기 들어갈 내용이 더 있다’단어 : placeholderexpression: 어떤 값condition: 참 또는 거짓 같은 메타문법1234567891011121314151617181920212223//while : 컨디션이 참 같은 값이면 statement 를 실행한다.while(condition) statement //if else if(condition) //condition이 참 같은 값이면 statement1//statement1실행[else //그렇지 않다면 statement2] //statement2 실행 //do while do statement //statement는 최소한 한 번 실행 while(condition); //condition이 참 같은 값일 동안 반복 실행 //forfor([initialization];[condition];[final-expression]) statement/*루프에 들어가기 전 initialization 실행condition이 참인 동안 statement 실행 final-expression을 실행한 다음 condition 다시 체크*/ 4.2.4 for 루프의 다른 패턴​&gt; 쉼표 연산자를 쓰면 초기화와 마지막 표현식에 여러 문을 결합 할 수 있다. 루프의_다른_패턴 12345678910111213141516//피보나치 수열 =&gt; i,j 동시 선언, 세 변수 동시 조작 for(let temp, i=0, j=1; j&lt;30; temp =i, i =j, j = i + temp)console.log(j); //for 루프에서 조건 생략시 항상 true로 평가되어 무한 루프 for(;;) console.log(\"i will repeat\"); //특이한 for문들..let s ='3'; //숫자가 들어있는 문자열for(; s&lt;s.length; s ='' + s); //문자열의 길이가 조건 for(let x = 0.2; x&lt;3.0; x +=0.2) //제어변수가 정수가 아님 console.log(x); for(; !player.isBroke;) //조건에 객체 프로퍼티 사용console.log('still playing'); 4.2.5 switch 문 for 문이 두가지 중 하나를 선택하는 경우라면 switch는 조건 하나로 여러 가지 중 하나를 선택 12345678910111213141516171819202122232425262728293031323334353637383940414243//switchswitch(totalBet){ case 7 : //totalBet ==7 일때 totalBet = funds; //조건 실행 break; // 이 루프를 빠져나감 case 13 : // totalBet == 13일때 1펜스 기부 totalBet = funds -1; case 11 : //break 문이 없으므로 case 13 다음 바로 11로 넘어감 totalBet = 0; break; case 21 : //break가 걸렸으므로 안 넘어감 totalBet = 21; break; default : //case 절이 없을 때 실행 console.log(\"no\"); break;``` * return```javascript//return 즉시 함수를 빠져나갑니다.function adjustBet(totalBet,funds){ switch(totalBet){ case 7: return funds; case 13: return 0; //break문 대신 return을 사용 할 수 있다. default : return totalBet; }}``` ## 4.2.6 for ...in 루프&gt;객체에 프로퍼티에 루프를 실행하도록 설계 ```javascriptconst player={name:'Thomas',rank:'Midshipman',age:25};for(let prop in player){ if(!player.hasOwnProperty(prop)) continue; console.log(prop + ':' + player[prop]);} 4.2.7 for …of 루프 es6에서새로 생긴 반복문","link":"/2019/06/25/es6_md/chapter4/"},{"title":"chapter5. 표현식과 연산자","text":"5.1 연산자 값을 만드는 행동 반드시 피연산자가 있어야 한다. 5.2 산술 연산자 전위 연산자(–i , ++i) : 먼저 변수의 값을 바꾼 다음 평가후위 연산자(i– , i++) : 값을 바꾸기 전에 평가 12345678910111213141516171819//전위 연산자 후의 연산자let x = 2;const r1 = x++ + x++;console.log(r1); //5const r2 = ++x + ++x;console.log(r2); //11const r3 = x++ + ++x;console.log(r3); //14const r4 = ++x + x++;console.log(r4); //18let y = 10;const r5 = y-- + y--;console.log(r5); //19const r6 = --y + --y;console.log(r6); //13const r7 = y-- + --y;console.log(r7); //10const r8 = --y + y--;console.log(r8); //6 5.3 연산자 우선순위 5.4 비교 연산자 두 개의 값을 비교일치연산자 (===) : 같은 객체를 가리키거나 , 같은 타입이면서 값도 같음 / !== : 일치하지 않음동등연산자 (==) : 같은 객체를 가리키거나, 값이 같음 ex) “33” == 33대소관계 1234567891011121314//일치연산자와 동등연산차 차이//비교 연산자const n = 5;const s = \"5\";n === s; //falsen !== s; //truen === Number(s); //truen == s; //true 권장 xconst a = { name: \"an\" };const b = { name: \"an\" };a === b; //false 객체는 항상 다름a == b; //false 객체는 항상 다름 관계연산자 : 관계가 있는 값을 비교 작다(&lt;),작거나 같다(&lt;=),크다(&gt;),크거나 같다(&gt;=) 5.5 숫자비교 NaN : 그 자신을 포함하여 무엇과되 같지 않음 NaN === NaN / NaN ==NaN 모두 falseisNaN을 사용하여 NaN 값을 알아낼수 있다. 정수비교123456789101112131415//정수비교let n = 0;while (true) { n += 0.1; if (n === 0.3) break;}console.log(`stop at${n}`); //실행 안됌/* EPSILON */let n = 0;while (true) { n += 0.1; if (Math.abs(n - 0.3) &lt; Number.EPSILON) break;}console.log(`stop at${n}`); //결과 stop at0.30000000000000004 5.6 문자열 병합 문자열 병합은 피연산자중 하나라도 문자열이면 문자열 병합을 수행 123 + 5 + \"8\"; // \"88\"\"3\" + 5 + 8; //\"358\" 5.7 논리 연산자 오직 불리언 값만 다룰수 있다. true or falseboolean이 아닌 값도 다룰 수 있고, boolean이 아닌 값을 반환하기도 한다. 5.7.1 참 같은 값과 거짓 같은 값 자바스크립트에서는 모든 데이터를 참 같은 값과 거짓 같은 값으로 나눌 수 있다. 거짓 같은 값 undefined null false 0 NaN ‘’ (빈 문자열) 이들 외에는 모드 참 같은 값 참 같은 값 모든 객체 valueOf() 메서드를 호출 했을때 false를 반환하는 객체도 참 같은 값 배열, 빈 배열도 참 같은 값 공백만 있는 문자열 “ “ 문자열 “false” 5.8 AND, OR, NOT 자바스크립트가 지원하는 논리연산자는 AND(&amp;&amp;) OR(||) NOT(!)&amp;&amp; : 교집합,|| : 합집합! : 부정 5.8.1 단축평가 x = true, y = falsex&amp;&amp;y =false //x의 값만 알면 y의 값을 평가할 필요도 없이 falsex||y =true //x의 값만 알면 y의 값을 평가할 필요도 없이 true 12345678910111213141516171819202122232425//단축평가const skipIt = true;let x = 0; //falseconst result = skipIt || x++; //1==true || 0 false 의 합집합 ==true 1console.log(result); //true//skipIt 가 true이고 true 값의 합집합은 true 이므로 뒤 표현식 실행 안됌 x = 0//부수효과const skipIt = false;let x = 0; //falseconst result = skipIt || x++; //0과 1의 합집합console.log(result); //0// skipIt가 false라고 해서 합집합이 항상 false가 아니므로 x++ 실행 x = 1 부수효과 실행const doIt = false;let x = 0; //falseconst result = doIt &amp;&amp; x++; //0과 0의 교집합console.log(result); //false// skipIt 가 false이고 false의 교집합은 false이므로 두 번째 피연산자를 실행하지 않는다. x = 0const doIt = true;let x = 0; //falseconst result = doIt &amp;&amp; x++; //0과 0의 교집합console.log(result); //0// skipIt 가 true라고 해서 교집합이항상 true를 반환하는 것이 아니므로 x++ 실행 x = 1 부수효과 실행 5.8.2 피연산자가 불리언이 아닐때 논리 연산자가 동작하는 방법1const options = suppliedOptions || { name: \"Default\" }; 5.8.3 조건 연산자 유일한 3항 연산자 조건 연산자123const doIt = false;const result = doIt ? \"Did it\" : \"Didn't do it\";console.log(result); 5.8.4 쉼표 연산자 표현식을 결합하여 두 표현식을 평가한 후, 두번째 표현식의 결과를 반환=&gt; 마지막 표현식의 결과를 반환for 문에서 표현식을 결합할 때 사용하거나, 함수에서 빠져나오기 전 여러 작업을 한데 묶을 때 사용합니다 12345let x = 0, y = 10, z;z = (x++, y++);console.log(z); //10 5.9 연산자 그룹 (괄호)에는 아무 효과도 없지만, 연산자 우선순위를 높이거나 명확히 표현하는데 사용 5.9.1 비트 연산자 별로 사용안함 5.9.2 typeOf 연산자 피연산자의 타입을 나타내는 문자열을 반환, 자바스크립트의 7가지 데이터타입(undefined, null, boolean, 숫자, 문자, 심볼, 객체)를 정확히 나타내지 못함 .typeOf x : 권장typeOf(x): 유효하긴 하지만 권장하진 않음 5.9.3 void 연산자 피연산자를 평가한후 undefined를 반환링크 이동을 막아줍니다. 5.9.4 할당 연산자 변수에 값을 할당 5.10 헤체할당 객체나 배열을 변수로 해체할 수 있다. es6에서 새로 도입됨 123456789//객체 선언const obj = { b: 2, c: 3, d: 4 };//객체할당const { a, b, c } = obj;a; //undefined \"a\"가 없습니다.b; //2c; //3d; //ReferenceError \"d\"는 정의되지 않았습니다. 객체를 해체할 때는 반드시 변수명과 프로퍼티 이름이 일치해야 합니다. obj에 a 프로퍼티가 없으므로 a는 undefined 해체 할당에 d라는 프로퍼티가 없으므로 d는 선언조차 되지 않음 배열 해체 12345678910111213//배열 선언const arr = [1, 2, 3];let [x, y] = arr;x;y;z; //ReferenceError \"z\"는 정의되지 않았습니다.//확산 연산자를 사용하면 남은 요소를 새 배열에 할당할수 있다.const arr = [1, 2, 3, 4, 5];let [x, y, ...rest] = arr;x; // 1y; //2rest; //[3,4,5] 배열을 해체할 때는 변수 이름을 마음대로 써도 됨 , 배열 순서에 대응한다. 5.11 객체와 배열 연산자 5.12 탬플릿 문자열과 표현식 어떤 표현식이든 그 값을 문자열에 넣을 수 있다. 123456789101112const roomTempC = 21.5;const currentTempC = 19.5;const message = `The current temperature is` + `${currentTempC - roomTempC}\\u00b0C dirrenet than room temperature`;const fahrenheit = `the current temperature is ${(currentTempC * 9) / 5 + 32}\\u00b0F`;console.log(message);console.log(fahrenheit);//The current temperature is-2°C dirrenet than room temperature//the current temperature is 67.1°F 5.13.1 if…else 문을 3항 연산자로 바꾸기12345678//if else문을 3항 연산자로 변경if (isPrime(n)) { label = \"prime\";} else { label = \"non-prime\";}label = isPrime(n) ? \"prime\" : \"non-prime\"; 5.13.2 if문을 단축 평가하는 OR 표현식으로 바꾸기123if (!options) options = {};options = options || {};","link":"/2019/07/03/es6_md/chapter5/"},{"title":"chapter7. 스코프","text":"스코프 변수와 상수, 매개변수가 언제 어디서 정의되는지를 결정ex ) 함수 매개변수가 함수 바디 안에서만 존재하는 것 스코프123456//스코프function f(x){ return x + 3;}f(5); // 8x; //ReferenceError : x is not defined x가 아주 잠시나마 존재했으므로 x + 3을 계산 할 수 있었다. 그러나 함수를 벗어나면 x가 존재하지 않는 것처럼 보인다. 따라서 x의 스코프가 함수 f라고한다. 스코프 : 시야, 범위라고 이해 변수의 스코프가 어떤 함수라고 말할 때, 함수를 실제 호출할 때 까지는 함수 바디의 정해진 매개변수가 존재하지 않는다. 함수를 호출할 때마다 매개변수가 나타나고, 함수가 제어권을 반환하면 스코프 밖으로 사라진다. 변수와 상수는 만들기 전에는 존재하지 않는다. let이나 const로 선언 하기 전에는 스코프 안에서 존재하지 않는다. (var는 특수한 경우) 변수를 선언 : 식별자를 주어서 존재를 알린다.변수를 정의 : 선언과 함께 값을 부여한다.자바스크립트는 선언과 동시에 값이 주어지므로 둘을 구분하지 않는다. 7.1 스코프와 존재변수가 존재하지 않으면 그 변수는 스코프안에 ‘있지 않음’ → 그 변수는 존재하지 않는다 ?꼭 그런건 아님 스코프 : 실행 컨텍스트에서 현재 보이고 접근할 수 있는 식별자존재한다 : 그 식별자가 메모리가 할당된 무언가를 가리킴 ‘존재하지만 스코프 안에는 없는 변수의 예’ 무언가가 더 존재하지 않는다 해도 자바스크립트는 메모리를 바로 회수하는 것이 아닌, 자동적으로 가비지 콜렉션 프로세스에서 메모리를 회수 한다. 7.1 정적 스코프와 동적 스코프1234567891011function f1(){ console.log('one');}; function f2(){ console.log('two');}; f2();f1();f2(); 정적으로 보면 이 프로그램은 위에서 아래로 읽어내리지만(f1 정의-> f2정의) 실행을 하면 f2 -> f1 -> f2 자바스크립트의 스코프는 정적, 어떤 변수가 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다. 1234567891011const x = 3;function f(){ console.log(x); console.log(y);} { //새 스코프 const y = 5; f();} 1. 변수 x는 함수 f를 정의 할 때 존재하나 y는 다른 스코프에도 존재 한다. 2. 다른 스코프에서 y를 선언하고 그 스코프에서 f를 호출하더라도 f를 호출하면 x는 그 바디 안에 스코프에 있지만 y는 그렇지 않다. 3. 정적 스코프는 전역 스코프, 블록 스코프 , 함수 스코프에 적용된다. 7.3 전역 스코프스코프는 계층적이며 트리 맨아래 바탕이 되는 무언가가 있어야 한다.-&gt; 암시적으로 주어지는 스코프가 필요 이를 전역 스코프 라고 한다. 전역 스코프에서 선언한 것은 무엇이든 프로그램의 모든 스코프에서 볼 수 있다. 전역변수 : 전역 스코프에서 선언된 것 , 전역 스코프에 의존하는 걸 피해라.. 12345678910//전역 스코프, 전역변수 let name = 'lrene' //전역let age = 25; //전역 function greet(){ console.log(`hello ${name}`);}function getBirthYear(){ return new Date().getFullYear() - age;} 1. 함수가 호출하는 스코프에 대단히 의존적이다 2. name과 age의 값을 어디든지 실수로 바꿀 수 있다. 3. greet()와 getBirthYear()도 전역 변수에 의존하므로 name과 age를 정확히 사용한다는 가정에서만 쓸 수 있다. 12345678910111213//전역 스코프, 전역변수 개선ver1//단일 객체에 보관 let user = { name = 'Irene', age : 25,}; function greet(){ console.log(`hello ${name}`);}function getBirthYear(){ return new Date().getFullYear() - age;} 1. user을 써서 단일 객체에 보관 2. 그러나 아직 greet와 getBirthYear은 전역 user에 의존 123456789//전역 스코프, 전역변수 개선ver2//모든 스코프에서 호출할 수 있고, 명시적으로 user을 전달 받음 function greet(user){ console.log(`hello ${user.name}`);} function getBirthYear(user){ return new Date().getFullYear() - user.age;} 1. 모든 스코프에서 호출할 수 있고, 명시적으로 user을 전달 받음 7.4 블록 스코프 블록의 스코프안에서만 보이는 식별자let,const는 식별자를 블록 스코프에서 선언 1234567891011121314151617//블록 스코프 console.log('before block'); { console.log('inside block'); const x = 3; console.log(x);}console.log(`outside block; x = ${x}`);//결과/*before block inside block 3ReferenceError: x is not defined*/ x는 블록 안에서 정의되었고, 블록을 나가는 즉시 x도 스코프 밖으로 사라지므로 정의되지 않은 것으로 간주 7.5 변수 숨기기 다른 스코프에 있으면서 이름이 같은 변수나 상수는 혼란을 초래 1234567891011121314{ //block 1 const x = 'blue'; console.log(x); // \"blue\"}console.log(x); //ReferenceError: x is not defined { //block2 const x = 3; console.log(x) // \"3\"} console.log(typeof x); //undefined ; x는 스코프 밖에 있습니다. 변수 숨기기 12345678910111213141516//스코프 중첩 { //외부블록 let x = 'blue'; console.log(x) ; //\"blue\" { //내부블록 let x = 3; console.log(x); // \"3\" } console.log(x); //\"blue\" } console.log(typeof x); //undefined ; x는 스코프에 있지 않습니다. . 1. 내부 블록의 x와 외부블록의 x는 이름만 같은 다른 변수이다. 2. 그러므로 외부 스코프의 x를 숨기는 (가리는) 효과를 발휘 3. 실행 흐름이 내부 블록에 들어가 새 x를 정의 할 때, 두 변수가 모두 스코프 안에 있다 4. 이름이 같은 x의 경우 내부 블록에서 외부 스코프에 접근 할 방법은 없음 1234567891011121314151617{ //외부블록 let x = {color : \"blue\"}; let y = x; let z =3; { //내부블록 let x = 5; //외부블록의 x가 가려짐 console.log(x); //5 console.log(y.color)//\"blue\": y가 가리키는 외부 스코프의 x가 가리키는 객체는 모두 스코프 안에 있다. y.color = \"red\"; console.log(z) //\"3\" :z는 숨겨지지 않았다. } console.log(x.color); //\"red\" 객체가 내부스코프에서 수정됨 console.log(y.color); //\"red\"; x와 y는 같은 객체를 가리킴 console.log(z); //\"3\"} 1. 스코프는 계층적 , 이로인해 스코프 체인이란 개념이 생김 2. 스코프 체인에 있는 변수는 스코프에 있는 것이므로 숨겨지지만 않으면 접근이 가능하다. 7.6 함수, 클로저, 정적 스코프 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 경우가 많다.이를 클로저라고 한다.클로저 : 스코프를 함수 주변으로 좁히는 것 클로저예제12345678910//클로저 예제 let globalFunc; //정의되지 않은 전역함수 { let blockVar = \"a\"; globalFunc = function(){ console.log(blockVar); }} globalFunc(); //\"a\" 1. globalFunc가 블록 안에서 값을 할당 받음 2. globalFunc를 호출하면 이 함수는 스코프에서 빠져나왔어도 blockVar에 접근 할 수 있다. 3. 일반적으로 스코프를 빠져나가면 해당 스코프 안에서 선언한 변수는 메모리에서 제거해도 안전하다 4. 그러나 스코프 안에서 함수를 정의했고, 이 함수는 스코프 밖에서도 참조할 수 있으므로 자바스크립트는 스코프를 계속 유지한다. => 즉, 스코프 안에서 함수를 정의하면 해당 스코프는 더 오래 유지가 된다 . => 또한, 접근 할 수 없는 것에 접근 할 수 있게하는 효과도 있다. 123456789let f; //정의되지 않은 함수 { let o = {note : 'safe'}; f = function(){ return 0; }}let oRef = f();oRef.note = 'not so safe after all!'; 1. 일반적으로 스코프 바깥쪽에 있는 것들은 접근할 수 없다. 2. 그러나 함수를 정의해 클로저를 만들면 접근할 방법이 생긴다 . 7.7 즉시 호출하는 함수 표현식 함수 표현식을 사용하면 즉시 호출하는 함수 표현식(llEF)를 만들 수 있다.IIFE : Immediately Invoked Function Expressions, 함수를 선언하고 즉시 실행 IIEF1234//IIEF(function(){ //IIEF 바디 })(); 함수 표현식으로 익명 함수를 만들고 그 함수를 즉시 호출 IIFE는 내부에 있는 것 모두 자신의 스코프를 가지지만, IIEF가 함수이므로 스코프 밖으로 무언갈 내보낼 수 있는 장점을 가짐 12345const message =(function(){ const secret = \"I'm a secret!\"; return `The secret is ${secret.length} characters long.`;})();console.log(message);//The secret is 13 characters long. 1. 변수 secret은 IIEF 스코프 안에서 안전하게 보호되며 외부에서 접근 할 수 없다. 2. 그렇지만 IIEF는 함수이므로 무엇이든 반환할 수 있다. 12345678910const f = (function(){ let count = 0; return function(){ return `i have been called ${++count} time(s)`; }})(); f(); //i have been called 1 time(s)f(); //i have been called 2 time(s)//... 변수 count는 IIEF안에 안전하게 보관되어 있으므로 손댈 방법이 없다. f는 자신이 몇 번 호출됐는지 정확히 알고 있다. 7.8 함수 스코프와 호이스팅 letlet으로 변수를 선언하면, 그 변수는 선언하기 전에 존재하지 않는다. varvar로 선언한 변수는 현재 스코프 안이라면 어디서든 사용할 수 있으며, 선언하기 전에도 사용할 수 있다. 아직 선언되지않은 변수의 값 == 에러를 일으킴존재하되 값이 undefined인 변수 = 에러를 일으키지 않음 1234567891011121314151617//let x; //x가 정의되지 않음 let x = 3; //에러가 실행되어 멈춰서 여기에 도달할 수 없음``` &lt;pre&gt;let을 쓰면 변수를 선언하기 전에 사용하려고 할때 에러가 난다. &lt;/pre&gt;```javascript//var x;var x = 3;x; //3x; //선언(할당은 아닌)이 끌어올려 집니다. x; //undefinedvar x = 3;x; //3 1. var로 변수를 선언하면, 선언하기 전에도 사용할 수 있다. 2. var로 선언한 변수는 끌어올린다는 뜻의 호이스팅이라는 메커니즘을 따름 3. 선언만 끌어올리지며, 할당은 끌어올리지지 않는다. 123456789101112131415161718192021222324252627282930313233343536//원래코드 if(x !==3){ console.log(y); //undefined var y = 5; if(y === 5){ var x = 3; } console.log(y); //5} if(x === 3){ console.log(y); //5} //자바스크립트가 해석한 코드 var x;var y; if(x !== 3){ console.log(y); y = 5; if (y === 5){ x = 3; } console.log(y);} if(x === 3){ console.log(y);}var x = 3;if(x === 3){ var x = 2; console.log(x); //2}console.log(x); //2 1. 같은 함수나 전역 스코프 안에서는 var로 새 변수를 만들 수 없다. 2. let으로 가능 했던 변수 숨김도 불가능 3. 그렇지만 ES5로 트랜스 컴파일 해야하므로 var의 동작을 이해해야한다. 7.9 함수 호이스팅 var로 선언된 변수와 마찬가지로, 함수 선언도 스코프 맨 위로 끌어올려진다.함수를 선언하기 전에 호출 할 수 있다. 1234f(); //\"f\"function f(){ console.log(f);} 그러나, 변수에 할당한 함수 표현식은 끌어올려지지 않는다. 1234f(); //ReferrenceError : f는 정의되지 않았습니다.let f = function(){ console.log(f);}; 7.10 사각지대 let으로 선언하는 변수는 선언하기 전까지 존재하지 않는다는 직관적 개념스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드 1234567if(typeof x ===\"undefined\"){ console.log(\"x doesn't exist or is undefined\");}else{ //x를 사용해도 안전한 코드} //결과 x doesn't exist or is undefined 해당 코드는 안전하고 에러가 발생하지 않는다. BUT, 이 코드를 let으로 바꾸면 에러가 발생 사각지대let1234567//사각지대 letif(typeof x === \"undefined\"){ console.log(\"x doesn't exist or is undefined\");}else{ //x를 사용해도 안전한 코드 }let x = 5;//Uncaught ReferenceError: Cannot access 'x' before initialization ES6에서는 typeof 연산자로 변수가 정의됐는지 확인 할 필요가 거의 없어짐 7.11 스트릭트 모드 암시적 전역변수(ES5문법) : var로 변수를 선언하는 것을 잊으면 자바스크립트는 전역 변수를 참조하려 한다고 간주하고,그런 전역변수를 스스로 생성 =&gt; 수많은 문제 생성스트릭트 모드 : 암시적 전역 변수를 허용하지 않음“use strict”를 코드 맨 앞에 씀 전역 스코프에서 스트릭트 모드를 사용하지 않는 편이 좋다 . 스트릭트모드123456(function(){ 'use strict'; //코드를 전부 이 안에서 작성합니다. //이 코드는 스트릭트 모드로 동작하지만, //이 코드와 함께 동작하는 다른 스크립트는 스트릭트 모드에 영향을 받지 않습니다.})();","link":"/2019/07/13/es6_md/chapter7/"},{"title":"chapter9. 객체와 객체지향 프로그래밍","text":"9.1 프로퍼티 나열 1) 배열은 값을 가지며 각 값에는 숫자형 인덱스가 있습니다. 객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있습니다2) 배열에는 순서가 있습니다. 반면 객체는 그런 순서가 보장되지 않습니다. 9.1.1 for…in for…in : 객체 프로퍼티를 나열할 떄 123456789101112const SYM = Symbol();const o ={a:1,b:2,c:3,[SYM]:4};for(let prop in o){ if(!o.hasOwnProperty(prop)) continue; console.log(`${prop}:${o[prop]}`)}/*a:1b:2c:3*/ hasOwnProperty : for...in에 나타날 위험을 제거하기 위해 사용 for...in 루프에는 키가 심볼인 프로퍼티는 포함 안됌 9.1.2 Object.keys 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환 12345678910// 9.1.2 Object.keysconst SYM = Symbol();const o ={a:1,b:2,c:3,[SYM]:4};Object.keys(o).forEach(prop =&gt; console.log (`${prop} :${o[prop]}`));/*a:1b:2c:3*/ hasOwnProperty를 체크할 필요가 없다. 객체의 프로퍼티 키를 배열로 가져와야 할때 Object.keys가 편리하다. 9.2 객체지향 프로그래밍 OOP) 객체 : 데이터와 기능을 논리적으로 묶은 것 클래스 : 자동차처럼 추상적이고 범용적인 것 인스턴스 : 특정 자동차처럼 구체적이고 한정적인 것 메서드 : 기능 클래스 메서드 : 클래스지만 특정 인스턴스에 묶이지 않는 기능 생성자 : 인스턴스를 처음 만들 떄 생성자가 실행됨, 객체 인스턴스를 초기화함 클래스 : 운송수단서브 클래스 : 자동차, 보트, 비행기..보트 서브 클래스 : 요트, 카누,모터보트… 9.2.1 클래스와 인스턴스 생성 ES6애서 클래스를 만드는 간편한 새 문법을 도입함 클래스만들기12345class Car{ constructor(){ }} 새 클래스 Car을 만듬, 아직 인스턴스(특정 자동차)는 안만들어짐 인스턴스만들기12const car1 = new Car();const car2 = new Car(); 인스턴스를 만들 떈 new 키워드를 사용한다 instanceof123//instanceofcar1 instanceof Car //truecar1 instanceof Bus //false instanceof : 객체가 클래스인지, 인스턴스인지 확인 car1은 Car의 인스턴스이지만, Bus의 인스턴스는 아니다. 12345678910111213141516171819202122//제조사, 모델, 변속 기능 추가class Car{ constructor(make, model){ this.make = make; this.model = model; this.userGears = ['P','N','R','D']; this.userGear = this.userGears[0]; } shift(gear){ if(this.userGears.indexOf(gear)&lt;0) throw new Error('invalid gear :' `${gear}`); this.userGear = gear }}//실제 사용const car1 = new Car('Thsla','Model S');const car2 = new Car('Mazda','3i');car1.shift('D');car2.shift('R');car1.userGear //\"R\" this : 메서드를 호출한 인스턴스를 가리키는 목적 userGears : 사용할 수 있는 기어 목록 gear : 현재 기어 사용할 수 있는 첫번째 기어로 초기화 shift : 메서드(기어변속) * 실수로 기어 프로퍼티를 고치지 않도록 어느 정도 막을 수 있다. _ : 외부에서 접근하면 안돼는 프로퍼티 이름 앞에 붙이는 가짜 접근 제한 ex)_userGears 9.2.2 클래스는 함수다. ES6에서 class 키워드를 도입하기 전까지,클래스를 만드는 것은 곧 클래스 생성자로 사용될 함수를 만든다는 의미but, class는 단축 문법일 뿐이고 자바스크립트의 클래스가 바뀐 것은 아님 es5123456function Car(make,model){ this.make = make; this.model = model; this.userGears = ['P','N','R','D']; this.userGear = this.userGears[0];} es61234class Es6Car {} //생성자는 의도적으로 생략function Es5Car {}&gt; typeof Es6Car //'function'&gt; typeof Es5Car //'function' 9.2.3 프로토타입 프로토타입 메서드: 클래스의 인스턴스에서 사용할 수 있는 메서드ex) Car.prototype.shift :Car 클래스의 인스턴스에서 사용할 수 있는 shift 메서드는 프로토타입 메서드임 최근엔 메서드를 ‘#’로 표기하기도함 ex)Car#shift 클래스는 대문자로 시작하는게 관용적임 함수의 prototype 프로퍼티가 중요한 시점은 new 키워드로 새 인스턴스를 만들때 new 키워드로 만든 새 객체는 생성자 prototype 프로퍼티에 접근가능 ‘proto‘(밑줄 2개) 프로퍼티에 저장() 동적 디스패치 : 메서드 호출 prototype123456789101112131415161718192021222324252627282930313233//9.2.3 프로토타입const Car = (function(){ const carProps = new WeakMap(); class Car{ constructor(make,model){ this.make = make; this.model = model; this._userGears = ['P','N','R','D']; carProps.set(this,{userGear:this._userGears[0]}); } get userGear(){return carProps.get(this).userGear;} set userGear(value){ if(this._userGears.indexOf(value)&lt;0) throw new Error(`${value}`); carProps.get(this).userGear = value; } shift(gear){this.userGear = gear;} } return Car;})();const car1 = new Car();const car2 = new Car();car1.shift === Car.prototype.shift; //true;car1.shift('D');car1.shift('d');//error;car1.userGear; // 'D';car1.shift === car2.shift; //true;car1.shift = function(gear) {this.userGear = gear.toUpperCase();}car1.shift === Car.prototype.shift; //false 9.2.4 정적 메서드 정적 메서드 : 클래스 메서드 특정 인스턴스에 적용되지 않음 this는 인스턴스가 아니라 클래스 자체에 묶임 클래스와 관련되지만 인스턴스와 관련없는 범용적 작업에 사용ex) 자동차 식별 번호 (VIN) 붙이기 여러 인스턴스를 대상으로 하는 작업에도 사용 정적메서드123456789101112131415161718192021222324252627282930313233//areSimilar : 두 자동차의 제조사와 모델이 같으면 true 반환 메서드//areSame : 두 자동차의 VIN이 같으면 true반환 메서드class Car{ static getNextVin(){ return Car.nextVin++; //this.nextVin++이라고 써도 되지만, // Car을 앞에 쓰면 정적 메서드라는 걸 상기 } constructor(make,model){ this.make = make; this.model = model; this.vin = Car.getNextVin(); } static areSimilar(car1,car2){ return car1.make == car2.make &amp;&amp; car1.model == car2.model; } static areSame(car1,car2){ return car1.vin === car2.vin; }}Car.nextVin = 0; //초기값const car1 = new Car(\"Tesla\",\"S\");const car2 = new Car(\"Mazda\",\"3\");const car3 = new Car(\"Mazda\",\"3\");car1.vin; //0car2.vin; //1car3.vin; //2Car.areSimilar(car1,car2);//falseCar.areSimilar(car2,car3);//trueCar.areSame(car2,car3);//falseCar.areSame(car2,car2);//true 9.2.5 상속 클래스 인스턴스는 클래스의 기능을 모두 상속한다. 프로토타입 체인 : 조건에 맞는 프로토타입을 찾을 때 까지 체인을 계속 거슬러감 프로토타입을 찾지 못하면 에러를 일으킴 123456789101112131415161718192021222324252627282930313233343536//프로토타입 체인/*deployAirbags */class Vehicle { constructor(){ this.passengers = []; console.log(\"Vehicle created\"); } addPassenger(p){ this.passengers.push(p); }}class Car extends Vehicle{ constructor(){ super(); console.log(\"Car created\"); } deployAirbags(){ console.log(\"BWOOSH\"); }}const v = new Vehicle(); v.addPassenger(\"Frank\");v.addPassenger(\"Judy\");v.passengers; // [\"Frank\",\"Judy\"];const c = new Car();c.addPassenger(\"Alice\");c.addPassenger(\"Cameron\");c.passengers; //[\"Alice\",\"Cameron\"]v.deployAirbags(); //errorc.deployAirbags(); //console.log(\"BWOOSH\"); extends : Car를 Vehicle의 서브 클래스로 만듬 super() : 슈퍼클래스의 생성자 호출, 서브클래스에서는 이 함수를 반드시 호출 c 에서는 deployAirbags 호출 가능, v 에서는 error 서브클래스는 슈퍼클래스의 모든 메서드에 접근 가능 / 반대는 불가 9.2.6 다형성 다형성 : 여러 슈퍼클러스의 맴버인 인스턴스instanceOf 연산자: 객체가 클래스의 인스턴스인지 확인 다형성123456789//다형성// Vehicle : 슈퍼클래스 // Motorcycle 와 Car는 Vehicle의 서브클래스임 class Motorcycle extends Vehicle{};const c = new Car();const m = new Motorcycle();c instanceof Car; //truec instanceof Vehicle; //truem instanceof Car //false 자바스크립트의 모든 객체는 루트 클래스인 Object의 인스턴스이다 9.2.7 객체 프로퍼티 나열 다시 보기1234567891011121314151617181920212223242526272829//class Super{ constructor(){ this.name = 'Super'; this.isSuper = true; }}//유효하지만 권장xSuper.prototype.sneaky = 'not recommended';class Sub extends Super{ constructor(){ super();//서브클래스는 써줘야함 this.name = 'Sub'; this.isSub = true; }}const obj = new Sub(); for(let p in obj){ console.log(`${p} : ${obj[p]}`+ (obj.hasOwnProperty(p)? '': '(inherited)'));}/*name : SubisSuper : trueisSub : truesneaky : not recommended(inherited) */ 9.2.8 문자열 표현 toString : 객채의 기본적인 문자열 표현을 제공 9.3 다중 상속, 믹스인, 인터페이스 다중 상속 : 클래스가 슈퍼 클래스 두 개를 가지는 기능, 충돌 위험 존재인터페이스 : 다중 상속을 지원하지 않는 언어의 경우 인터페이스를 도입믹스인 : 기능을 필요한 만큼 섞은 것Symbol() : 심볼은 고유하므로, 다른 슈퍼클래스의 기능과 충돌할 가능성이 없다.","link":"/2019/07/22/es6_md/chapter9/"},{"title":"ES6 Summary 1 - 변수와 스코프","text":"ES6 공부를 한 지 시간이 좀 지났다.. 그리고 요즘은 SCSS, React 위주의 공부를 하다보니 내가 ES6 공부를 했었던가 하는 기억조차 가물가물해지는거 같다.원래 공부란게 하나 공부하고 뒤돌으면 까먹고.. 최근 너무 모르는거 같아 ES6 문법을 다시 읽고 있긴 한데 정리가 안돼는거 같다.각설하고..ES6공부를 완벽하게 숙지는 못하더라도 중요 개념 정도는 집고 넘어갸아겠다는 생각이 들어서 정리를 시작하게 되었다. ES6? ECMA2015 ? ECMAScript is a standard script language즉 자바스크립트 언어의 표준을 의미한다. ECMAScript 6 는 2015년 6월에 업데이트 되었다고 한다. ECMAScript의 6번째 에디션이 ES6이자 ECMA2015인 셈이다. ES6가 뜨는 이유는 ES5에서 제공하지 않던 다양한 기능들을 제공하기 때문인데, 아쉽게도 모든 브라우저에서 ES6의 기능을 제공하지 못한다. ES6 호환성https://kangax.github.io/compat-table/es6/ 각 브라우저마다 ES6 를 지원하는지에 대해 정리해놓은 사이트이다.구글 Chrome 기준으로, current brower 위에 98%, 즉 대부분의 ES6기능이 크롬에서 지원 가능하다고 나온다. 반대로 IE 11은 지원 안돼는 기능들이 거의 대부분이고, Edge는 상당부분 지원가능하다고 나온다. 반면, ES5 탭을 클릭해서 들어가면 브라우저에서 거의 대부분의 ES5 기능이 지원되는 것을 알 수 있다. 보통 그래서 ES6로 개발하고 Babel을 통해 ES5로 변환해서 올리는 방식을 많이 쓴다. babel babel 공식 사이트 : https://babeljs.io/바벨(Babel)은 ECMAScript 2015 이상의 코드를 이전 버전과 호환되는 JavaScript 버전으로 변환하는 데 주로 사용되는 무료 오픈 소스 JavaScript 컴파일러이다. 쉽게 말해 es6 코드를 es5로 변환해주는 도구이다.babel은 react에서도 create react-app 통해 react를 설치하면 자동으로 들어가 있기도 하다. 위의 babel 사이트를 들어가서 es6 문법 중 하나인 화살표 함수(arrow)를 입력하면 다음과 같이 변환해준다. babel을 사용해서 es6 변환123456789//es6const plus = (x) =&gt; { return x + x;}//es5var plus = function plus(x){ return x + x;} babel 설치는 babel 설치하기를 가면 알 수 있다. 본격적으로 ES6의 제공 문법에 대해서 알아보자 var와 스코프(scope)ES6 이전에 자바스크립트에서 변수를 선언할 수 있는 방법은 var를 사용하는 것이였다. var 키워드는 다른 언어와 다르게 몇 가지 특징이 있다. var의 특징 var는 함수 레벨 스코프를 따른다. var 키워드는 생략이 가능하다. 변수 중복 선언을 허용한다. 변수 호이스팅이 발생한다. var는 함수 레벨 스코프를 따른다. 스코프란 시야, 범위라는 뜻인데, 변수와 상수, 매개변수가 언제 어디서 정의되는지를 결정하는 유효범위를 가리킨다.자바스크립트는 다른 프로그래밍 언어가 블록 레벨 스코프를 따르는 것과 달리 함수 레벨 스코프를 따른다는 점에서 차이가 있다. c언어 블록 레벨 스코프123456789101112// 참고 : https://poiemaweb.com/js-scopeint main(void) { // block-level scope if (1) { int x = 5; printf(\"x = %d\\n\", x); } printf(\"x = %d\\n\", x); // use of undeclared identifier 'x' return 0;} 위의 코드를 보면 if 문 내에서 선언된 변수 x는 if문 코드 블록 내에서만 유효하고, if 문 밖에서는 참조가 불가능하므로 에러를 발생시킨다.그러나 자바스크립트는 함수 레벨 스코프를 따른다. 그렇기에 다음과 같은 상황이 발생하게 된다. javascript var의 함수 레벨 스코프123456var x = 1; //전역 변수{ var x = 2; //전역 변수가됨 console.log(x); //2 }console.log(x); //2 얼핏 보면 블록 스코프 밖에 있는 x는 1을 찍어낼 거 같지만 var는 함수레벨 스코프를 따르기 때문에 코드 블록 내의 x는 전역 변수가 된다.그런데 이미 var x = 1이라는 전역변수가 있기 때문에, var에서는 변수 중복 선언이 가능하므로 별 문제 없이 x의 값을 재할당하여 새로운 값 2로 덮어쓰게 된다. 이러한 문제는 예상치 못한 에러를 종종 발생시켰고 , ES6는 이러한 var 키워드의 단점을 보완하기 위해 let과 const 키워드를 도입하였다. let, const의 스코프(scope)let과 const는 블록 레벨 스코프를 따른다.위의 코드를 let으로 바꾸면 다음과 같은 결과가 나온다. javascript let의 블록 레벨 스코프123456789let x = 1; //전역 변수{ let x = 2; //지역 변수가됨 let y = 3; console.log(x); //2 }console.log(x); //1console.log(y); //ReferenceError: y is not defined 코드 블록({}) 내에 선언된 x는 블록 레벨 스코프를 가지며 그 블록 내에서만 사용가능한 지역변수이다. 따라서 블록 밖에 let x 와는 다른 별개의 변수이다. 또한, 코드 블록 내의 y 역시 블록 내에서만 사용 가능한 지역 변수이므로 블록 밖, 즉 외부에서 이를 참조할 수 없다. 그러므로 외부에서 이를 참조하려고 하면 참조에러(ReferenceError)를 발생시키게 된다. 스코프의 종류정적 스코프와 동적 스코프 자바스크립트는 정적 스코프를 따른다. 12345678910111213var x = 1;function foo() { var x = 10; bar();}function bar() { console.log(x);}foo(); // ?bar(); // ? 위 실행 결과는 함수 bar()의 상위 스코프가 무엇인지에 따라 값이 다르게 나온다.첫 번째는 함수를 어디서 호출하는지에 따라 스코프가 결정되는 방식인, 동적 스코프이고, 두 번째는 함수를 어디서 선언했는지에 따라 값이 다르게 나오는 정적 스코프이다. 자바스크립트는 정적 스코프(렉시컬 스코프)이다. 즉 함수가 어디서 선언되었는지가 중요하지, 어디서 호출했는지는 중요하지 않다. 따라서 위의 예제를 보면 함수 bar()는 전역변수 var x = 1의 값을 참조하게 된다. 설사 foo() 함수 안에서 호출되었다고 해도 스코프 결정에 별 영향을 주지 못하므로 bar()를 두 번 호출한 것과 같은 결과인 1을 두 번 출력하게 된다. 이러한 정적 스코프는 전역 스코프, 블록 스코프 , 함수 스코프에 적용된다. 전역 스코프 전역에 변수를 선언하면 이 변수는 어디서든지 참조할 수 있는 전역 스코프를 갖는 전역 변수가 된다 1234567let name = \"lee\";function hello(){ console.log(`${name} 님 안녕하세요!`);}hello(); // lee 님 안녕하세요! 위의 name은 전역 스코프를 갖는 전역 변수이다. 이 변수는 어디서든지 참조가 가능하게 된다. 자바스크립트는 다른 언어와 달리 특별한 시작점 없이 전역 변수 선언이 가능하다. 이런 편리함때문에 전역 변수를 남발하게 되면 변수 이름이 중복되게 되고, 변수가 중복되면 값이 재할당이 되므로 의도치 않은 문제를 발생시킬 수 있다. 이러한 문제를 해결하기 위해서는 전역 스코프에 가면 확인 할 수 있다. 지역 스코프 코드의 특정 부분에서만 사용할 수 있는 변수는 지역 스코프에 있다고 할 수 있다. 함수 내부에서 선언한 변수나 , 코드 블록내에서 let,const로 선언한 변수는 외부에서 참조할 수 없으므로 지역 변수가 된다. 함수 스코프 함수 내부에서 변수를 선언하면 그 변수는 함수 내부에서만 접근이 가능한 함수 스코프를 가진다. 블록 스코프 블록의 스코프안에서만 보이는 식별자를 말한다. let,const는 식별자를 블록 스코프에서 선언한다. 이러한 블록 스코프를 중첩해서 변수 숨기기가 가능하다. 12345678910111213141516//스코프 중첩 { //외부블록 let x = 'blue'; console.log(x) ; //\"blue\" { //내부블록 let x = 3; console.log(x); // \"3\" } console.log(x); //\"blue\" } console.log(typeof x); //undefined ; x는 스코프에 있지 않습니다. . 위 코드를 보면 외부 블록 x와 내부 블록 x는 이름만 같지 다른 지역변수이다.그러므로 내부 블록에서는 마치 외부 스코프 x를 가리는 것과 같은 효과를 발휘하게 된다.이러한 것을 변수 숨기기 라고 한다. var / let / const1) var : 함수 레벨 스코프 / let,const : 블록 레벨 스코프2) 중복 선언 여부var로는 동일한 이름을 갖는 변수를 중복해서 선언이 가능했지만,let과 const로는 으로는 중복 선언이 불가능하다. 123456789101112//varvar a = 1;var a = 2; console.log(a); //2; 값이 재 할당됨//letlet b = 1;let b = 2; //Identifier 'b' has already been declared//constconst c = 1;const c = 2; //Identifier 'c' has already been declared 3) 호이스팅 자바스크립트는 ES6에서 도입된 let,const를 포함하여 모든 선언(var, function,class..)등을 호이스팅한다.호이스팅이란 ? : var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성을 말한다. 먼저 알아야할 것은 변수는 3단계에 거쳐 생성된다는 것이다. 선언: 변수를 실행 컨텍스트의 변수 객체(Variable Object)에 등록한다. 이 변수 객체는 스코프가 참조하는 대상이 된다. 초기화: 변수를 위한 공간을 메모리에 확보한다. 이 단계에서 변수는 undefined로 초기화된다. 할당: undefined로 초기화된 변수에 실제 값을 할당한다. varvar로 선언된 변수는 선언과 초기화가 한번에 이루워진다. 즉 스코프에 변수를 선언(등록)하자마자 그 변수를 위한 공간을 메모리에 확보(초기화)가 동시에 발생한다.단, 아직 변수에 값을 할당하지 않았으므로 undefined를 반환한다. 변수값을 할당하는 문에 도달해서야 비로소 할당 단계가 완료된다. var의 호이스팅123456789// var 변수는 스코프의 가장 선두로 호이스팅되고 선언 단계와 초기화 단계가 실행된다.//선언,초기화 동시진행 console.log(a); //undefined var a; //변수 선언문console.log(a); // undefineda = 2; //할당console.log(a); //2 letlet으로 선언된 변수는 선언과 초기화가 분리되어 진행된다. 즉 스코프를 변수에 선언(등록)은 하지만, 초기화 단계는 그 변수에 도달했을 때 이뤄진다. 그러므로 초기화 이전에 변수를 참조하려고 하면 참조에러(ReferenceError)가 발생한다.이렇게되면 변수가 선언되고 초기화 되기 전까지는 그 변수를 참조할 수 없게 되는 구간이 생기는데 이를 일시적 사각지대(Temporal Dead Zone; TDZ)라고 부른다. let의 호이스팅123456789//let 변수는 스코프의 선두에서 선언이 실행된다.(호이스팅)//단 초기화는 그 변수의 선언문에서 실행된다. console.log(b);// ReferenceError: b is not definedlet b; //변수 선언문, 초기화 단계 실행 console.log(b); // undefined (선언, 초기화 완료, 값 아직 미할당)b = 1;// 할당console.log(b); // 1 많은 사람들이 이 코드를 보면 let이 호이스팅이 발생하지 않는것 아니냐고 생각하곤 한다.그러나 그것이 아니고 var은 선언과 초기화가 동시에 호이스팅 되는 것이고, let은 선언만 스코프 선두로 올라가는 호이스팅이 된다고 생각하면 될 것 같다. let과 const let은 변할 수 있는 값을 위해, const는 변하지 않는 값(상수)를 위해 사용한다.const는 let과 거의 비슷하나 몇 가지 차이가 있다. 선언과 할당 let은 재할당이 자유로우나 const는 선언과 동시에 반드시 할당이 되어야 하며 재할당이 금지된다. 12345678910//letlet a; //undefineda = 2; console.log(a); //2 //const const b; // Missing initializer in const declaration (선언과 할당을 같이 하라)const c = 1;c = 2; // Assignment to constant variable.(재할당 금지) const의 객체의 내용 변경 const는 재할당 자체는 불가능하지만, 할당된 객체의 내용을 추가, 삭제, 프로퍼티 값 변경 등은 가능하다. 123const a = {name : \"somoong\"};a.name = \"jinmoong\";console.log(a); // {name: \"jinmoong\"} 객체의 프로퍼티 값 변경 가능 NEXT : 자바스크립트의 클로저 참고 링크 let, const와 블록 레벨 스코프 : https://poiemaweb.com/es6-block-scope 자바스크립트의 변수범위와 호이스팅 : http://chanlee.github.io/2013/12/10/javascript-variable-scope-and-hoisting/ let과 const는 호이스팅 될까? : https://medium.com/korbit-engineering/let%EA%B3%BC-const%EB%8A%94-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EB%90%A0%EA%B9%8C-72fcf2fac365","link":"/2019/11/02/es6_md/es6_summary_1/"},{"title":"hexo icarus 테마 설치 및 커스텀하기","text":"hexo 테마 중 하나인 icarus 테마를 설치하고 커스텀하는 방법을 알아본다. 블로그를 만들고, hexo 테마 중 icarus 테마를 적용하면서 장단점을 각각 느끼게 되었는데, 설치 방법과 커스텀 방법에 대해 알아보도록 하겠다. hexo 테마 고르기https://hexo.io/themes/로 들어가면 hexo 블로그 테마가 다양하게 들어가 있는 것을 볼 수 있다.그 중 icarus 테마를 결정했는데 결정 기준은 디자인이 이뻐야한다. javascript, react 등의 코드를 많이 올릴것이므로 코드를 보여줄 수 있는 공간이 있고, 보기 편해야한다. (코드 복사도 된다면 굿) 이미지 클릭 시 크게 보이는 silder가 있었으면 좋을거 같다. 였고, 이 세가지 기준을 icarus 테마가 만족시켰기에 결정하게 되었다. icarus icarus 테마 설치git bash에서 hexo 블로그가 설치된 경로로 들어가서, icarus 테마를 설치한다. icarus 테마 github 주소 : https://github.com/ppoffice/hexo-theme-icarus 12cd bloggit clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 이렇게하면 themes 폴더 안에 icarus 테마 폴더가 다운로드 된다. 테마 설정루트폴더의 _config.yml으로 들어가서 테마 설정을 바꾼다. 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus //테마를 icarus로 설정 icaurs 테마 불편한 점 개선하기icarus 테마를 다운받으면서 느낀 불편한 점은 다음과 같다. 글 쓰는 공간이 작아 자꾸 가로 스크롤이 생긴다. 무슨 말인고 하니 다음을 들어가보면 알겠지만, 좌우 공간에 무언가 너무 많아? 코드가 조금만 길어지면 금방 스크롤이 생긴다는 것이다. https://blog.zhangruipeng.me/hexo-theme-icarus/uncategorized/getting-started-with-icarus/ 이 문제는 다음과 같이 2가지 절차를 거쳐 개선하게 되었다. 1. md파일 상단에 포스팅 설정 넣기파일 상단에 정보넣기1234567891011121314151617181920---title: 글제목date: 2019-10-20tags:categories: - 카테고리명/* 옵션 넣기 */ toc: truewidgets: - type: toc position: right - type: category position: right - type: tagcloud position: rightsidebar: right: sticky: true--- 이렇게 md 파일 상단에 정보를 넣게되면 왼쪽에 있는 내용들이 날라가게되면서 포스팅 부분이 넓어지게 된다. 포스팅 설정 넣기 전 포스팅 설정 넣은 후 layout과 widget의 크기 개선하다보니 저 설정 넣은 후에도 불만이 하나 있었는데,좌우 여백이 더 좁아서 포스팅하는 하얀색 블럭?의 크기가 더 커도 될거 같다는 거였다. 어찌할까 하다가 다음과 같은 3가지 절차로 해결했다. 1) layout.ejs 개선themes/icarus/layout/layout.ejs 경로로 들어가서 ejs 파일을 약간 수정해주었다. layout.ejs는 말 대로 글쓰는 부분의 layout인데저 is-8-tablet is-8-desktop is-8-widescreen이 마치 부트스트랩의 col같은 느낌이 들어 저기 숫자를 증가시켜 줌으로써 layout의 크기를 넓혔다. layout.ejs123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html &lt;%- has_config('language') ? ' lang=\"' + get_config('language').substring(0, 2) + '\"' : '' %&gt;&gt;&lt;head&gt; &lt;%- partial('common/head') %&gt;&lt;/head&gt;&lt;body class=\"is-&lt;%= column_count() %&gt;-column\"&gt; &lt;%- partial('common/navbar', { page }) %&gt; &lt;% function main_column_class() { switch (column_count()) { case 1: return 'is-12'; case 2: //기존 코드 : return 'is-8-tablet is-8-desktop is-8-widescreen'; return 'is-12-tablet is-8-desktop is-9-widescreen'; case 3: return 'is-8-tablet is-8-desktop is-6-widescreen' } return ''; } %&gt; &lt;section class=\"section\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"columns\"&gt; &lt;div class=\"column &lt;%= main_column_class() %&gt; has-order-2 column-main\"&gt;&lt;%- body %&gt;&lt;/div&gt; &lt;%- partial('common/widget', { position: 'left' }) %&gt; &lt;%- partial('common/widget', { position: 'right' }) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; &lt;%- partial('common/footer') %&gt; &lt;%- partial('common/scripts') %&gt; &lt;% if (has_config('search.type')) { %&gt; &lt;%- partial('search/' + get_config('search.type')) %&gt; &lt;% } %&gt;&lt;/body&gt;&lt;/html&gt; 2) widget.ejs 수정themes/icarus/layout/common/widget.ejs 경로로 들어가서 ejs 파일을 약간 수정해주었다. widget.ejs는 오른쪽에 붙어있는 위젯의 크기를 조절해주는 부분인것 같아 마찬가지로 수정해주었다. widjet.ejs12345678910111213141516171819202122232425262728293031323334353637&lt;% if (get_widgets(position).length) { %&gt;&lt;% function side_column_class() { switch (column_count()) { case 2: //기존 코드 : return 'is-4-tablet is-4-desktop is-4-widescreen'; return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } return ''; } %&gt;&lt;% function visibility_class() { if (column_count() === 3 &amp;&amp; position === 'right') { return 'is-hidden-touch is-hidden-desktop-only'; } return ''; } %&gt;&lt;% function order_class() { return position === 'left' ? 'has-order-1' : 'has-order-3'; } %&gt;&lt;% function sticky_class(position) { return get_config('sidebar.' + position + '.sticky', false) ? 'is-sticky' : ''; } %&gt;&lt;div class=\"column &lt;%= side_column_class() %&gt; &lt;%= visibility_class() %&gt; &lt;%= order_class() %&gt; column-&lt;%= position %&gt; &lt;%= sticky_class(position) %&gt;\"&gt; &lt;% get_widgets(position).forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;% if (position === 'left') { %&gt; &lt;div class=\"column-right-shadow is-hidden-widescreen &lt;%= sticky_class('right') %&gt;\"&gt; &lt;% get_widgets('right').forEach(widget =&gt; {%&gt; &lt;%- partial('widget/' + widget.type, { widget, post: page }) %&gt; &lt;% }) %&gt; &lt;/div&gt; &lt;% } %&gt;&lt;/div&gt;&lt;% } %&gt; 3) style.styl 수정style.styl 폴더에서 screen-widescreen부분과 screen-fullhd 부분의 max-width 값을 지정해줘서 전체 크기를 늘려주었다. 저 /* custom */부분이 내가 새로 넣은 값이다. style.styl1234567891011121314151617181920212223242526272829303132333435363738394041424344family-sans = \"Ubuntu\", \"Roboto\", \"Open Sans\", \"Microsoft YaHei\", sans-seriffamily-mono = \"Source Code Pro\", monospace, \"Microsoft YaHei\"gap = 64pxscreen-tablet = 769pxscreen-desktop = 1088pxscreen-widescreen = 1280pxscreen-fullhd = 1472px/* --------------------------------- * Override CSS Framework * --------------------------------- */html font-size: 14pxbody background-color: #f7f7f7body, button, input, select, textarea font-family: family-sans@media screen and (min-width: screen-widescreen) .is-1-column .container .is-2-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap /*custom*/ max-width:1100px; width:100%;@media screen and (min-width: screen-fullhd) .is-2-column .container max-width: screen-widescreen - 2 * gap width: screen-widescreen - 2 * gap /*custom*/ max-width:1250px; width:100%; .is-1-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap /*custom*/ max-width:1250px; width:100%;(...중략...) 결과","link":"/2019/10/21/hexo_md/hexo2/"},{"title":"SCSS의 문법  nesting, mixin, extend , partial","text":"SCSS의 여러 문법들에 대해 알아본다nesting, media query 사용하기, mixin, extends 등등을 살펴본다. css Preprocessor (전처리기) SASS, SCSS, Less .. 이 들은 css 전(예비)처리기이다.즉 css 동작 전에 사용하는 기능인데 css가 주지 못하는 불편한 과정들을 이들이 도와주게 된다.웹에서는 오직 css만 동작하므로, 보통 전처리기로 작성한 뒤, 이 파일을 css로 컴파일하는 과정을 거치게 된다. SASS vs SCSS SASSSASS : SCSS를 작성하는데 있어서 구조적 차이가 있고 작성이 번거롭고 복잡할 수 있다.SCSS : 기존 CSS와 유사하게 작성할 수 있어 친근하게 느껴져 배우기 쉽다. 가장 큰 차이는 {}, ; 에서 나타난다. sass12345//sass.box width:100px a color:red scss1234567//scss.box{ width:100px; a{ color:red; }} sass는 들여쓰기로 범위를 구분하고 ;을 쓰지 않는다.scss는 {}로 적용 범위를 구분하고 ;을 쓴다. css와 거의 유사한 형태이다. SCSS 에서 변수 사용하기 $로 시작해야하고$bk123-_ (영어,숫자,대시,언더스코어)가 들어갈 수 있다. 12345678$red: #f53535;$yellow: #f2fa1a;.box{ width:50px; height:50px; background-color: $red; //background-color:#f53535;} scss 문법 공부를 하기에 앞서 예제링크를 들어가 html과 css 파일을 받는다. : https://codepen.io/blueweber/pen/WzvWPp basic.html 예제코드html12345678&lt;div id=\"box1\"&gt; box1&lt;br&gt; &lt;a href=\"#\"&gt;button1&lt;/a&gt; &lt;div id=\"box2\"&gt; box2&lt;br&gt; &lt;a href=\"#\"&gt;button2&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; basic.css 예제코드css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960html { font-size: 18px; }body { margin: 20px; background-color: #fff4ef;}div { color: #333; padding: 20px;}a { display: inline-block; margin: 10px 0;}#box1 { font-size: 40px; background-color: #ffcccc; border-radius: 20px; border: 3px solid #f00; box-shadow: 0px 3px 11px 0px rgba(0, 0, 0, 0.75);}#box1 &gt; a { color: #a22; text-decoration: none;}#box1 &gt; a:hover { color: #000; text-decoration: underline;}#box1:hover { background-color: #ccc;}#box1 #box2 { font-size: 20px; background-color: #e9e9e9; border-radius: 20px; border: 3px solid #f00; box-shadow: 0px 3px 11px 0px rgba(0, 0, 0, 0.75);}#box1 #box2 &gt; a { color: #ee6633; text-decoration: none;}#box1 #box2 &gt; a:hover { color: #a22; text-decoration: underline;} 본격적으로 SCSS 문법을 들어가보자. nesting Nesting은 SCSS의 유용한 확장 기능으로 선언을 중첩(Nesting)하는 것이다.HTML과 같은 방식으로 CSS 선택자를 중첩할 수 있다.‘&amp;’는 자기자신(상위선택자)를 가리킨다. basic.css123456789101112131415161718192021222324/* 기존 css 코드 */#box1 { font-size: 40px; background-color: #ffcccc; border-radius: 20px; border: 3px solid #f00; box-shadow: 0px 3px 11px 0px rgba(0, 0, 0, 0.75);}#box1:hover { background-color: #ccc;}#box1 &gt; a { color: #a22; text-decoration: none;}#box1 &gt; a:hover { color: #000; text-decoration: underline;}(...) basic.scss12345678910111213141516171819202122232425/* nesting된 코드 */#box1{ font-size: 40px; background-color: #ffcccc; border-radius: 20px; border: 3px solid #f00; box-shadow: 0px 3px 11px 0px rgba(0, 0, 0, 0.75); //여기서 &amp;는 #box1태그를 가리킨다 #box1 &amp;:hover{ color: #000; text-decoration: underline; } &amp; &gt; a{ color: #a22; text-decoration: none; //여기서 &amp;는 a태그를 가리킨다 #box1 &gt; a &amp;:hover{ color: #000; text-decoration: underline; } }}(...) 너무 많은 중첩은 오히려 코드의 혼란을 가져오므로 (마치 콜백지옥같은 모양새) 상황에 맞게 사용하도록 한다. nesting에서 media query(미디어쿼리) 사용하기미디어 쿼리란 Responsive Web(반응형웹)을 구현하는 CSS 기술로 특정조건(주로 width)에 따라 css를 다르게 줄 수 있게 하는 것이다. scss 에서 미디어쿼리 사용법은 기존 css 미디어쿼리 사용하는 방식이랑 거의 비슷하다. nesting 문법을 사용해서 작성한다. media query12345678910111213#box1 { &amp;:hover { background-color: #ccc; } //미디어 쿼리 작성 @media screen and (max-with: 500px) { font-size: 20px; } @media screen and(min-width: 501px) and (max-width: 980px) { font-size: 50px; }} mixin 믹스인은 비슷한 코드를 여러번 사용해야할 때 사용한다.mixin을 선언 할때는 @mixin을 사용하며, 적용할때는 @include로 불러온다.@mixin mixin명(mixin내부에서 사용할 변수){ …} @include mixin명(값); mixin123456789101112131415161718192021222324//변수 앞에 $를 붙인다.//$fontSize, $bgColor는 오직 이 믹스인 안에서만 사용되는 변수이다.@mixin fontSizeBgColor($fontSize, $bgColor) { font-size: $fontSize; background-color: $bgColor;}#box1{ /*위 코드는 font-size: 40px; background-color: #ffcccc; 와 완전히 같습니다. */ @include fontSizeBgColor(40px, #ffcccc);}#box1 #box2{ /*위 코드는 font-size: 20px; background-color: #e9e9e9; 와 완전히 같습니다. */ @include fontSizeBgColor(20px, #e9e9e9);} extend 완전히 똑같은 코드를 하나로 묶어서 재사용할 때 사용한다.extend를 선언할 땐 : %extend명{속성값}extend를 불러올 땐 : @extend %extend명 extend12345678910111213%boxShape { border-radius: 20px; border: 3px solid #f00; box-shadow: 0px 3px 11px 0px rgba(0, 0, 0, 0.75);}#box1{ @extend %boxShape;}#box1 #box2{ @extend %boxShape;} 이렇게 extend를 작성하면… extend123456#box1, #box1 #box2 { border-radius: 20px; border: 3px solid #f00; -webkit-box-shadow: 0px 3px 11px 0px rgba(0, 0, 0, 0.75); box-shadow: 0px 3px 11px 0px rgba(0, 0, 0, 0.75);} css에서 이런식으로 변환이 되게 된다. partial 공용 스타일을 범용으로 하나의 파일로 묶고, 이를 여러 sass 파일에 가져다쓸때 partial을 사용한다.예를 들어, mixin으로 만든 코드를 여러 scss 파일에서 재 사용해야할때, 그때마다 mixin을 새로만드는것이 아니라_mixins.scss 식으로 파일을 만들어 범용 코드를 넣어놓고, 그 파일을 import 해 불러오는 식으로 사용한다. 예제를 위해, scss폴더 안에 partial 라는 폴더를 만들어보자현재 폴더구조는 이렇다. partial 폴더 안에 _mixins.scss 파일을 생성하고 아까 만든 mixin 변수를 넣어준다.앞에 _(언더스코어)를 붙이는 이유는 컴파일을 하지말라는 의미인데이 _mixin.scss는 watiching sass를 시작해도 _mixins.css로 컴파일 되지 않는다.어차피 이 파일을 다른 scss 파일에서 가져다 쓰기 때문에 컴파일 할 필요가 없기 때문이다.이 규칙은 scss 뿐만이 아니라 다른 언어에서도 비슷하게 적용된다. partial 파일을 가져올때는@import “파일명”식으로 가져온다. 단, 앞의 언더스코어(_)와 뒤의 확장자(.scss)를 붙이지 않는다 _mixins.scss12345//기존 basic.scss에서 mixin 부분을 가져와서 복붙한다.@mixin fontSizeBgColor($fontSize, $bgColor) { font-size: $fontSize; background-color: $bgColor;} basic.scss123456789101112//_mixin.scss을 import 한다.//기존에 적용되었던 mixin 내용을 날린다.@import \"mixins\";#box1{ //똑같이 mixin 내용이 적용이 된다. @include fontSizeBgColor(40px, #ffcccc);}#box1 #box2{ @include fontSizeBgColor(20px, #e9e9e9);} 확장 호스트가 예기치 않게 종료되었습니다 가끔 partial파일을 import를 할 때, 스펠링등을 잘못쳐셔 실수로 없는 파일을 import 하는 경우가 있는데..이럴경우 자꾸 vscode에서확장 호스트가 예기치 않게 종료되었습니다 또는extension host terminated unexpectedly식의 에러를 발생시키게 된다..그리고 자꾸 vscode가 튕기게 되고 watiching sass가 안켜지는 이상한 문제가 지속적으로 발생됐다. 어제 한참 고생했는데결론부터 말하자면 color Highlight 확장때문에 발생한 문제였다. 왠지 모르겠지만 저 확장이랑 무언가 충돌이 나는듯하다.color Highlight 확장을 사용안함으로 설정하고 다시 로드하면 더이상 에러를 발생시키지 않는다.그리고 저거랑 비슷한 역할을 하는 colorize라는 확장이 있다..저걸 설치하니 문제 해결..ㅠㅠ 어제 저거때문에 공부도 못하고 구글링 엄청 했는데오늘 내가 유료로 듣는 인프런 강사님께서 해결책을 알려주셨다…허무허무..ㅠㅠ 결론: 강의를 끝까지 듣자.. scss의 if 문 사용하기 scss에서도 if문을 사용할 수 있다.예를들어, mixin 변수에 따른 다른 스타일 효과를 주고 싶을때 다음과 같이 사용할 수 있다. if.scss1234567891011121314151617181920212223242526272829303132333435363738//mixin 생성@mixin textAndBgColor($textColor, $bgColor) { color: $textColor; background-color: $bgColor;}//분위기에 따른 테마같이 스타일을 나눠서 효과를 주고 싶을 떄 //theme mixin 생성@mixin theme($mood) { //$mood 변수가 \"light\"란 글자와 같다면 @if $mood == \"light\" { //이 mixin 효과를 주겠다.(이중 mixin) @include textAndBgColor(#333, #ff0); } //else if @else if $mood == \"dark\" { @include textAndBgColor(#fff, #333); } //else @else { @include textAndBgColor(#f00, #aaa); }}#box1 { //theme mixin 불러오기 @include theme(\"light\");}#box2 { @include theme(\"dark\");}#box3 { @include theme(\"noraml\");} scss 작성 후 watching sass를 켜놓은 상태라면 css가 다음과 같이 컴파일 된다. if.css12345678910111213141516171819body { margin: 50px;}#box1 { color: #333; background-color: #ff0;}#box2 { color: #fff; background-color: #333;}#box3 { color: #f00; background-color: #aaa;}/*# sourceMappingURL=if.css.map */ if.html123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"css/if.css\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"box1\"&gt;box1&lt;/div&gt; &lt;div id=\"box2\"&gt;box2&lt;/div&gt; &lt;div id=\"box3\"&gt;box3&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 이 css 파일을 html에 적용시킨 결과","link":"/2019/10/10/scss_md/sass2/"},{"title":"typescript chapter4. 제어문","text":"조건문if if문은 조건이 참인지 거짓인지를 판단하고 분기를 수행한다. 이때 if문에 지정하는 조건은 참과 거짓을 판단할 수 있는 boolean 타입이여야한다. 1234567891011121314151617let text: string = \"\";let statusActive: number = 0;let isEnabeld: boolean = true;// 첫 번째 if문if (statusActive || text) { console.log(\"1\");}// 두 번째 if문if (isEnabeld &amp;&amp; 2 &gt; 1) { console.log(\"2\");}// 실행 결과 2 statusActive 변수는 숫자타입인데 숫자가 0이면 false 이고, 0이 아닌 나머지는 true이다.text 변수는 문자열 타입인데, 빈 값일 때 false이고, 값이 있으면 true이다. 첫번째 if문은 둘다 false 이므로 if문이 실행되지 못한다. switch switch 문은 비교 대상이 많을 때 단순한 형태로 비교를 수행하기 위해 사용한다.break 문을 통해 switch문을 벗어날 수 있어야 하고 , case 절에 부합하지 않는 예외조건을 처리 하기 위해 default 절을 추가할 수도 있다.switch의 표현식에는 변수가 올 수 있고, 표현식의 값과 일치하는 case 절이 실행된다. 1234567891011let command: number = 0;switch (command) { case 0: console.log(\"0\"); break; case 1: console.log(\"1\"); break;}// 0 위 예제에서 switch문의 조건은 number 타입이므로 case 절의 값은 모두 number 타입이여야한다.case 절의 값 타입이 정해져 있지 않은 경우에는 다음과 같다. 123456789101112let command2: any = \"hi\";switch (command2) { case \"hi\": console.log(\"hi\"); break; case 0: console.log(0); break;}// 'hi' fall-through switch에서 break문을 생략하면 다음 case 절이 실행되는 폴스루(fall-through)가 일어날수 있다.case문 내의 break 문이 없어 case 문이 종료되지 않고 다음 case 문이 이어져 실행되는 현상을 말한다. break 문이 누락되어 폴스루가 발생함1234567891011let input = 2;switch (input % 2) { case 0: console.log(\"0\"); case 1: console.log(\"1\"); break;}// 0// 1 case 0 절에 break문이 누락되어 폴스루가 발생해 case 1절이 자동으로 실행됨타입스크립트의 폴스루 사용 여부를 설정하고 싶으면 tsc 컴파일러 옵션인 nofallthroughcasesinswitch를 수정하면 된다. tsconfig.json 폴스루 방지12345678910//{ \"compilerOptions\" :{ \"nofallthroughcasesinswitch: true }}// 또는 cmd에서 컴파일 시 컴파일할 ts 파일에 --nofallthroughcasesinswitch를 붙이면 폴스루시 에러를 뱉어냄tsc switch-fallthrough-case.ts --nofallthroughcasesinswitch// switch-fallthrough-case.ts:4:3 - error TS7029: Fallthrough case in switch. 반복문 타입스크립트는 ECMA 자바스크립트를 따르므로 자바스크립트의 반복문을 지원한다.ECMA 스크립트 표준이 발전하는 과정에 맞춰 새로운 for문이 타입스크립트에 추가되었다. 기본 for문 for문에서 사용할 변수에 let키워드와 타입을 지정할 수 있다. 12345678910111213141516// ES5for (var i = 0; i &lt; 2; i++) { console.log(\"i : \" + i);}// 타입스크립트for (let j: number = 0; j &lt; 2; j++) { console.log(\"j : \" + j);}/**i : 0i : 1j : 0j : 1 */ ES5 : var선언자는 블록 레벨 스코프가 적용되지 않아 for문에서 초기화한 변수를 for밖에서도 사용 가능했다.타입스크립트 : j변수에 number 타입을 지정해 타입 안전성을 강화했고, let선언자를 사용해 for문 내부에서만 사용되도록 블록 레벨 스코프가 적용되었다. for in문 (ES5) for…in문은 ES5의 자바스크립에서 배열이나 객체를 순회할 떄 사용한다. 1234567891011let islands = [\"a\", \"b\", \"c\", \"d\"];for (let index in islands) { console.log(index, islands[index]);}/**0 a1 b2 c3 d */ for…in문에 선언된 변수 index는 인덱스를 나타내며, 배열의 요소를 가져오려면 islands[index]와 같이 인덱스를 통해 값을 접근 할 수 있다.만약, 인덱스가 숫자가 아닌 키라고 한다면 객체 리터럴을 이용하면 된다. for...in문을 통한 객체 리터럴을 순회12345678910let fruits = { a: \"apple\", b: \"banana\", c: \"cherry\" };for (let property in fruits) { console.log(property, fruits[property]);}/**a appleb bananac cherry */ fruits 변수를 객체 리터럴로 초기화했고, for…in문을 이용해 객체 리터럴을 순화했다. 이때 property변수를 통해 키 값으로 접근 했으며, fruits[property]로 문자열 키를 이용해 대응되는 객체의 값을 가져왔다. for of문 (ES6) for…of문은 ES6 표준에 추가된 특징이며 인덱스를 이용해 값을 가져오는 for…in과 달리 for…of문은 바로 값을 가져올 수 있다. [형식]for(변수 of 이터러블){명령문;} 이터러블(iterable)객체는 반복 가능한 객체인 배열, 문자, 숫자, DOM 컬렉션, 맵(Map), 셋(Set) 등을 말한다. 이터러블 객체가 문자열인 경우 이터러블 객체가 문자열인 경우12345for (let value of \"hi\") { console.log(value);}// \"h\"// \"i\" 이터러블 객체가 배열인 경우 이터러블 객체가 배열인 경우123456789for (const value of [1, 2, 3]) { console.log(value);}/**123 */ 일반 for문에서 let 선언자가 아닌 const를 사용하면 상수가 되어 증가 값이 바뀌지 않아 무한 루프가 되지만,for of는 Symbol.iterator 의 구현을 통해 각 이터레이션 값의 요소를 가져오기 때문에 const를 사용할 수 있다. Map 과 Set ES6에 추가된 이터러블 객체로 맵(Map)과 셋(Set)이 있다. 맵과 셋은 tsconfig.json 의 target 속성이 es5이면 컴파일 되지 않는다.es5에 맵과 셋을 대응할 만한 문법이 존재하지 않기 때문이다.따라서, 맵과 셋을 이용하는for of 문을 실행하려면 tsconfig의 target 을 ES2015로 수정해아한다. tsconfig.json12345678{ \"compilerOptions\" :{ \"target\" : 'ES2015' }}// 또는 cmd에서 컴파일시tsc example.component.ts --target es6 Map 12345678910111213let itMap = new Map([ [\"one\", 1], [\"one\", 2]]);itMap.set(\"one\", 3);for (let value of itMap) { console.log(value);}console.log(itMap.get(\"one\"));// 3 맵 객체는 키 중복을 허용하지 않으므로 for…of문을 이용해 출력해보면 중복을 제하고 출력된다. 맵 객체는 키-값 기반이므로 키를 이용해 값을 가져올 수 있다. 맵 겍체를 이용하지 않고 객체 리터럴을 이용해 맵의 특징인 중복 제거와 키를 통한 값 접근을 구현 할 수도 있다. 12345678910let map: { [key: string]: number } = {};map[\"one\"] = 1;map[\"one\"] = 2;map[\"one\"] = 3;for (let value in map) { console.log(map); // {one : 3}}console.log(map[\"one\"]); // 3 Set셋 객체(Set Object)는 어떤 타입의 값이든 유일한 값을 저장 할 수 있다. 셋 역시 맵처럼 컴파일러 target 속성이 ES2015일때 허용된다. 123456789101112let itSet = new Set([\"a\", \"b\", \"c\", \"a\"]);for (let value of itSet) { console.log(value);}itSet.add(\"f\");/**abc */ Set 객체는 값을 추가하거나(add), 비우거나(cleear), 삭제하는것(delete)과 같이 키가 아닌 값을 다루는 메서드를 제공한다. [Symbol.iterator()]메서드를 이용한 이터러블 객체 사용 [Symbol.iterator()]은 ES6에 추가된 특징으로 배열, 맵, 셋과 같은 이터러블 객체를 순회하는데 사용한다.이 메서드는 반복문을 순회할 때 마다 next() 메서드를 통해 순회 중인 객체를 반환하는 특성이 있다. 123456789101112131415let arr = [1, 2];let itObj = arr[Symbol.iterator]();console.log(typeof itObj);console.log(itObj.next());console.log(itObj.next());console.log(itObj.next());/** * object{ value: 1, done: false }{ value: 2, done: false }{ value: undefined, done: true } // 더 이상 반환되는 객체가 없으므로 value가 undefined가 되며 모든 객체를 순회했으므로 done 이 true가 된다. */ while과 do-while while while문의 조건이 참이면 명령문을 실행하며 조건이 거짓이면 명령문의 실행을 끝내는 반복문이다. do while문 do-while문은 명령문을 실행하고 나서 조건이 참이면 명령문을 실행하고 거짓이면 명령문 실행을 끝내는 반복문이다.while과 달리 명령문을 먼저 실행하고 조건을 검사하기 때문에 최소 한 번 이상 명령문 실행이 보장된다. do-while12345678910111213let cnt: number = 0;do { console.log(cnt); cnt++;} while (cnt !== 4);/**0123 */","link":"/2020/03/21/ts_md/ts2/"},{"title":"typescript chapter6. 함수","text":"자바스크립트 함수 타입스크립트는 함수의 매개변수나 반환값에 타입을 지정해 타입 안정성을 강화할 수 있다.자바스크립트 함수는 기명 함수와 익명함수로 나뉜다. 기명함수는 호출 될 때 호이스팅이 발생한다. 함수를 선언하기 전에도 선언한 후에도 호출할 수 있다. 기명함수1234myFunction(1,2);function myFunctiion(x,y){}myFunction(1,2); 변수에 익명함수를 할당해 호출하면 익명 함수를 할당 한 뒤에만 함수를 호출 할 수 있다. 익명함수123myFunc(1, 2); // Block-scoped variable 'myFunc' used before its declaration.ts(24let myFunc = function (a, b) { }myFunc(1, 2); let 선언자는 익명 함수를 변수에 할당 한 후에만 호출하게 함 자바스크립트 함수의 불안정성 자바스크립트 - 느슨한 타입 언어 , 프로그램이 실행될 때 동적으로 타입을 할당, 타입 추론, 타입이 없어 브라우저 환경에서 속도가 빠름그러나, 타입이 없기 때문에 런타임때 의도치 않은 타입 변환이 일어날 수 있다. 1234567function abc(str) { return str + 1000;}let result = abc('10');console.log(typeof result, result); // string 101000 함수의 매개변수와 반환값에 타입을 지정하지 않아 함수에서 연산시 결과를 예측할 수 없음이를 방지하기위해 자바스크립트는 불필요한 매개변수 검증이나 타입 캐스팅을 수행 불필요한 타입 캐스팅의 예123456789function abm(num) { if (typeof num !== 'number') { num = Number(num) } return Number(num) + 1000;}let result = Number(abm('1000')) 타입이 고정되어 있지 않아 불필요한 코드가 발생함 타입 안정성을 가진 타입 스크립트 함수 타입스크립트는 함수의 매개변수나 반환 값에 타입을 추가해 타입 안정성을 강화함 , 이러한 과정을 함수에 대한 타입 지정(typing)이라고 함안정성이 보장되므로 타입 검사나 캐스팅 작업이 필요가 없음 12345678910111213function max(x: number, y: number): number { // 매개변수와 반환값에 number 타입 지정 if (x &gt; y) { return x; } else { return y; }}let a = max(1, 2);let b = max(\"abc\", \"ABC\"); // Argument of type '\"abc\"' is not assignable to parameter of type 'number'.tsconsole.log(`a=${a}`);console.log(`b=${b}`); // Argument of type '\"abc\"' is not assignable to parameter of type 'number'.ts 안전하게 매개변수로 숫자 값만 전달하고, 함수에서 안전하게 숫자 값만 반환함 매개변수의 활용 ES6에 추가된 기본 초기화 매개변수는 함수의 특정 매개변수에 인수가 전달되지 않으면 매개변수에 설정된 초깃값으로 값을 초기화하는 기능이다. 타입스크립트123456function pow(x: number, y: number = 2): number { return x ** y};console.log(pow(10)); // 100console.log(pow(10, 3)); // 1000 나머지 매개변수 나머지 매개변수(rest parameter)는 es6에서 제안된 특징으로 개수가 정해지지 않은 인수를 배열로 받을 수 있는 기능이다. 1234567function concat(a, b, ...rest) { return a + b + rest.join('');}// concat() //Expected at least 2 arguments, but got 0.ts(2555)concat(\"a\", \"b\", 1, 2, true, false); 나머지 매개변수는 0개 이상 요소를 받을 수 있다. 위 concat 함수를 호출하려면 최소 0개 이상 인수를 전달해야한다.선언된 나머지 매개변수는 타입이 없기 때문에 타입 구분 없이 여러 인수를 전달받아 문자열 합치기를 수행한다. 만약, 전달받을 요소가 string으로만 받아야 한다면 타입을 제한해야할 필요가 있다.이때 나머지 매개변수에 타입을 추가하면 지정한 타입의 인수만 받을 수 있다. 123function concat(a, b, ...rest: string[]) { return a + b + rest.join('');} 나머지 매개변수는 개수가 정해지지 않은 인수를 받기 때문에 문자열 배열 타입인 string[]으로 지정해야한다. 나머지 매개변수는 ES6에 도입된 특징이므로 위 코드를 ES5로 컴파일하면 나머지 매개변수 기능을 동작시키지 위해함수 내부에 인수(arguments) 객체를 순회하는 for문이 추가된다. 12345678910111213// 나머지 매개변수 사용시(es6)function colors(a: string, ...rest: string[]) { return a + \" \" + rest.join(\" \");}//es5로 변환시function colors(a) { var rest = []; for (var _i = 1; _i &lt; arguments.length; _i++) { rest[_i - 1] = arguments[_i]; } return a + \" \" + rest.join(\" \");} 선택 매개변수 함수 호출 시에는 매개변수를 선언한 만큼 인수를 전달해야한다. 그런데 나머지 매개변수는 개수가 정해져 있지 않아 불필요한 인수가 전달 될 수 있다.따라서 전달할 인수의 개수를 0개 이상 1개 미만으로 제한하려면 선택 매개변수(optional parameter)을 이용해야 한다.선택 매개변수는 변수명 뒤에 물음표를 붙이는 식으로 선언한다. 선택 매개변수를 이용하면 지정한 매개변수는 생략 할 수 있다. 1234function sum(a: number, b?: number): number { return a + b}console.log(sum(1)) // NaN 매개변수는 2개지만 두번째가 선택 매개변수라서 인수 하나를 생략해 호출하더라도 에러가 발생하지 않는다.다만 선택 매개변수로 지정된 b가 초기화되지 않았으므로 NaN 값이 되어 반환값도 NaN이 된다. 선택 매개변수와 매개변수의 초깃값 설정은 함께 사용할 수 없다. 123function sum(a: number, b?: number = 2): number { //Parameter cannot have question mark and initializer. return a + b} 위 내용을 수정하려면 매개변수 b에 대한 undefined 검사를 통해 초깃값을 설정해야한다. 12345678function sum2(a: number, b?: number) { if (b === undefined) { b = 0; } return a + b;}console.log(sum2(1)); 매개변수 b가 아무것도 전달 못받았을 때 어떤 값으로 초기화해야하는지에 대한 로직을 추가함 함수 오버로드 함수 오버로드란 매개변수와 반환 타입이 다른 함수를 여러 개 선언할 수 있는 특징을 말한다.오버로드는 목록 형태로 선언할 수 있다. 12345function add(a: string, b: string): string;function add(a: number, b: number): number;function add(a: any, b: any): any { return a + b;} 가장 일반적인 함수(매개변수가 any 타입)을 가장 아래에 선언하고 그 위로 구체적인 타입을 명시한 함수를 쌓는 방식으로 선언한다.각 오버로드를 독립된 블록 형태로 선언하면 안됀다.매개변수의 개수가 다른 오버로드를 지정할 때는 선택 매개변수를 둬 매개변수 개수에 변화를 줄 수 있도록 허용할 수 있다. 선택 매개변수를 둔 경우123456789101112function add(a: number): number;function add(a: number, c: number): number;function add(a: any, b?: any): any { if (b === undefined) { return a; } else { return a + b; }}console.log(add(1, 2)); // 3console.log(add(1)); // 1 add 함수 두번째 매개변수에 ?를 사용해 선택 매개변수로 선언했다. 선택 매개변수는 전달 받은 값이 없을수도 있으므로 undefined 인지 검사하는 로직을 추가해야한다. 익명함수의 이해와 활용익명함수와 화살표 함수 화살표 함수(arrow function)은 ES6 표준에 포함된 익명 함수를 좀 더 간략하게 표현 할 수 있는 방법이다.매개변수가 하나도 없을 때는 ( )로 표현한다. 화살표 함수를 호출하려면 변수에 할당해야 한다. 123let x1 = () =&gt;{};x1(); // 함수 호출시 매개변수가 1개인 화살표는 다음과 같이 표현할 수 있다. 12let y1 = x =&gt; {return x};let y1 = (x) =&gt; {return x}; 매개변수가 1개일때는 소괄호를 생략할수 있다. 생략하지 않는 형태도 유효하지만 타입스크립트 스타일 가이드에서 추천하지 않는다. 화살표 함수를 호출할때는 변수를 이용해 호출한다. 유의할 점은 중괄호{}를 사용한 경우 반환값이 있으면 return 키워드를 사용해 값을 반환해야한다.매개변수가 2개일 때는 소괄호를 사용해 표현한다. 1234567let x1 = (x) =&gt; { x;}; // 반환값이 없다.let x2 = (x, y) =&gt; { return x + y;}; // 매개변수가 2개일 때 화살표함수는 익명함수라 변수를 할당에 호출했지만, 변수를 사용하지 않고 화살표 함수를 사용하려면 즉시실행함수(IIEF)를 이용해야 한다.즉시 실행함수는 코드를 실행하면 별도의 외부호출없이 바로 함수가 자체적으로 호출된다. IIEF1234567// reteurn 값이 없을때(x =&gt; { x;})(3);// retunr 값이 있을 때let iife = ((x) =&gt; { return x;})(3); 위와 같이 return 를 사용해 실행하면 iife 변수에 즉시실행함수가 반환한 값이 할당된다. 필터 메서드 (filter) 화살표함수는 필터 메서드를 적용할 수 있다. 필터 메서드는 배열에서 조건에 맞는 요소를 추출할 때 사용한다.for문을 순회해 조건에 맞는 값을 찾는 것보다 편리하고 유지보수에도 좋다. filter 메서드1234567let list = [1, 2, 3, 4, 5];list = list.filter((x) =&gt; { return x % 2 === 0;});console.log(list); // [2,4] 리듀스 메서드(reduce) 배열의 합을 구하는데 적용할 수 있다. reduce 메서드는 배열의 요소를 왼쪽에서 오른쪽으로 더해가면서 값을 처리할수 있는 메서드이다. reduce 메서드123456789101112131415161718console.log( [1, 2, 3, 4, 5].reduce((a, b) =&gt; { return a + b; }));// 15// 화살표 함수로 합계 계산(reduce) 사용function getSum(numList: number[]) { let sum: number = numList.reduce((a, b) =&gt; { return a + b; }); return sum;}console.log(getSum([1, 2, 3, 4, 5]));// 15 첫번째 매개변수(a)는 누적된 값이고, 두번째 매개변수(b)는 현재값 이다. 객체 리터럴 객체 리터럴은 여러 속성의 값을 한 단위로 묶어서 표현할 수 있는 객체이다.객체 리터럴의 속성은 키(key)이며, 값(value)은 숫자,문자열뿐만 아니라 사용자가 정의한 객체도 할당 할 수 있다. 따라서 함수 역시 객체이므로 함수도 속성 값으로 할당 할 수 있다. 값을 선언하면서 객체 프로퍼티를 참조하려면 this 키워드를 사용한다. this를 이용해 다른 객체 속성 참조하기12345678let person = { name: \"lee\", hello: function (name2: string) { console.log(this.name, name2); // lee park },};person.hello(\"park\"); 객체 리터럴 내부에서 다른 프로퍼티를 참조할 일이 많다면 객체 리터럴에 타입을 선언할 수 있다.타입은 interface를 이용해 정의한다. 12345678910111213interface PersonType { name: string; hello(this: PersonType, name2: string): string;}let typedPerson: PersonType = { name: \"lee\", hello: function (this: PersonType, name2: string): string { let message = `${this.name + name2}`; return message; },};console.log(typedPerson.hello(\"world\")); // leeworld 참조 : https://webclub.tistory.com/390 익명함수의 타입 선언 익명 함수는 변수에 할당 할수 있고, 익명함수가 할당된 변수는 타입을 추가 할수 있으므로 함수 자체에도 타입이 존재할 수 있다.타입스크립트에서는 함수 자체에 대한 타입을 함수 타입(function type)이라고 한다. 할당한 익명함수에 매개변수 타입과 반환 타입을 추가할 수 있다. 익명함수에 타입 선언123let concat = function (str1: string, str2: string): string { return str1 + str2;}; 그런데, 익명함수에 선언된 타입을 별도로 분리해 선언하면 타입 안정성을 보장하면서도 익명함수의 타입이 무엇인지 쉽게 파악이 가능하다.특히 익명함수의 타입을 분리하면 새로 정의한 타입은 반복적으로 재활용해 사용할 수 있다. 1234type caltype = (a: number, b: number) =&gt; number;let add: caltype = (a, b) =&gt; a + b;let minus: caltype = (a, b) =&gt; a - b; 새롭게 정의한 타입인 caltype은 익명함수를 할당받는 여러 변수에 함수 타입으로 선언할 수 있다. 콜백함수의 타입 선언 콜백함수(callback)함수는 또 다른 함수의 매개변수로 전달 될 수 있는 함수이다.콜백함수를 전달받는 함수는 상위 처리를 담당하는 고차 함수(higher-order function)이라고 불린다.고차 함수는 하나 이상의 콜백을 전달받거나, 하나 이상의 함수를 결과로 반환하는 특성이 있다. 콜백함수의 한가지 예로 setTimeout함수가 있다. setTimeout은 지정된 시간이 지난 후에 어떠한 일을 처리하기 위해 콜백 함수를 전달 받는다. setTimeout123setTimeout(function () { console.log(\"종료\");}, 1000); 단순한 형태의 콜백함수는 다음과 같다. 123456function ehoFunction(message: string, callback) { return callback(message);}let response = ehoFunction(\"hello\", (message) =&gt; message);console.log(response); // hello 첫번째 인수로 문자열을 전달하고, 두번째 인수로 콜백 함수를 전달하면 문자열을 되돌려주는 에코(eho) 함수이다.두번째 인자인 콜백함수는 문자열을 반환하는 비교적 단순한 동작을 수행하므로 타입이 없는 화살표 함수를 사용했다.이렇게 하면 타입 안정성이 없으므로, 콜백 함수에 로직을 추가해야하고 콜백 함수가 중요하다면 콜백 함수 선언을 분리해 타입을 추가하는 편이 좋다. 12345type callbackType = (message: string) =&gt; string; // 콜백 함수의 타입을 먼저 선언let callback: callbackType = (message) =&gt; message; // 콜백 함수 선언let response = ehoFunction(\"hello\", callback);console.log(response); // hello 위 처럼 콜백 함수의 타입을 먼저 선언하고, 콜백함수의 선언과 사용을 분리할 수 있다.","link":"/2020/03/30/ts_md/ts4/"},{"title":"typescript chapter5. 연산자","text":"연산자산술 연산자 타입스크립트는 자바스크립트와 동일한 산술 연산자를 지원한다.더하기, 빼기, 곱하기, 나누기, 나머지 연산자(%)와 타입스크립트는 지수 연산자인 **을 지원하므로 Math.pow를 대체해 사용 가능하다. 12console.log(1 + \"happy\"); //1happyconsole.log(10 ** 3); //지수 연산자 1000 **은 타입스크립트에만 있는 지수 연산자이므로 js로 컴파일시 Math.pow로 컴파일된다. 위 코드를 컴파일 시12console.log(1 + \"happy\"); // 숫자 + 문자 = 문자console.log(Math.pow(10, 3)); 타입스크립트에서는 더하기 연산자를 허용하지 않는 예외 사항이 있다. number + boolean 값 연산시의 오류 1234561 + false; // Operator '+' cannot be applied to types 'number' and 'boolean'.ts// 번외로 다른 연산자를 넣었을 경우false * false;// The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.ts(2363)// 산술 연산의 오른쪽은 'any', 'number', 'bigint'또는 enum 유형이어야합니다 .ts (2363) js에서는 fasle를 0으로 인식하여 1로 출력하지만 타입스크립트에서는 타입 오류라고 판별한다. boolean + boolean 값 연산시의 오류 1false + false; //Operator '+' cannot be applied to types 'boolean' and 'boolean'.ts 마찬가지로 false 를 0으로 인식하지 않으므로 불리언 값끼리의 연산에도 타입 오류가 발생한다. 또한, 문자열 타입의 숫자를 연산식에 사용할 수 없다. js에서 문자열 타입의 숫자 연산시12console.log(10 / \"2\"); // 5console.log(10 - \"2\"); // 8 자바스크립트에서는 위 식은 정상적으로 실행되지만, 타입스크립트에서는 타입 오류가 발생한다. ts에서 문자열 타입의 숫자 연산시123console.log(10 / \"2\");console.log(10 - \"2\");// The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type. 비교, 논리, 조건 연산자 타입스크립트에서 조건문에 사용할 수 있는 연산자는 크게 세 부류가 있다. 비교 연산자 논리 연산자 조건 연산자 비교 연산자 자바스크립트에서는 피 연산자 간에 타입이 달라도 비교 할수 있다.타입스크립트에서는 피 연산자 간에 타입이 다르면 연산을 허용하지 않는다. 피연산자간의 타입이 다를때 비교12341 === true;0 === false;// this condition will always return 'false' since the types 'number' and 'boolean' have no overlap.ts(2367)// 'number'와 'boolean'유형이 겹치지 않으므로이 조건은 항상 'false'를 반환합니다 .ts (2367) 타입스크립트는 true === false와 같이 타입이 같은 피 연산자간의 비교만 허용한다.또한 , 타입스크립트는 ==보다 ===를, != 보다 !==를 권장한다. 자바스크립트로 컴파일 한 이후에도 타입 안정성을 보장 할 수 있기 때문이다. 논리 연산자 논리 연산자는 &amp;&amp;, ||, ! 세가지가 있다.비교 연산자와 달리 피 연산자 간의 타입이 일치하지 않아도 된다. 123console.log(1 &amp;&amp; true); // trueconsole.log(true || false); // trueconsole.log(!true); // false &amp;&amp; : 피 연산자가 모두 참일 때 참이라는 의미|| : 피 연산자 가운데 하나라도 참이면 참이라는 의미! : 부정 연산자 !true === false 조건 연산자 (?:) 피 연산자 3개를 이용하는 삼항 연산자이다.판별조건 ? true일때 실행하는 표현식 : false일때 실행하는 표현식 불리언 타입과 부정 연산자 불리언 타입(true/false) 타압스크립트에서는 상황에 따라 타입 변환이 발생해 true 인지 false인지 명확하지 않을 때가 있다.입력값이 숫자, 문자일 때 발생한다. 입력값이 숫자일 때, 예를 들어 1의 타입은 number이지만 12if (1) {} 위처럼 숫자 1이 조건문에 들어가면 타입 변환이 일어나 true가 된다. 1 , -1모두 true이다.다만 0은 false가 된다. 입력값이 문자일 때 에를 들어 “abc”의 타입은 string이지만 boolean 타입으로 변환하면 true가 된다.다만 빈 문자열 “”는 false가 된다. Boolean 메서드를 이용하면 입력값에 따라 불리언 타입으로 변환할 수 있다. 12345console.log(Boolean(-1)); // trueconsole.log(Boolean(1)); // trueconsole.log(Boolean(0)); // falseconsole.log(Boolean(\"\")); // falseconsole.log(Boolean(\"ab\")); // true 부정 연산자 값이 문자열, 숫자, 불리언이냐에 따라 다른 결과가 출력된다. 123console.log(\"hello\", !\"hello\", !!\"hello\", !\"\"); // \"hello\", false , true , trueconsole.log(1, !1, !!1, !0, !!0); //1 false true true falseconsole.log(!true, !false, !!true); //false true true 문자열 “hello”에 부정 연산자를 사용하면 “hello”자체가 조건문에서는 true가 되므로 !true === false가 된다.부정 연산자를 두번쓰면(!!) 부정의 부정이므로 참이 된다. 디스트럭처링 타입스크립트는 ES6의 디스트럭처링(destructuring)을 지원한다. 객체의 구조(structure)을 제거(de)한다는 의미가 있다.객체의 구조를 분해 후 할당, 확장과 같은 연산을 수행하는 것을 말한다.배열 디스트럭처링과 객체 디스트럭처링 이 있다. 객체 디스트럭처링 객체 디스트럭처링은 객체 리터럴에서 변수명에 대응하는 속성값을 추출해 변수로 할당할 때 유용하며,객체의 속성값을 변수에 할당하는 것을 디스트럭처링 할당이라고 한다. 할당 표현식은 {id,myName} 으로 표현한다. 할당 시에 id와 myName은 객체의 속성값(0,”lee”)에 대응한다. 디스트럭처링 할당1234let { id, myName } = { id: 0, myName: \"lee\" };console.log(id); // 0console.log(myName); // \"lee\" 디스트럭처링 할당 시에 할당 받을 속성이 없다면 표현식에 새롭게 정의한 변수를 선언해 초기화 할 수 있다. 1234let { id, myName = \"kim\" } = { id: 0 };console.log(id); // 0console.log(myName); // \"kim\" 속성 재명명을 이용해 할당할 객체 속성에 새로운 이름을 부여 할 수 있다. 1234let { id: name1, myName: name2 } = { id: 0, myName: \"lee\" };console.log(name1); // 0console.log(name2); // \"lee\" 디스트럭처링 매개변수 선언 함수 호출 시에 객체 리터럴을 전달하고 속성을 검사하려면 함수의 매개변수의 속성 검사 시123456789101112function profile(obj) { var name = \"\"; var jobs = \"\"; name = obj.name === undefined ? \"no name\" : obj.name; jobs = obj.jobs === undefined ? \"no jobs\" : obj.jobs; console.log(name); // lee console.log(jobs); // no jobs}profile({ name: \"lee\" }); 이런식으로 속성을 검사하기 위한 코드가 계속 발생하게 된다.객체의 특정 속성이 있는지 없는지를 타입에서 검사하고 없으면 기본값을 할당 할 수 있도록 함수의 매개변수에 디스트럭처링 매개변수를 선언 할 수 있다. 함수의 매개변수로 객체 디스트럭처링을 사용한 경우123456function profile({ name = \"no name\", jobs = \"no jobs\" }) { console.log(name); // lee console.log(jobs); // no jobs}profile({ name: \"lee\" }); 객체 디스트럭처링 시 type 키워드 활용 type 키워드를 이용해 매개변수에 타입을 선언함으로써 객체 디스트럭처링을 할 수 있다. 123456789type C = { a?: string; b: number };function func({ a, b }: C): void { console.log(a, b);}func({ a: \"abc\", b: \"def\" }); // (property) b?: numberfunc({ a: \"abc\", b: 0 }); // \"abc\" , 10func({ b: 0 }); // \"abc\"func({ a: \"def\" }); //Argument of type '{ a: string; }' is not assignable to parameter of type 'C'. 객체 디스트럭처링을 수행시 매개변수 a,b에 타입을 미리 정의한 타입 변수 C를 이용한다.a?는 string 타입이고 ?(선택연산자)로 선언했으므로 생략 가능하다. b는 number 타입이고 생략 불가능하다. 배열 디스트럭처링 배열 디스트럭처링은 배열 요소를 간결한 방법으로 변수에 할당하는 방법을 제공한다. 12345678910111213141516171819202122232425262728// 0. 배열 디스트럭처링을 활용하지 않을 때let numbers = [1, 2, 3, 4, 5];// let num1 = numbers[0]; // 1;// 1. 배열 디스트럭처링을 활용할 때let [num1, num2] = numbers;console.log(num1); // 1console.log(num2); // 2// 2. 배열의 3번째, 4번째 요소를 변수에 할당할 때// 앞의 요소는 쉼표로 건너 뛴다.let [, , num3, num4] = numbers;console.log(num3); // 3console.log(num4); // 4// 3. 값을 교환할 때[num3, num4] = [num4, num3];console.log(num3); // 4console.log(num4); // 3// 4. 기본값을 지정할 수 있다.let [color1, color2 = \"red\"] = [\"black\"];console.log(color1); // \"black\"console.log(color2); // \"red\" 배열 요소를 함수의 디스트럭처링 매개변수로 전달 배열 디스트럭처링을 이용하면 함수에 배열을 전달할 때 배열 요소를 디스트럭처링 매개변수로 전달 할 수 있다. 123456function func([a, b]: [number, string]) { console.log(a); // 1 console.log(b); // \"hi\"}func([1, \"hi\"]); 전개 연산자 타입스크립트는 ES6의 전개연산자(…)를 지원한다. 전개 연산자는 다음과 같을때 사용한다. 나머지 매개변수를 선언 배열 요소 확장 객체 요소 확장 나머지 매개변수를 선언뒷장에서 설명 배열 요소 확장배열 합치기와 배열 디스트럭처링 할 때 사용한다. 객체 요소 확장객체 합치기와 객체 디스트럭처링 할 때 사용 전개 연산자를 이용한 배열 요소 확장 전개 연산자를 이용해 배열을 합칠 수 있다. 배열 합치기12345let arr1 = [1, 2, 3];let arr2 = [...arr1, 4, 5];let arr3 = [4, ...arr1, 5];console.log(arr2); // [ 1, 2, 3, 4, 5 ]console.log(arr3); // [ 4, 1, 2, 3, 5 ] 전개 연산자를 이용하면 간단히 배열을 합칠 수 있고 원하는 위치에 배열 요소를 전개할 수 있다. 할당받는 변수에 전개 연산자를 사용하면 나머지 요소를 배열로 받을 수 있다.(배열 디스트럭처링) 배열 디스트럭처링12345let [first, ...rest]: [number, number, number] = [10, 20, 30];console.log(first); // 10console.log(rest); // [20,30]console.log(rest[0]); // 20 전개 연산자를 이용한 객체 요소 확장 객체 합치기를 수행할 때 전개 연산자를 이용해 합칠 수 있다. 1234let obj1 = { c: 3, d: 4 };let obj2 = { a: 1, b: 2, ...obj1, e: 5 };console.log(obj2); // { a: 1, b: 2, c: 3, d: 4, e: 5 } 객체 디스트럭처링에서 전개 연산자 사용 12345let group = { a: 1, b: 2, c: 3 };let { b, ...rest } = group;console.log(b); // 2console.log(rest); // { a: 1, c: 3 } 위 코드 속성 rest에 전개 연산자가 사용되었으므로 rest는 rest 속성(나머지)가 된다. b속성을 제외한 나머지에 해당하는 객체를 받게 된다.","link":"/2020/03/22/ts_md/ts3/"},{"title":"typescript chapter8. 모듈","text":"모듈 모듈은 독립 가능한 기능의 단위이다. 모듈을 사용하면1) 유지보수가 쉬워진다. 자주 사용하는 공통 기능을 정의해 사용하면 중복 코드가 적어져 유지 보수가 쉬워진다.2) 전역 스코프 오염을 방지한다. 전역 스코프 내부에서 함수나 변수 이름을 중복해 선언할 수 없으므로 이를 파일 내부에 한정해 모듈로 선언하면 전역 공간을 침범하지 않는다.3) 재사용성이 향상된다. 모듈은 프로젝트에 자주 사용되는 기능을 공통으로 뺴놓을 수 있게 된다. 내부 모듈과 외부 모듈 내무 모듈은 네임스페이스를 의미하고, 외부 모듈은 export 라고 선언해 외부로 공개된 모듈을 의미한다.네임 스페이스는 여러 파일에 걸쳐 하나의 이름 공간을 공유하지만, 외부 모듈은 모듈 파일마다 이름 공간이 정해진다. 내부모듈내부 모듈은 네임스페이스는 전역 이름 공간과 분리된 네임스페이스 단위의 이름공간이다.따라서 같은 네임스페이스내 이름공간에서는 파일 B가 파일 A에 선언된 모듈을 참조(reference)할 수 있다.파일이 다르더라도 같은 네임 스페이스 내에서는 이름을 중복해 클래스,함수,변수 등을 선언 할 수 없다. 외부모듈export로 선언한 모듈을 외부 모듈이라고 한다. export 키워드로 외부 모듈로 선언할 수 있는 대상은 변수, 함수, 클래스 , 네임스페이스 등이 가능하다.export로 외부 모듈로 선언하면 이름이 같아도 충돌이 일어나지 않는다. 1234567891011//ts1.tsexport function1(){}//ts2.tsexport function1(){}/**이름이 같아도 export로 분리하면 충돌이 발생하지 않지만 export를 생락하면 전역 스코프의 이름 공간을 공유해 충돌이 발생함*/ 타입스크립트는 module 옵션을 통해 다른 모듈 형식으로 변환할 수 있게 지원한다. tsc의 –module 옵션을 통해 특정 모듈 형식으로 변환할 수 있다. 1234tsc --module &lt;모듈형식&gt; &lt;변환할 파일명&gt;/** 예시 **/tsc --module commonjs example.component.js module 옵션에서 사용할 수 있는 모듈형식은 다음과 같다. commonjs amd system umd es2015 또는 es6 모듈 예제를 컴파일 할 때 주의사항 Node.js 버전이 8.5.0 이상이면 –experimental-modules 플래그를 통해 es 모듈에 대한 컴파일을 지원한다. 1node --experimental-modules load-default.mjs 이 때 자바스크립트 확장자가 .mjs 여야한다. 반대로 8.5.0 미만이면 es2015를 지원하지 않으므로 다운 레벨 컴파일이 필요하다. 네임스페이스 네임스페이스는 하나의 독립된 이름 공간을 만들고, 여러 파일에 걸처 하나의 이름 공간을 공유하게 한다.namespace 키워드를 이용해 선언한다. module 키워드로도 같은 역할과 기능을 한다. 12namespace Hello {}module Hello{} namespace와 module의 선언과 컴파일 결과 확인hello.ts1234567891011namespace Hello { function print() { console.log(\"hello\"); }}module Hello { function print() { console.log(\"hello\"); }} hello.js123456var Hello;(function (Hello) { function print() { console.log(\"hello\"); }})(Hello || (Hello = {})); namespace와 module은 컴파일 결과가 완전히 동일하다. 내부 모듈은 자바스크립트(es6)로 컴파일 될 때 즉시 실행함수로 변환된다. 한 파일에 여러 네임스페이스 선언 네임스페이스는 보통 여러 파일에 걸처 하나의 이름 공간을 공유하는데, 특정 파일에만 네임 스페이스를 선언하거나, 하나의 파일에 여러 네임스페이스를 함께 써도 가능하다. 한 파일에서 여러 네임스페이스를 써서 서로의 이름 공간에 접근하려면 모듈을 export로 선언해야한다. 12345678910111213141516171819// 네임스페이스 간에는 모듈을 서로 호출하고 주고 받을 수 있다.namespace MyInfo1 { // export로 오 export let name = \"happy1\"; export function getName2() { return MyInfo2.name2; }}namespace MyInfo2 { export let name2 = \"happy2\"; export function getName() { return MyInfo1.name; }}// 전역 공간에서 네임스페이스 내부에 선언된 외부 모듈 호출할 수 있다.console.log(MyInfo1.getName2()); // happy2console.log(MyInfo2.getName()); // happy1 자바스크립트는 코드가 순차적으로 실행되므로 상위의 있는 네임스페이스에서 하위에 선언된 네임스페이스로 접근할 수 없어야 한다.그런데, 컴파일 결과를 보면 실행 순서와 관계없이 자유롭게 호출할 수 있는데 이는 컴파일시 네임 스페이스 이름이 var 변수로 선언됬기 때문이다. 컴파일 결과123456789101112131415161718192021// 네임스페이스 간에는 모듈을 서로 호출하고 주고 받을 수 있다.var MyInfo1;(function (MyInfo1) { // export로 오 MyInfo1.name = \"happy1\"; function getName2() { return MyInfo2.name2; } MyInfo1.getName2 = getName2;})(MyInfo1 || (MyInfo1 = {}));var MyInfo2;(function (MyInfo2) { MyInfo2.name2 = \"happy2\"; function getName() { return MyInfo1.name; } MyInfo2.getName = getName;})(MyInfo2 || (MyInfo2 = {}));// 전역 공간에서 네임스페이스 내부에 선언된 외부 모듈 호출할 수 있다.console.log(MyInfo1.getName2());console.log(MyInfo2.getName()); 참조 경로 추가car1.ts1234567namespace Car { export let auto: boolean = false; export interface ICar { name: string; }} car1.ts 파일에는 export로 auto변수와 ICar 인터페이스가 선언되어있음. car2.js1234567891011namespace Car { let wheels: number; console.log(auto); class Taxi implements ICar { name: string; vendor: string; }}console.log(Car.auto); car2.ts에서 Taxi 클래스는 car1.js의 ICar 인터페이스를 참조한다. 같은 네임스페이스(Car) 안에서 선언되어 있으므로tsc로 프로젝트 단위로 컴파일 하면 이상없이 컴파일된다. 그러나 특정 파일 (car2.ts)만 컴파일 하면 문제가 발생한다.따라서 파일 상단에 명시적으로 참조 경로(reference path)를 선언해줘야한다. 참조 경로 설정1/// &lt;reference path=\"car1.ts\" /&gt; 참조 경로는 트리플 슬래시를 이용해 작성한다. 참조 경로를 작성한 car2.ts를 컴파일하면 참조 경로로 연결된 car1.ts도 함께 컴파일되어car1.js, car2.js 두 파일이 생성된다. 그 다음 컴파일된 car2.js를 실행하면 다음과 같다. 123node car2.jsundefinedundefined undefined가 출력되는 이유는 컴파일 후 js 파일에서 참조 경로가 주석처럼 인식되어 제 기능을 할 수 없기 때문이다.올바른 결과를 컴파일 하려면 두 파일을 합쳐서 컴파일 해아한다. 1tsc --out out.js car2.ts 위 명렁어를 입력하면 car1.js 파일의 결과를 합쳐 out.js라는 파일을 생성한다. 컴파일 결과가 한 파일에 존재하므로 참조 경로나 require 함수가 없더라도 정상적으로 결과가 출력된다. out.js12345678910111213141516var Car;(function (Car) { Car.auto = false;})(Car || (Car = {}));/// &lt;reference path=\"car1.ts\" /&gt;var Car;(function (Car) { var wheels; console.log(Car.auto); var Taxi = /** @class */ (function () { function Taxi() { } return Taxi; }());})(Car || (Car = {}));console.log(Car.auto); 네임스페이스 모듈 네임스페이스는 export를 이용해 모듈로 선언할 수 있다.import문을 이용해 js로 컴파일 된 뒤에도 명시적으로 모듈 호출(imort문 , require 함수) 등을 할 수 있다. 먼저 export 키워드를 이용해 Car 네임스페이스를 모듈로 선언한다. car1.ts12345678export namespace Car { export let auto: boolean = false; export interface ICar { name: string; vendor: string; }} 그 다음 네임스페이스 모듈을 호출하는 import문을 다음과 같이 작성한다. car2.ts123456789101112import * as ns from \"./car1\";namespace Car { let wheels: number; console.log(ns.Car.auto); class Taxi implements ns.Car.ICar { name: string; vendor: string; }} 그 뒤 car2.ts 파일을 컴파일 한다. 1tsc car2.ts tsc로 컴파일시 –module 옵션을 설정하지 않았으므로 기본 설정인 CommonJs 모듈 형식으로 변환된다. 네임스페이스 이름 확장 네임스페이스 이름은 알파벳 대소문자를 사용한다. 1namespace Animal{} 네임 스페이스 이름은 예외로 점(.)을 허용한다. 점을 이용하면 네임스페이스 간의 이름 계층을 만든다. 1namespace Animal.Land{} Animal과 Animal.Land 네임스페이스는 서로 다른 이름 공간이다.따라서 Animal.Land 네임스페이스에서 Animal의 모듈 함수를 호출할 수 있다. 또한, 한 파일내에 여러 네임스페이스를 선언할 때 논리적인 이름 순서 상 상위 이름은 앞에 선언되어야한다.그러나 선언 순서를 바꾼다고 해서 문제가 생기지는 않는다. animal.ts 논리적 순서에 맞게 1234567891011namespace Animal{...}namespace Animal.Land {...}namespace Animal.Land.Cat{ ..} 위와 같이 선언된 네임스페이스를 import 할때는 최상위 이름만을 이용해야한다. 1import { Animal } from \"./animal\"; 모듈의 이해와 사용 타임스크립트는 ES2015 모듈 선언과 호출과 관련한 스타일을 지원한다. 모듈 선언과 모듈 임포트 export나 import 제한자를 통해 모듈을 선언하고 호출할 수 있다. 이러한 방식을 명명된 내보내기(named exports)라고 한다.외부로 노출된 모듈은 import를 통해 가져올 수 있다. 함수나 인터페이스와 같은 단위별로 노출하려면 개별 노출 형식을 사용한다. export.ts12export interface ICard {}export function saveInfo(card: ICard, name: string) {} export로 노출된 ICar 인터페이스와 saveInfo 함수는 다음과 같은 방식으로 임포트 할 수 있다. 123import { ICard,saveInfo} from './export'let card : ICard ={};saveInfo(card,\"string\"); 여러 모듈 export 하기 함수나 인터페이스 뿐만 아니라 배열과 변수 등도 모듈로 선언할 수 있다. variable.ts12345let ver = \"1.0\";let author: string = \"happy\";let extensions = [\"jpg\", \"bmp\", \"png\"];let display = () =&gt; \"hello world\";export { ver, author, extensions, display }; 일일이 export 붙이기 힘드므로 다음과 같은 형태로 여러 변수를 함꼐 export 할 수 있다. export된 함수는 다음과 같이 import 해 사용할 수 있다. 1import { ver, author, extensions, display } from \"./variable\"; 만약, 모둘로 선언할 대상이 인터페이스를 사용하는 함수 일때는 함수가 인터페이스와 의존관계에 있으므로 함께 선언해주어야한다. 1234interface ICar {}function drive(car: ICar) {}export { ICar , drive} 모듈을 재 노출해 사용하기 가져온 모든 모듈 재노출 한 파일에서 재노출할 모듈이 많아 구체적인 이름을 열거하기 불편할 때 export * from 을 이용한다.(*) 은 모든 모듈을 의미한다. 예시1export * from \"./module1\"; 외부 모듈 *에 대한 별칭이 없으므로 임포트시 as 키워드를 이용해 별칭을 추가해야한다. 12import * as m from \"./module1\";m.run(20); 디폴트 모듈의 이해와 사용법디폴트 모듈 선언 타입스크립트 1.5에서는 import-equals문과 export-equals 문 대신 다른 형태로 모듈을 선언하거나 임포트 할 수 있다.export-equals 할당은 default 키워드를 이용한 방식으려 변경되었다. 1234export default { title: \"title\", length: 11,}; 위와 같이 default로 선언된 모듈은 파일마다 하나씩만 선언되어야 한다.다음과 같은 방식으로도 선언 가능하다. 123456789101112131415161718192021222324252627282930//기본export default { title: \"title\", length: 11,};//변형export a = { title : 'title', length : 11 } export { a as default} //익명 함수 export default function(x :number){ }//기명 함수export default function add(x :number){}//클래스export default class Hello{ sayHello(){ console.log('hello'); }} import-equals 문은 require() 대신 import 형식으로 가져올 수 있다. 123import Validator from \" ./validator\";import {default as Validator} from './validator' 디폴트 모듈과 명명된 모듈을 함께 가져오기 디폴트 모듈은 default 키워드를 이용해 선언한다. 익명의 객체 리터럴을 디폴트 모듈로 선언하고 임포트하는 과정은 다음과 같다. default.ts1234export default{ name : 'happy'; age : 40} 익명의 객체 리터럴을 디폴트 모듈로 선언할 경우 외부에 export 할 때 이름이 없으므로 임의로 지정해 주어야한다. 1import profile from \"./default\"; 또한 default 키워드는 한 번만 사용해야 한다. 유일한 식별자로서만 인식되기 때문이다. 두 번 사용하면 컴파일 에러가 발생한다. default 모듈을 import 할때는 {}에 선언하면 안돼고 {}가 없이 선언해야한다. 12import {default} from \"./default\"; (x)import default from \"./default\"; (o) 따라서 디폴트 모듈과 일반 모듈을 함꼐 import 할때는 다음과 같이 사용해야한다. 12import profile from \"./default\"; // 한 개의 디폴트 모듈 임포트시import p, { hello } from \"./default2\"; // 디폴트 모듈 p와 일반 모듈hello를 임포트시 이처럼 디폴트 모듈과 일반 모듈을 함께 임포트 할 때는 디폴트 모듈은 이름만 선언하고 일반 모듈은 {} 내부에 선언해야한다. 디폴트 모듈로 타입과 모듈을 함께 노출하기export.ts12345678910interface HelloMessage { first: string;}function HelloMessage(name: string): HelloMessage { let message: HelloMessage = { first: \"hello\" }; return message;}export default HelloMessage; // 디폴트 모듈로 export함 interface 명과 함수 명을 HelloMessage로 일치시키고 해당이름으로 export 한 뒤 ,export된 디폴트 모듈을 임포트하면 같은 이름을 이용해 함수 또는 인터페이스 타입으로서 사용할 수 있다. import.ts12345import hello from \"./export\"; // 디폴트 모듈은 임포트할 때 이름 변경이 가능하다.let helloMessage: hello = hello(\"hello\");console.log(hello(\"hello\")); // { first: 'hello' }console.log(helloMessage); // { first: 'hello' } 임포트한 hello 모듈은 hello(‘hello’)와 같이 함수로 사용될 수 있고, : hello와 같이 인터페이스 타입으로 사용될 수도 있다.","link":"/2020/05/09/ts_md/ts6/"},{"title":"chapter14. 비동기적 프로그래밍","text":"자바스크립트는 기본적으로 단일 스레드에서 동작한다. 즉 한 번에 한 가지 일만 할 수 있다.자바스크립트에서는 매우 일찍부터 비동기적 실행 매커니즘이 존재했지만, 필요한 장치가 추가되었다. 콜백, 프라미스, 제너레이터가 그것이다.제너레이터는 비동기적 프로그래밍을 전혀 지원하지 않으므로 비동기적으로 쓰기 위해 프라미스나 특수한 콜백과 함께 사용해야한다.사용자 입력 외에, 비동기적 테크닉을 사용해야 하는 경우는 크게 세 가지가 있다. Ajax 호출을 비롯한 네트워크 요청 파일을 읽고 쓰는 등의 파일시스템 작업 의도적으로 시간 지연을 사용하는 기능(알림 등) 14.1 비유 분주한 음식점에서 전화번호를 받아서 자리가 나면 알려줌 : 콜백음식점에 자리가 났을 떄 진동하는 호출기를 넘겨줌 - 프라미스 14.2 콜백 콜백은 자바스크립트에서 가장 오래된 비동기적 매커니즘이다.콜백이란 나중에 호출할 함수이다.콜백 함수는 일반적으로 다른 함수에 넘기거나, 객체의 프로퍼티로 사용한다. 배열에 넣어서 쓰기도한다. 대게 익명 함수로 사용한다. setTimeOut1234567891011121314// ## 14.2 콜백console.log(\"before setTimeout \" + new Date());function f(){ console.log(\"After setTimeout \"+ new Date());}setTimeout(f, 60 *1000); // 1분 console.log(\"i happen after setTimeout\");console.log(\"me too\");/*before setTimeout Thu Aug 01 2019 21:10:46 GMT+0900 (GMT+09:00)i happen after setTimeoutme tooAfter setTimeout Thu Aug 01 2019 21:11:46 GMT+0900 (GMT+09:00)*/ 작성하는 코드와 실제 실행되는 코드가 다르다. 비동기적 실행의 가장 중요한 점은 어떤 것도 차단하지 않는다는 것 자바스크립트는 싱글 스레드를 사용하므로, 컴퓨터에 60초 동안 대기한 후 코드를 실행하게되면 프로그램이 멈추고, 사용자 입력을 받아들이지 않는 등의 문제가 발생한다. 위 예제는 이름 붙은 함수 f를 setTimeout에 넘겼으나, 이름을 쓸 이유가 없다면 일반적으로 익명 함수를 사용한다. setTimeOut 익명함수123setTimeout(function(){ console.log(\"After TimeOut \"+ new Date() ,6000);}); 14.2.1 setInterval 과 clearInterval setTimeout은 콜백 함수를 한 번만 실행하고 멈추지만,setInterval은 콜백을 정해진 주기마다 호출하며 clearInterval을 사용할 때까지 멈ㅊ지 않는다. 123456789101112131415//분이 넘어거거나 10회째가 될 때까지 5초마다 콜백 실행const start = new Date();let i =0;const intervalId = setInterval(function(){ let now = new Date(); if(now.getMinutes() !== start.getMinutes() || ++i &gt;10) return clearInterval(intervalId); console.log(`${i}:${now}`);},5000);/* 1:Fri Aug 02 2019 13:59:47 GMT+0900 (한국 표준시) 2:Fri Aug 02 2019 13:59:52 GMT+0900 (한국 표준시) 3:Fri Aug 02 2019 13:59:57 GMT+0900 (한국 표준시)*/ setInterval이 ID 값을 반환하므로 이 ID를 써서 실행을 멈출 수 있다. clearInterval이 반환하는 ID값을 받아 타임아웃을 종료 14.2.2 스코프와 비동기적 실행 비동기적 실행에서 혼란스럽고 에러가 자주 일어나는 부분은 스코프와 클로저가 비동기적 실행에 영향을 미치는 부분이다.함수를 호출하면 항상 클로저가 만들어진다. 매개변수를 포함해 함수 안에서 만든 변수는 모두 무언가가 자신에 접근 할 수 있는한 계속 존재 countdown 오류12345678910111213//5초 카운트 다운function countdown(){ let i; //i를 for 루프 밖에서 실행 console.log(\"Countdown\"); for(i=5; i&gt;=0; i--){ setTimeout(function(){ console.log(i===0 ? \"Go\":i) },(5-i)*1000); }}countdown();//-1이 6번 나옴 var가 아닌 let 변수를 for 루프 밖에서 선언했으므로 같은 문제가 발생한다. 즉 for 루프가 실행을 마치고, i의 값이 -1이 된 다음에야 콜백이 실행된다. 여기서 i는 두 가지 방법으로 사용됬다. 1. (5-i)이는 첫번째 타임아웃 : 0 , 두번쨰 : 1000, 세번쨰 : 2000 이렇게 동기적으로 실행된다. countdown 문제해결123456789101112131415161718192021//1. 즉시표현식var count= function(i){console.log(\"Countdown\"); for(let i=5; i&gt;=0; i--){ setTimeout(function(){ console.log(i===0 ? \"Go\":i) },(5-i)*1000); }}();//2. for 루프 안에 let i 선언function countdown(){ // let i; i를 for 루프 밖에서 실행 console.log(\"Countdown\"); for(let i=5; i&gt;=0; i--){ setTimeout(function(){ console.log(i===0 ? \"Go\":i) },(5-i)*1000); }}countdown(); 즉시 호출하는 함수 표현식(IIFE)를 쓰거나, 더 간단하게는 for 루프 선언부에서 let i 를 쓰는 방식으로 해결 가능 콜백은 자신을 선언한 스코프(클로저)에 있는 것에 접근 할 수 있다. 그러므로 i의 값은 콜백이 실행되는 순간마다 다를 수 있다. 이 원칙은 모든 비동기적 테크닉에 적용된다. 14.2.3 우선 오류 콜백 우선 오류 콜백 : 콜백을 사용하면 예외 처리가 어려워 지므로, 콜백과 관련된 에러를 처리할 표준이 필요이에 따라 콜백의 첫 번쨰 매개변수에 에러 객체를 쓰자는 것이 등장에러가 null이나 undefined 이면 에러가 없는 것우선 오류 콜백에서 가장 먼저 생각할 것은에러 매개변수를 체크하고 그에 맞게 반응한다는 것 123456//노드에서 파일 콘텐츠를 읽을 떄 우선 오류 콜백을 사용할 경우const fs = require('fs');const fname = 'may_or_may_not_exist.txt';fs.readFile(fname, function(err,data){ if(err) return console.error(`error reading file ${fname}:${err.message}`);}); 콜백에서 가장 먼저 하는 일은 err 가 참 같은 값인지 확인하는 것 err가 참 같은 값이면 파일을 읽는 데 문제가 있다는 뜻이므로 콘솔에 오류를 보고하고 즉시 빠져나옵니다. 우선 오류 콜백을 사용할때 많이 하는 실수는 빠져나와야 한다는 사실을 잊는 다는 것 프라미스를 사용하지 않으면 우선 오류 콜백은 노드 개발의 표준이나 다름없음 14.2.4 콜백 헬 콜백 헬 : 중괄호로 둘러쌓여 끝없이 중첩된 삼각형의 코드 블록 14.3 프라미스 프라미스 : 콜백의 단점을 해결하려는 시도에서 만들어짐프라미스가 콜백을 대체하는 것은 아니다. 프라미스는 콜백을 예측 가능한 패턴으로 사용할 수 있게 한다. 프라미스 기반 비동기 함수를 호출하면 그 함수는 promise 인스턴스를 반환 성공(fulfilled)하거나, 실패(rejected) 하는 단 두가지 뿐 성공한 프라미스가 나중에 실패할 일 같은 경우는 없음 단 한번만 일어난다. -&gt; 그 프라미스를 결졍됐다(settled)고 한다. 프라미스는 객체이므로 어디든 전달 할수 있다.(음식점에서 받은 예약 호출기를 친구에게 맡기는 것과 비슷) 14.3.1 프라미스 만들기 성공(resolve)와 실패(reject) 콜백이 있는 함수로 새 promise 인스턴스를 만들기만 하면 된다. 1234567891011121314151617181920212223// 5초 카운트 다운에 매이지 않고, 카운트가 끝나면 프라미스를 반환function countdown(seconds){ return new Promise(function(resolve,reject){ for(let i =seconds; i&gt;=0; i--){ setTimeout(function(){ if(i&gt;0) console.log(i + \"...\"); else resolve(console.log(\"GO\")); },(seconds-i)*1000); } });}/*결과5...4...3...2...1...GO만약 이 함수가 실패하면 \"GO\"를 반환*/ resolve와 reject는 함수이다. resolve를 여러번 호출해도 결과는 같다. 첫 번째로 호출한 것만 의미 있다. 프라미스는 성공 또는 실패를 나타낼 뿐이다. 14.3.2 프라미스 사용프라미스 사용(카운트다운)12345678910111213141516171819202122//13을 만나면 에러를 내는 함수function countdown(seconds){ return new Promise(function(resolve,reject){ for(let i =seconds; i&gt;=0; i--){ setTimeout(function(){ if(i === 13) return reject(new Error(\"oh my god\")); if(i&gt;0) console.log(i + \"...\"); else resolve(console.log(\"GO\")); },(seconds-i)*1000); } });}/*15...14...Uncaught (in promise) Error: oh my god12...11...10... 9...*/ 13에서 에러가 발생, 그러나 콘솔에는 12부터 다시 카운트를 기록한다. reject나 resolve가 함수를 멈추지는 않는다. 그저 프라미스의 상태를 관리할 뿐이다. 즉, 프라미스는 비동기적 작업이 성공 또는 실패하도록 확정하지만, 현재는 진행 상황을 전혀 알려주지 않는다. 즉, 프라미스는 완료되거나 파기될 뿐 50% 진행되었다.라는 개념자체가 없다. 14.3.3 이벤트 이벤트가 일어나면 이벤트 발생을 담당하는 개체(emitter)에서 이벤트가 일어났음을 알린다.필요한 이벤트는 모두 주시(listen)할 수 있다. 콜백을 통해서 가능노드에서 이벤트를 지원하는 모듈 EventEmitter가 내장됨EventEmitter는 클래스와 함께 사용하도록 설계 12345678910111213141516171819202122232425262728293031323334353637//countdown 함수를 countdown 클래스로 변경const EventEmitter = require('events').EventEmitter;class Countdown extends EventEmitter{ constructor(seconds,superstitious){ super(); this.seconds = seconds; this.superstitious = !!superstitious; } go(){ const countdown = this; const timeoutIds = []; return new Promise(function(resolve,reject){ for(let i = countdown.seconds; i&gt;=0; i--){ timeoutIds.push(setTimeout(function(){ if(countdown.superstitious &amp;&amp; i ===13){ //대기중인 타임아웃을 모두 취소 timeoutIds.forEach(clearTimeout); return reject(new Error('oh my god')); } countdown.emit('trick',i); if(i === 0) resolve(); },(countdown.seconds-i)*1000)); } }); }}//카운트다운 사용const c = new Countdown(5);c.on('trick',function(i){ if(i&gt;0) console.log(i+\"...\");});c.go().then(function(){ console.log('go');}).catch(function(err){ console.log(err.message);}); EventEmitter를 상속하는 클래스는 이벤트를 발생시킬 수 있다. 실제 카운트다운을 시작하고 프라미스를 반환하는 부분은 go 메서드이다. go메서드에서 1) const countdown = this; 즉 countdown에 this를 할당 2) 카운트가 얼마나 남았는지 알려면 this 값을 알아야한다. 14.3.4 프라미스 체인 프라미스에는 체인으로 연결할 수 있다는 장점이 존재프라미스가 완료되면 다른 프라미스를 반환하는 함수를 즉시 호출 가능 프라미스 체인12345678910111213141516function launch(){ return new Promise(function(resolve,reject){ console.log(\"Lift off\"); setTimeout(function(){ resolve(\"in orbit\"); },5*1000); //2초만에 궤도도달 });}//이 함수를 카운트다운에 쉽게 묶을 수 있다.const c = new Countdown(5).on('trick',i =&gt; console.log(i + \"...\"));c.go().then(launch).then(function(msg){ console.log(msg);}).catch(function(err){ console.error(\"houston, we have a problem...\");}); 프라미스 체인을 사용하면 모든 단계에서 에러를 캐치할 필요가 없다. 체인 어디서든 에러가 생기면 체인 전체가 멈추고 catch 핸들러가 동작한다. 14.3.5 결졍되지 않는 프라미스 방지하기 프라미스는 비동기적 코드를 단순화하고 콜백이 두 번 이상 실행되는 문제를 방지하지만, reslove나 reject를 호출하는 걸 잊어서 프라미스가 결정되지 않는 문제까지 자동으로 해결하지는 못함결정되지 않는 프라미스를 방지하는 방법은 프라미스에 타임아웃을 거는 것 14.4 제너레이터 제너레이터는 함수와 호출자 사이의 양방향 통신을 가능하게 함.제너레이터는 동기적 성격을 지녔지만, 프라미스와 결합하면 비동기 코드를효율적으로 관리 가능 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//파일 3개를 읽고 1분간 기다린 다음 그 내용을 합쳐서 네 번째 파일에 작성//1. 노드의 콜백 오류를 프라미스로 바꾸기 function nfcall(f,...args){ return new Promise(function(resolve,reject){ f.call(null,...args,function(err,...args){ if(err) return reject(err); resolve(args.length&lt;2 ? args[0]:args); }); });}//2. setTimeout을 써야하는데, 이는 오류 우선 콜백 패턴을 따르지 않으므로 같은 기능을 가진 ptimeout(promise timeout) 함수를 만든다.function ptimeout(delay){ return new Promise(function(resolve,reject){ setTimeout(resolve,delay); });}//3. 제너레이터 실행기// 제너레이터는 동기적이지만, 호출자와 통신 가능하므로 제너레이터와의 통신을 관리하고, 비동기적 호출을 처리하는 함수 grun을 만듬 function grun(g){ const it = g(); (function iterate(val){ const x = it.next(val); if(!x.done){ if(x.value instanceof Promise){ x.value.then(iterate).catch(err =&gt; it.throw(err)); }else{ setTimeout(iterate,0,x.value); } } })();}//grun은 제너레이터 실행기이고, yield로 값을 넘긴 제너레이터는 이터레이터에서 next를 호출할 때까지 기다린다. function* theFutureIsNow(){ const dataA = yield nfcall(fs,readFile, \"a.txt\"); const dataB = yield nfcall(fs,readFile, \"b.txt\"); const dataC = yield nfcall(fs,readFile, \"c.txt\"); yield ptimeout(60*1000); yield nfcall(fs.writeFile,\"d.txt\",dataA + dataB + dataC);}grun(theFutureIsNow); 14.4.2 제너레이터 실행기를 직접 만들지 마세요co(link: https://github.com/tj/co) kos 미들웨어(link: https://koajs.com/) 14.4.3 제너레이터 실행기와 예외처리 제너레이터 실행기를 쓰면 try/catch를 써서 예외 처리가 가능콜백이나 프라미스를 사용하면 예외 처리가 쉽지 않다.제너레이터 실행기는 비동기적으로 실행하면서도 동기적인 동작 방식을 유지하므로 try/catch문과 함께 쓸 수 있다. 제너레이터 실행기와 예외처리12345678910111213141516171819202122function* theFutureIsNow(){ let data; try{ data = yield Promise.all([ nfcall(fs.readFile, \"a.txt\"), nfcall(fs.readFile, \"b.txt\"), nfcall(fs.readFile, \"c.txt\"), ]); }catch(err){ console.error(\"unable to read..\" + err.message); throw err; } yield ptimeout(60 * 1000); try{ yield nfcall(js.writeFile, \"d.txt\", data[0] + data[1] + data[2]); } catch(err){ console.err(\"unable to write output file\"+ err.message); throw err; }}grun(theFutureIsNow); 14.5 요약 요약내용 자바스크립트의 비동기적 실행은 콜백을 통해 이루어진다. 프라미스를 콜백 대신 사용할 수 있는 것은 아니다. 프라미스 역시 콜백을 사용 프라미스는 콜백이 여러 번 호출되는 문제를 해결 콜백을 여러 번 호출해야 한다면 이벤트와 결합하는 방법도 있다.(프라미스도 함께 쓸 수 있다.) 프라미시는 반드시 결졍된다는(성공 or 실패한다는) 보장은 없다. 다만 프라미스에 타임아웃을 걸면 이 문제가 해결 프라미스는 체인으로 연결 할 수 있다. 프라미스와 제너레이터 실행기를 결합하면 비동기적 실행의 장점을 유지하면서도 동기적인 사고 방식으로 문제 해결 가능 제너레이터를 써서 동기적인 사고방식으로 문제를 해결 할 땐, 프로그램의 어느 부분에서 동시에 실행할 수 있는지 잘 봐야함. 동시에 실행할 부분은 Promise.all을 써서 실행 제너레이터 실행기 직접 만들지 말기 노드 스타일 콜백을 프라미스로 바꿀 필요도 없다. Q를 써라 제너레이터 실행기를 쓰면 예외 처리도 익숙한 방식으로 할 수 있다.","link":"/2019/08/01/es6_md/chapter14/"},{"title":"chapter20. 노드","text":"20.1 노드의 기초 브라우저 기반 자바스크립트는 브라우저에만 해당하는 API를 사용합니다.노드에는 DOM이 없습니다. HTML이 없으니까요.노드에만 해당하고 브라우저에는 존재하지 않는 API도 있습니다.window와 document는 브라우저 환경에서 제공하는 API 입니다.이 장에서는 노드에서 제공하는 API에 대해 설명합니다. 20.2 모듈 모듈은 패키지를 만들고 코드를 네임스페이스(namespace)로 구분하는 메커니즘이다.네임스페이스는 이름 충돌을 방지하는 방법이다. amanda.js12345678// ## 20.2 모듈//아만다가 만든 calculatefunction calculate(a, x, n) { if (x === 1) return a * n; return (a * (1 - Math.pow(x, n))) / (1 - x);}//내보내기module.exports = calculate; tyler.js1234567// ## 20.2 모듈//타일러가 만든 calculatefunction calculate(r) { return (4 / 3) * Math.PI * Math.pow(r, 3);}//내보내기module.exports = calculate; app.js123456//이들 모듈을 임포트함const amanda_calculate = require(\"./amanda.js\");const tyler_calculate = require(\"./tyler.js\");console.log(amanda_calculate(1, 2, 5)); //31console.log(tyler_calculate(2)); //33.510321638291124 module은 노드에서 모듈을 구현하기 위해 만든 특별한 객체이다. export 프로퍼티에 무엇을 할당하든, 모듈은 그것을 내보낸다. 모듈은 어떤 타입의 값이든 내보낼 수 있다. 20.3 코어 모듈, 파일 모듈, npm 모듈 모듈은 코어 모듈, 파일 모듈, npm 모듈 3가지로 나뉜다.코어 모듈 : fs나 os처럼 노드 자체에서 제공 하는 모듈, 모두 예약어 이다.파일 모듈 : module.exports 에 할당되는 파일을 만들고 그 파일을 불러옴npm 모듈 : 특별한 디렉터리 node_modules에 저장되는 모듈 파일require 함수를 사용하면 노드는 함수의 매개변수를 보고 어떤 타입인지 판단한다. 코어모듈process나 buffer 같은 일부 코어 모듈은 전역이고, 명시적인 require 문 없이도 사용할 수 있다. 모듈에 대한 상세한 API 문서(link: https://nodejs.org/api/) 를 참고 npm 모듈npm 모듈은 특수한 이름 표기법을 사용하는 파일 모듈이다.node_modules 디렉터리에 직접적으로 작업하지말고, 모듈 파일 관련 작업은 npm에서 하도록 해야한다. 20.4 함수 모듈을 통한 모듈 커스터마이징 모듈은 대부분 객체를 내보내지만, 가끔 함수 하나만 내보내기도 한다.이럴 경우 그 모듈의 함수를 즉시 호출하기 위해 사용한다.그 함수가 아닌, 함수가 반환하는 것을 쓰게 한 것이다. 12const debug = require(\"debug\")(\"main\"); //모듈이 반환하는 함수를 즉시 호출 할 수 있다.debug(\"starting\"); //디버그가 활성화되어 있으면 main starting + 0ms라는 로그를 남긴다. debug 모듈이 반환한 것을 즉시 호출했으므로 debug 모듈이 함수를 반환한다는 것을 알 수 있고, 반환값인 함수 역시 함수를 반환하며 최종적으로 반환된 함수는 첫 번째 함수에 넘긴 문자열을 기억한다. 노드는 노드 앱을 실행할 때 어떤 모듈이든 단 한번만 임포트한다. 20.5 파일시스템 접근 자바스크립트는 노드가 만들어지기 전까지는 파일시스템에 접근 할 수 없었다. 파일을 생성하고 쓸 때는 fs.writeFile()을 사용합니다. writeFile1234567//파일 생성하고 쓰기const fs = require(\"fs\");fs.writeFile(\"hello.txt\", \"hello from node!\", function(err) { if (err) { return console.log(\"error\"); }}); write.js 파일을 저장한 디렉터리에 쓰기 권한이 있고, hello.txt 파일이 생성되어 글자가 써진다. 해당 애플리케이션은 자신이 실행된 현재 디렉터리를 __dirname 변수로 보관한다. 이 변수를 사용해서 write.js 파일을 고쳐 쓸 수 있다. __dirname123456789101112const fs = require(\"fs\");fs.writeFile(__dirname + \"/hello.txt\", \"hello from node!\", function(err) { if (err) return console.log(\"error writing to file\");});//path.joinfs.writeFile(path.join(__dirname, \"/hello.txt\"), \"hello from node!\", function( err) { if (err) return console.log(\"error writing to file\");}); 이제 write.js가 있는 디렉터리에 hello.txt를 만든다. __dirname은 특정 운영체제에 따라 호환되지 않을 수 있다. 이럴 경우 노드의 path.join을 사용하면 모든 운영체제에서 호환 가능하다. 파일을 읽을때는 fs.readFile()을 사용합니다. readFile1234567const fs = require(\"fs\");var path = require(\"path\");fs.readFile(path.join(__dirname, \"hello.txt\"), function(err, data) { if (err) return console.error(\"error\"); console.log(\"read file contents\"); console.log(data);}); fs.readFile()는 가공되지 않은 바이너리 데이터인 버퍼를 반환한다. 기본 문자열 인코딩은 UTF-8이다. 인코딩을 지정하면 원하는 결과를 얻을 수 있다. UTF-812345678910111213const fs = require(\"fs\");var path = require(\"path\");fs.readFile(path.join(__dirname, \"hello.txt\"), { encoding: \"utf8\" }, function( err, data) { if (err) return console.error(\"error\"); console.log(\"read file contents\"); console.log(data);});/*결과 : */ 파일 관련 함수에는 모두 동기적으로 작업하는 짝이 있으며,이들 이름은 Sync로 끝난다. 123456789//파일 쓰기fs.writeFileSync(path.join(__dirname, \"hello.txt\"), \"hi\");//try { fs.readFileSync(path.join(__dirname, \"hello.txt\"), \"hi~\");} catch (err) { console.err(\"error\");} 디렉터리에 어떤 파일이 있는지 알아보려면 fs.readdir을 사용합니다. readdir123456const fs = require(\"fs\");fs.readdir(__dirname, function(err, files) { if (err) return console.err(\"err\"); console.log(`${__dirname}:`); console.log(files.map(f =&gt; \"\\t\" + f).join(\"\\n\"));}); fs 모듈에는 이외에도 파일을 지우는 fs.unlink(); 파일을 옮기거나 이름을 바꾸는 fs.rename(), 파일과 디렉터리의 정보를 얻는 fs.stat(),등이 있으며 자세한 정보는 link(https://nodejs.org/api/fs.html) 을 참고 20.6 process 실행 중인 노드 프로그램은 모두 process 변수에 접근 가능이 변수는 해당 프로그램에 관한 정보를 담고 있으며 실행 자체를 컨트롤 할 수 있다.예를 들어, 애플리케이션이 치명적 에러를 만나서 실행하지 않는 편이 좋으면 (fatal error) process.exit를 호출해 즉시 실행을 멈춘다.숫자형 종류 코드를 쓰면 프로그램이 성공적으로 종료됐는지, 에러가 있었는지 외부 스크립트에서 알 수 있다.보통 에러없이 프로그램을 끝냈다면 종료코드 0을 사용한다. 12345678910111213const fs = require(\"fs\");fs.readdir(\"data\", function(err, files) { if (err) { console.error(\"fatal error\"); process.exit(1); } const txtFiles = files.filter(f =&gt; /\\.txt$/i.test(f)); if (txtFiles.length === 0) { console.log(\"no files to process\"); process.exit(0); } //.txt 파일 처리}); process 객체를 통해 프로그램에 전달된 명령줄 매개변수 배열에 접근 할 수도 있다.명령줄 매개변수는 process.argv() 배열에 저장된다. process.env()를 통해 환경 변수에 접근 할 수 있다.환경 변수는 시스템 변수이며 주로 명령줄 프로그램에서 사용한다.export VAR_NAME=value 명령으로 환경변수를 설정할 수 있다.환경변수는 보통 전부 대문자로 표현한다. 123const debug = process.env.DEBUG === \"1\" ? console.log : function() {};debug(\"visible only if environment variable DEBUG is set\"); 이 예제에서 debug 함수는 환경 변수 DEBUG가 1이면 console.log의 별칭이되고, 그렇지 않으면 null 함수가 된다. null 함수를 만들지 않으면 debug 가 정의되지 않는 경우가 생기고, 에러가 발생한다. process.cmd 에서는 현재 작업 디렉터리가 저장되며,process.chdir로 현재 작업 디렉터리로 바꿀 수 있습니다. 123456789//프로그램에서 현재 작업 디렉터리를 호출한다음, 프로그램이 저장된 디렉터리를 현재 작업 디렉터리로 바꾸는 경우console.log(`current directory ${process.cwd()}`);process.chdir(__dirname);console.log(`new directory ${process.cwd()}`);/*current directory C:\\Users\\moong\\Desktop\\소뭉이\\komos_node\\1day\\sunday01new directory C:\\Users\\moong\\Desktop\\소뭉이\\komos_node\\1day\\sunday01*/ 20.7 운영체제 os 모듈은 프로그램을 실행하는 컴퓨터의 운영체제에 관한 정보를 제공합니다. os모듈12345678910111213141516171819202122const os = require(\"os\");console.log(\"hostname:\" + os.hostname());console.log(\"os type:\" + os.type());console.log(\"os platform:\" + os.platform());console.log(\"os release:\" + os.release());console.log(\"cpu uptime:\" + (os.uptime() / 60 / 60 / 24).toFixed(1));console.log(\"cpu architecture:\" + os.arch());console.log(\"cpu 갯수:\" + os.cpus().length);console.log(\"총 메모리:\" + (os.totalmem() / 1e6).toFixed(1));console.log(\"여유 메모리:\" + (os.freemem() / 1e6).toFixed(1));/*hostname:DESKTOP-EN75874os type:Windows_NTos platform:win32os release:10.0.17763cpu uptime:7.0cpu architecture:x64cpu 갯수:8총 메모리:8458.6여유 메모리:3421.3Program exited with code 0*/ 20.8 자식 프로세스 child_process 모듈은 애플리케이션에서 다른 프로그램을 실행할 때 사용.주요함수는 exec, execFile,fork 입니다.exec와 execFile은 운영체제에서 지원하는 실행파일은 무엇이든 실행할 수 있습니다.exec는 명령줄에서 실행할 수 있는 것은 다 실행할 수 있다.execFile은 셸을 통하지 않고 실행파일을 직접 실행하므로 효율적이지만 더 주의해야 할 점이 있다.fork는 다른 노드스크립트를 실행할 때 사용한다 1234567891011121314151617181920212223242526272829303132333435const exec = require(\"child_process\").exec;exec(\"dir\", function(err, stdout, stderr) { if (err) return console.err('error execiting \"dir\"'); stdout = stdout.toString(); //Buffer을 문자열로 바꿈 console.log(stdout); stderr = stderr.toString(); if (stderr !== \"\") { console.error(\"error:\"); console.error(stderr); }});/*호출결과 Command: node \"C:/Users/moong/Desktop/소뭉이/komos_node/1day/sunday01/linecount.js\" Volume in drive C has no label. Volume Serial Number is F8DB-AEAD Directory of C:\\Users\\moong\\Desktop\\소뭉이\\komos_node\\1day\\sunday012019-08-26 오후 11:27 .2019-08-26 오후 11:27 ..2019-08-26 오후 10:24 132 hello.js2019-08-26 오후 10:49 3 hello.txt2019-08-30 오후 08:51 368 linecount.js2019-08-26 오후 09:46 node_modules2019-08-26 오후 09:46 19,130 package-lock.json2019-08-26 오후 09:46 278 package.json2019-08-26 오후 10:49 389 read.js 6 File(s) 20,300 bytes 3 Dir(s) 139,629,719,552 bytes freeProgram exited with code 0*/ 20.9 스트림 스트림은 스트림 형태의 데이터를 다루는 객체이다.스트림은 흐름같은 느낌이고, 흐름은 비동기적으로 이루워질것이라 짐작됨스트림에서는 읽기(read) 스트림, 쓰기(write) 스트림, 이중(duplex) 스트림이 있다. 쓰기 스트림123456789101112const fs = require(\"fs\");const ws = fs.createWriteStream(\"stream.txt\", { encoding: \"utf8\" });ws.write(\"line1\\n\");ws.write(\"line2\\n\");ws.end();/*결과stream.txt 생성line1line2라는 텍스트가 써짐*/ end()를 호출해서 쓰기 스트림(ws)를 종료하기 전까진 write 메서드를 통해 스트림에 쓸 수 있다.end를 호출한 다음 write를 호출하면 에러가 발생한다. 마찬가지로 읽기 스트림을 만들어서 들어오는 데이터를 읽을 수도 있다. 123456789101112131415161718192021const fs = require(\"fs\");const ws = fs.createWriteStream(\"stream.txt\", { encoding: \"utf8\" });ws.write(\"line1\\n\");ws.write(\"line2\\n\");ws.end();const rs = fs.createReadStream(\"stream.txt\", { encoding: \"utf8\" });rs.on(\"data\", function(data) { //줄바꿈 문자 이스케이프 console.log(\"&gt;&gt; data :\" + data.replace(\"\\n\", \"\\\\n\"));});rs.on(\"end\", function(data) { console.log(\"&gt;&gt; end\");});/*호출결과&gt;&gt; data :line1\\n&gt;&gt; data :line2\\n&gt;&gt; end*/ 데이터가 스트림을 ‘흐른다’는 표현을 보면 읽기 스트림에서 데이터를 읽는 즉시 쓰기 스트림에서 쓸 수 있다. 이런 작업을 파이프(pipe)라고 한다.예를 들어, 읽기 스트림과 쓰기 스트림을 파이프로 연결하면 파일 콘텐츠를 복사하는 효과가 있다. 123456const fs = require(\"fs\");const rs = fs.createReadStream(\"stream.txt\");const ws = fs.createWriteStream(\"stream_copy.txt\");rs.pipe(ws);//stream.txt에 있는 내용을 읽어서 stream_copy.txt를 생성하고 그 내용을 복사함 위 예제는 따로 인코딩을 명시할 필요없이 rs는 그냥 stream.txt의 데이터를 ws 파이프에 연결하고, ws는 그 데이터를 그대로 steam_copy.txt에 기록할 뿐이다. 20.10 웹서버 노드는 원래 웹서버를 만드는 것이 목적이였다.http 모듈(보안 연결을 제공하는 https 모듈 역시)에는 기본적인 웹 서버를 만드는 createServer 메서드가 있다.들어오는 요청을 처리할 콜백 함수만 만들면 된다.서버를 시작할 떈 listen 메서드를 호출하면 포트를 지정한다. 웹서버1234567891011121314151617const http = require(\"http\");const server = http.createServer(function(req, res) { console.log(`${req.method} ${req.url}`); res.end(\"hello world\");});const port = 8080;server.listen(port, function() { console.log(`server started on port ${port}`); //server started on port 8080});/*node cmd 에 찍히는 화면GET /GET /favicon.ico*/ 노드를 실행하면, 브라우저 http://localhost:8080/ 에 hello world가 보인다. 터미널을 보면 모든 요청이 기록되어 있다. 요청은 메서드(여기서는 GET)과 URL 경로로 구성된다. 브라우저에서 그 URL을 방문할 때마다 요청 두 개가 기록되는 것을 보고 의이할 수 있다. 대부분의 브라우저는 요청을 보낼 때 url 막대 또는 탭에 표시할 아이콘인 파비콘을 요청한다. 노드 웹 서버서의 핵심은 들어오는 요청에 모두 응답하는 콜백함수 이다.이 함수는 매개변수로 IncomingMessage객체(req)와 **ServerRequest객체(res)를 받는다.IncomingMessage 객체에는 요청받은 url, 보낸 헤더, 바디에 들어있던 데이터 등 http 요청에 관한 모든 정보가 들어있다.ServerResponse 객체에는 클라이언트(보통 브라우저)에 보낼 응답을 컨트롤하는 프로퍼티와 메서드가 들어있다.ServerResponse 객체는 쓰기 스트림 인터페이스이며, 이를 통해 데이터 클라이언트에 보낸다. 12345678910const server = http.createServer(function(req, res) { if (req.method === \"GET\" &amp;&amp; req.url === \"favicon.ico\") { const fs = require(\"fs\"); fs.createReadStream(\"favicon.ico\"); fs.pipe(res); //end 대신 사용할 수 있다. } else { console.log(`${req.method} ${req.url}`); res.end(\"hello world\"); }}); 20.11 요약 fs,Buffer, process, stream 등 거의 모든 애플리케이션에서 사용하는 API는 이 장에서 소개했지만, 그외에 알아야할 API는 공식문서를 참고link(https://nodejs.org/en/docs/)","link":"/2019/08/20/es6_md/chapter20/"},{"title":"chapter8. 배열과 배열 처리","text":"8.1 배열의 기초 1) 배열은 객체와 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다.2) 자바스크립트 배열은 비균질적입니다. 즉 한 배열의 요소가 모두 같은 타입일 필요는 없습니다.다른 배열이나 객체도 포함 할 수 있습니다.3) 배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근할 때도 대괄호[]를 사용합니다.4) 모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다.5) 배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하면 배열은 자동으로 그 인덱스에 맞게 늘어나며,빈 자리는 undefined로 채워집니다.6) Array 생성자를 써서 배열을 만들수도 있습니다.(별로 사용하진 않음) 1234567891011121314151617181920212223242526272829303132333435363738394041//배열 리터럴const arr1 = [1,2,3]; //숫자배열const arr2 = [\"one\",2,\"three\"] //비균질적 배열const arr3 = [[1,2,3], [\"one\",2,\"three\"]]//배열을 포함한 배열const arr4 = [ //비균질적 배열 {name :\"Fred\",type :\"object\", luckyNumbers=[5,7,13] },[ {name :\"Susan\",type:\"object\"}, {name :\"Anthony\",type:\"object\"},],1,function(){return 'arrays can contain functions too'},\"three\",]; //배열 요소에 접근하기arr1[0]; //1arr1[2]; //3arr3[1] //[\"one\",2,\"three\"]arr4[1][0] //{name :\"Susan\",type:\"object\"} //배열 길이arr1.length; //3arr4.length; //5arr4[1].length //2 //배열 길이 늘리기 arr1[4] = 5; //[1, 2, 3, undefined, 5]arr1.length // 5 //배열의 현재 길이보다 큰 인덱스에 접근하는 것 만으로는 길이가 늘어나지 않음arr2[10];//undefined;arr2.length //3 //Array 생성자 const arr5 = new Array(); //빈 배열 생성 const arr6 = new Array(1,2,3) //[1,2,3]const arr7 = new Array(2) //(2) [empty × 2] 길이가 2개인 빈 배열 const arr8 = new Array(\"2\");//[\"2\"]; 8.2 배열 요소 조작 배열 메서드 중 일부는 배열 ‘자체를’ 수정하며, 다른 일부는 새 배열을 반환한다. push : 배열 자체를 수정 concat : 새 배열을 반환 8.2.1 배열의 처음이나 끝에서 요소 하나를 추가하거나 제거하기 배열의 처음 : 인덱스가 0인 요소배열의 끝 : 인덱스가 가장 큰 요소 arr.length - 1인 요소 push() : 배열의 끝에서 요소를 추가 pop() : 배열의 끝에서 요소를 제거 ※ 데이터를 수직으로 쌓아올리는 스택 stack 에 해당하는 행동 shift() : 배열의 앞에서 요소를 제거 unshift() : 베열의앞에서 요소를 추가 ※ 대기열과 비슷한 큐 stack 에 해당하는 행동 12345const arr = [\"b\",\"c\",\"d\"];arr.push(\"e\"); //arr = [\"b\",\"c\",\"d\",\"e\"];arr.pop(); // arr = [\"b\",\"c\",\"d\"];arr.unshift(\"a\"); // arr = [\"a\",\"b\",\"c\",\"d\"];arr.shift();//arr = [\"b\",\"c\",\"d\"]; 8.2.3 배열 일부 가져오기 *slice(a,b) : *배열의 일부를 가져옴 a : 어디서부터 가져올지, b : 어디까지 가져올지(바로 앞 인덱스까지) 지정 두번째 매개변수를 생략하면 배열의 마지막까지 반환음수 인덱스를 쓸수 있고, 음수 인덱스를 쓰면 배열의 끝에서부터 요소를 센다. slice12345678//sliceconst arr = [1,2,3,4,5];arr.slice(3); // [4,5]arr.slice(2,4); //[3,4]arr.slice(-2); //[4,5]arr.slice(1,-2); //[2,3]arr.slice(-2,-1); //[4]//arr는 바뀌지 않는다. 8.2.4 임의의 위치에 요소 추가하거나 제거하기 splice(a,b,c) : 배열을 수정 a : 수정을 시작할 인덱스 , b: 제거할 요소 숫자 (아무것도 제거하지 않을땐 0 ) c : 배열에 추가될 요소 splice123456//splice const arr = [1,5,7];arr.splice(1,0,2,3,4); //[1,2,3,4,5,7];arr.splice(5,0,6); //[1,2,3,4,5,6,7];arr.splice(1,2); // [1,4,5,6,7];arr.splice(2,1,\"a\",\"b\"); // [1,4,\"a\",\"b\",6,7]; 8.2.5 배열 안에서 요소 교체하기 copyWithin(a,b,c) : ES6에서 새로도입한 메서드 a : 복사한 요소를 붙여넣을 위치 b : 복사할 위치 c : 복사를 끝낼 위치 (생략가능) slice과 마찬가지로 음수 인덱스를 사용하면 배열의 끝에서 부터 센다. 12345678910111213141516171819202122//copywithinconst arr = [1,2,3,4];arr.copyWithin(1,2);//[1, 3, 4, 4]arr.copyWithin(2,0,2);//[1, 3, 1, 3]arr.copyWithin(0,-3,-1); //[3, 1, 1, 3]``` ## 8.2.6 특정 값으로 배열 채우기* **fill()**: 정해진 값으로 배열을 채움 크기를 지정해서 배열을 생성하는 Array 생성자와 아주 잘 어울림 배열의 일부만 채우려고 할때는 시작 인덱스와 끝 인덱스를 지정 음수 인덱스도 사용할 수 있다. ```javascript fill //fill const arr = new Array(5).fill(1);//[1,1,1,1,1]; arr.fill(\"a\"); // [\"a\", \"a\", \"a\", \"a\", \"a\"] arr.fill(\"b\",1);//[\"a\", \"b\", \"b\", \"b\", \"b\"] arr.fill(\"c\",2,4);//[\"a\", \"b\", \"c\", \"c\", \"b\"] arr.fill(5.5,-4); //[\"a\", 5.5, 5.5, 5.5, 5.5] arr.fill(0,-3,-1); //[\"a\", 5.5, 0, 0, 5.5] reverse() : 배열의 요소를 반대로 바꿈 sort() : sort는 배열의 요소의 순서를 정렬 (오름차순) reverse&sort1234567//reverse const arr = [1,2,3,4,5]; arr.reverse(); // [5,4,3,2,1] //sort const arr = [5,3,2,4,1]; arr.sort(); // [1,2,3,4,5]; 8.3 배열 검색 indexOf() : 찾고자 하는 것과 정확히 일치(===)하는 첫 번째 요소의 인덱스를 반환 lastIndexOf() : 배열의 끝에서부터 검색 배열의 일부분을 검색하려면 시작 인덱스를 지정 일치하는 것을 못찾으면 -1을 반환 indexOf1234567891011121314151617//indexOf const o = {name : \"Jerry\"};const arr = [1,5,\"a\",o,true,5,[1,2],\"9\"];arr.indexOf(5);//1arr.lastIndexOf(5);//5arr.indexOf(\"a\"); //2arr.lastIndexOf(\"a\"); //2arr.indexOf( {name : \"Jerry\"} ); //-1arr.indexOf(o); //3arr.indexOf([1,2]); //-1arr.indexOf(\"9\"); //7arr.indexOf(9); //-1 arr.indexOf(\"a\",5) //-1arr.indexOf(5,5) //5arr.lastIndexOf(5,4) //1arr.lastIndexOf(true,3) //-1순으로 정렬 findIndex() : 보조함수를 써서 검색 조건을 지정할 수 있다. 하지만 검색을 시작할 인덱스를 지정할 수 없고, 뒤에서 부터 찾을 수도 없다. findIndex123456findIndexconst arr = [{id : 5 , name: \"Judith\"}, {id : 7 , name: \"Francis\"}];arr.findIndex(o =&gt; o.id===5); //0arr.findIndex(o =&gt; o.name ==='Francis'); //1 arr.findIndex(o =&gt; o ===3); //-1arr.findIndex(o =&gt; o.id ===17); //-1 find() : indexOf와 findIndexOf()는 조건에 맞는 요소의 인덱스를 찾을 때 알맞지만, 요소의 인덱스가 아닌 요소 자체를 찾을때 조건에 맞는 요소가 없을 때 undefined를 반환 find123const arr = [{id : 5 , name: \"Judith\"}, {id : 7 , name: \"Francis\"}];arr.find(o =&gt; o.id===5); //{id: 5, name: \"Judith\"}arr.find(o =&gt; o.id===2); //undefined find와 findIndex에 전달하는 함수는 배열의 각 요소를 첫번째 매개변수로 받고,현재 요소의 인덱스와 배열 자체도 매개변수로 받는다. 특정 인덱스보다 뒤에 있는 제곱수를 찾아야 한다. 12const arr = [1,17,16,5,4,16,10,3,49];arr.find((x,i) =&gt; i &gt;2 &amp;&amp; Number.isInteger(Math.sqrt(x))); find와 findIndex에 전달하는 함수의 this도 수정 할 수 있다. 함수가 객체의 메서드인 것처럼 호출 할 수 있다. 간혹, 조건을 만족하는 요소의 인덱스나 요소 자체가 아닌, 단순히 조건을 만족하는 요소가 있는지 없는지만 알아도 될때 some() : 조건에 맞는 요소를 찾으면 즉시 검색을 멈추고 true 를 반환, 찾지 못하면 false를 반환 every() : 배열의 모든 요소가 조건에 맞아야 true를 반환하며, 그렇지 않으면 false를 반환 조건에 맞지 않은 요소를 찾아야만 검색을 멈추고 false를 반환 some&every123456789//someconst arr = [5,7,12,15,17];arr.some(x =&gt; x%2 ===0); //짝수 찾기 12가 짝수이므로 truearr.some(x =&gt; Number.isInteger(Math.sqrt(x))); //제곱수 false //everyconst arr = [4,6,16,36];arr.every(x =&gt; x%2 ===0); //짝수찾기 모든 요소가 짝수 true arr.every(x =&gt; Number.isInteger(Math.sqrt(x))); //false 6이 제곱수가 아님 8.4 map과 filter map(a,i) : 배열 요소를 변형 , 사본을 반환하며 원래 배열은 바뀌지 않는다. a : 요소 i :인덱스 filter() : 배열에서 필요한 것들만 남김, 사본을 반환하며 새 배열에는 필요한 요소만 남음 map&filter12345678910111213141516171819202122232425262728293031323334353637383940//mapconst cart =[{name : 'Widget',price : 9.95},{name : 'Gadget',price : 22.95}];const names = cart.map(x =&gt; x.name); // ['Widget','Gadget'];const prices = cart.map(x =&gt; x.price); // [9.95,22.95];const disCountPrices = prices.map(x =&gt; x*0.8); //[7.96,18.36]; //filterconst cards = [];for(let suit of [\"H\",\"C\",\"D\",\"S\"]) for(let value=1; value&lt;=13; value++) cards.push({suit,value}); //value가 2인 카드cards.filter(c =&gt; c.value ===2);/*[0: {suit: \"H\", value: 2}1: {suit: \"C\", value: 2}2: {suit: \"D\", value: 2}3: {suit: \"S\", value: 2}]*/ //다이아몬드cards.filter(c =&gt; c.suit ===\"D\"); //length = 13 //킹,퀸,주니어cards.filter(c =&gt; c.value &gt; 10); //length = 12 //하트의 킹,퀸,주니어cards.filter(c =&gt; c.suit ===\"H\" &amp;&amp; c.value&gt; 10); //length = 12/*[0: {suit: \"H\", value: 11}1: {suit: \"H\", value: 12}2: {suit: \"H\", value: 13}length: 3]*/ 8.5 배열의 마법 reduce reduce(a,b,i) : 배열 자체를 변형, 배열을 값 하나로 줄이는데 쓰임 a : 누적값 b: 현재값 i : 인덱스 예) 배열에 들어있는 숫자를 더하거나, 평균을 구하는 것 배열의 값을 하나로 줄이는 동작 reduce가 반환하는 값 하나는 객체일 수도 있고, 다른 배열일 수도 있다. 1. map과 filter와 마찬가지로 콜백 함수를 받는다. 2. reduce가 받는 첫 번째 매개변수는 배열이 줄어드는 대상인 어큐물레이터이다. 3. reduce는 초기값도 옵션으로 받을 수 있다. reduce12const arr = [5,7,2,4];const sum = arr.reduce((a,x)=&gt; a +=x,0); //sum =18 reduce의 콜백함수는 매개변수로 누적값 a와 현재배열요소 x를 받음 누적값 : 0 으로 시작 12const arr = [5,7,2,4];const sum = arr.reduce((a,x)=&gt; a +=x); //sum =18 위 처럼 첫번째 배열 요소가 그대로 초기값이 될 경우에는 초기값을 생략해도된다. reduce는 보통 숫자나 원시 값을 누적값으로 사용하지만, 객체 또한 누적값이 될 수 있다. 예)영단어로 이뤄진 배열이 있고, 각 단어를 첫 글자에 따라 묶는 예제 12345678910111213141516//영단어로 이뤄진 배열이 있고, 각 단어를 첫 글자에 따라 묶는 예제 const words = [\"Beachball\",\"Redeo\",\"Angel\",\"Adrdvark\",\"Xylphone\"];const alphabetical = words.reduce((a,x) =&gt; { if(!a[x[0]]) a[x[0]] =[]; a[x[0]].push(x); return a;}, {}); /*{B: Array(1), R: Array(1), A: Array(2), X: Array(1)}A: (2) [\"Angel\", \"Adrdvark\"]B: [\"Beachball\"]R: [\"Redeo\"]X: [\"Xylphone\"] */ 1. 배열의 모든 요소에서 콜백 함수는 전 단계의 결과에 이 단어의 첫번째 글자인 프로퍼티가 있는지 확인 2. 그런 프로퍼티가 없다면 빈 배열을 추가 예) 문자열을 누적값으로 사용 123456789101112const words = [\"Beachball\",\"Redeo\",\"Angel\",\"Adrdvark\",\"Xylphone\"]; const longWords = words.reduce((a,w)=&gt; w.length &gt; 6 ? a + \" \" : a ,\"\" ).trim(); //trim() : 문자열 좌우 공백제거 메서드/* longWords \"Beachball Adrdvark Xylphone\" */ 8.6 삭제되거나 정의되지 않은 요소들&gt; Array 메서드에서, 삭제되거나 정의되지 않은 요소들에서 이상하게 동작하기도 한다. map,filter,reduce는 삭제되거나 정의되지 않는 요소들에서 콜백함수를 호출하지 않는다. 123456789//삭제되거나 정의되지 않은 요소들 const arr = Array(10).map(function(x){return 5}); /*//arr//(10) [empty × 10]*///arr는 전부 undefined 123456const arr = [1,2,3,4,5];delete arr[2]; //arr : (5) [1, 2, empty, 4, 5]arr.map(x =&gt; 0); //[0,0,undefined,0,0]//(5) [0, 0, empty, 0, 0]//배열 중간 요소를 삭제하고 map을 호출하면 가운데 구멍이 생김 8.7 문자열 병합 Array.prototype.join() : 매개변수로 구분자 하나를 받고 요소들을 하나로 합친 문자열을 반환 매개변수가 생략되면 기본값은 쉼표(,) 정의되지 않은 요소, 삭제된 요소,null,undefined 모두 빈 문자열로 취급한다. 123456//문자열 병합 const arr = [1,null,\"hello\",\"world\",true,undefined];delete arr[3];arr.join(); //\"1,,hello,,true,\" arr.join(''); //\"1hellotrue\"arr.join(' -- '); //\"1 -- -- hello -- -- true -- \" *8.8 요약 * 표 8-1 배열 함수의 매개변수(순서대로) 메서드설명reduce에만 적용누적값, 초깃값 또는 마지막 호출에서 반환한 값모든 메서드요소(현재 요소의 값)모든 메서드현재 요소의 인덱스모든 메서드배열 자체(그다지 쓸모는 없음) 콜백을 받는 메서드들은 옵션으로 콜백을 호출할 때 this로 사용한 값을 받을 수 있다. 표 8-2 배열 콘텐츠 조작 하고 싶은 일사용할 메서드수정 또는 사본스택(후입 선출)을 만들때push(바뀐 길이 반환), pop배열 수정큐(선입 선출)을 만들때&nbsp;unshift(바뀐 길이 반환),shift배열 수정여러 요소를 배열 마지막에 추가할 때concat사본 반환배열 일부가 필요할 때slice사본반환임위의 위치에 요소를 추가하거나 제거splice배열 수정배열 안에서 요소를 교체copyWithin배열 수정배열을 채울 때fill배열 수정배열 반대 정렬reverse배열 수정배열 정렬sort(정렬 함수 사용 가능)배열 수정&nbsp; 표 8-3 배열 검색 찾고자 하는 것사용할 메서드요소의 인덱스indexOf(단순한 값), findIndex(복잡한 값)인덱스를 뒤에서 부터 찾을 때lastIndexOf(단순한 값)요소 자체find조건을 만족하는 요소가 들어 있는지 확인some모든 요소가 그 조건을 만족하는지 확인every 표 8-4 배열 변형 하고 싶은 일사용할 메서드수정 또는 사본배열의 모든 요소를 변형map사본 반환조건에 맞는 요소만 남김fill사본 반환배열 전체를 다른 데이터 타입으로 변형reduce사본 반환요소를 문자열로 바꿔서 하나로 합침join&nbsp;사본 반환&nbsp; [##Image|kage@FQF0t/btqwDJ8nvzH/toKJ3Ysq9UFUuAszaHgM0k/img.jpg|alignCenter|data-filename=”B2328850940_l.jpg” width=”154” height=”198”|러닝 자바스크립트##]","link":"/2019/07/15/es6_md/chapter8/"},{"title":"react chapter3. 컴포넌트 (리액트를 다루는 기술)","text":"클래스형 컴포넌트, 함수형 컴포넌트, props, state, state를 사용할때 주의사항 등을 알아본다. 3.1 클래스형 컴포넌트 함수형 컴포넌트는 다음과 같은 구조로 이루어져 있다. App.js 함수형 컴포넌트123456789import React from 'react';//함수형 컴포넌트function App(){ const name =\"리액트\"; return &lt;div className=\"react\"&gt;{name}&lt;/div&gt;}export default App; 컴포넌트는 함수형 컴포넌트와 클래스형 컴포넌트로 선언할 수 있다. 클래스형 컴포넌트는 다음과 같은 구조이다. App.js 클래스형 컴포넌트123456789import React, { Component } from 'react';//클래스형 컴포넌트class App extend Component{ const name =\"리액트\"; return &lt;div className=\"react\"&gt;{name}&lt;/div&gt;}export default App; 클래스형 컴포넌트로 바뀌었지만 둘의 기능은 똑같다.이 둘의 차이점은 클래스형 컴포넌트는 state 기능 및 라이프사이클(life cycle)을 사용가능하다는 것과 임의 메서드를 정의할 수 있다는 것이다.클래스형 컴포넌트에서는 render 함수가 꼭 있어야하고, 그 안에 보여줄 JSX를 반환해야한다. 리액트 메뉴얼에서는 함수형 컴포넌트와 hooks를 사용하기를 권장하지만 함수형 컴포넌트도 장단점이 존재한다. 함수형 컴포넌트 장점 : 선언하기가 편하다, 메모리 자원을 덜 사용한다, 프로젝트 빌드 후 배포할때 파일 크기가 더 작다.함수형 컴포넌트 단점 : state와 라이프사이클 API 사용이 불가능하다(이 점은 리액트 v16.8 업데이트 후 Hooks 라는 기능이 도입되면서 해결) 3.2 첫 컴포넌트 생성 파일만들기 -&gt; 코드 작성 -&gt; 모듈내보내기 및 불러오기 MyComponent.js1234567891011//hello-react\\src\\MyComponent.js//모듈 불러오기(import)import React from 'react';const MyComponent = () =&gt; { return (&lt;div&gt; 나의 새롭고 멋진 컴포넌트&lt;/div&gt; );};//모듈 내보내기export default MyComponent; function 키워드 사용대신 () =&gt; {} 를 사용함 이는 ES6에서 도입된 화살표 함수 문법임 노트 ES6 화살표 함수 화살표 함수는 ES6 문법에서 함수를 표현하는 새로운 방식이다. 이 문법은 주로 함수를 파라미터로 전달할 때 유용하다.이 문법이 기존 function을 대체할 수 없는 이유는 서로 가리키는 this의 값이 다르기 때문이다. function vs 화살표12345678910111213141516171819202122232425function BlackDog() { this.name = \"흰둥이\"; return { name: \"검둥이\", bark: function () { console.log(this.name + \"명멍\"); } }}const blackDog = new BlackDog();blackDog.dark(); //검둥이 멍멍function WhiteDog() { this.name = \"흰둥이\"; return { name: \"검둥이\", bark: () =&gt; { console.log(this.name + \"명멍\"); } }}const whiteDog = new WhiteDog();whiteDog.dark();//흰둥이 멍멍 일반 함수는 자신이 종속된 객체를 this로 가리키며, 화살표 함수는 자신이 종속된 인스턴스를 가리킨다. 노트 ReactJS Code Snippet 사용 vs code 에서 ReactJS Code Snippet 확장팩 설치후 에디터에 rsc를 입력하면알아서 react 컴포넌트 코드가 생성됨rsc -&gt; 함수형 컴포넌트 생성rcc - &gt; 클래스형 컴포넌트 생성 3.2.2 모듈 불러오기(import)App.js12345678import React from 'react';import MyComponent from './MyComponent';const App = () =&gt; { return &lt;MyComponent /&gt;;};export default App; 3.3 props props는 컴포넌트 속성을 설정할때 사용하는 요소이다.props 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트 (현 상황에서는 App.js가 부모 컴포넌트임)에서 설정 가능하다. 3.3.1 JSX 내부에서 props 랜더링 MyComponent 수정해서 해당 컴포넌트에서 name이라는 props를 랜더링하도록 설정한다. MyComponent.js1234567891011//hello-react\\src\\MyComponent.js//모듈 불러오기(import)import React from 'react';const MyComponent = props =&gt; { return (&lt;div&gt;안녕하세요, 제 이름은 {props.name} 입니다.&lt;/div&gt; );};//모듈 내보내기export default MyComponent; App.js 컴포넌트에서 MyComponent의 props의 값을 지정한다. App.js12345678import React from 'react';import MyComponent from './MyComponent';const App = () =&gt; { return &lt;MyComponent name=\"soo\"/&gt;;};export default App; 3.3.3 props 기본값 설정 : defaultProps name 값을 부모 컴포넌트에서 지정해주지 않으면 name 값이 안나타나므로“안녕하세요, 제 이름은 입니다.” 로 나온다.지금처럼 props 값을 지정하지 않을때 보여줄 기본값을 설정하는 defaultProps는 다음과 같다. defaultProps12345678910111213import React from 'react';const MyComponent = props =&gt; { return (&lt;div&gt;안녕하세요, 제 이름은 {props.name} 입니다.&lt;/div&gt; );};//기본설정하기MyComponent.defaultProps ={ name : \"기본이름\"}export default MyComponent; 3.3.4 태그 사이의 내용을 보여주는 children 리액트 컴포넌트를 사용할 떄, 컴포넌트 태그 사이에 내용을 보여주는 props가 있는데 children 이라고 한다. App.js12345678import React from 'react';import MyComponent from './MyComponent';const App = () =&gt; { return &lt;MyComponent&gt;자식&lt;/MyComponent&gt;;};export default App; 위에서 MyComponent 사이에 작성한 ‘자식’이란 문자열을 MyComponent 내부에서 보여주려면 props.children을 사용한다. MyComponent.js1234567891011121314151617import React from 'react';const MyComponent = props =&gt; { return (&lt;div&gt;안녕하세요, 제 이름은 {props.name} 입니다. children의 값은 {props.children} 입니다. &lt;/div&gt; );};/* 안녕하세요, 제 이름은 기본이름 입니다. children의 값은 자식입니다.*/(...)export default MyComponent; 3.3.5 비구조화 할당 문법을 통해 내부 props 값 추출하기 MyComponent 에서 props 값을 조회할 때마다 props.name 과 같이 props.를 붙여주고 있는데, 이러한 작업을 더 편하게 하기 위해 ES6의 비구조화 할당 문법을 사용하여 내부 값을 추출할 수 있다. MyComponent.js12345678910111213141516//MyComponent.js 수정import React from 'react';const MyComponent = props =&gt; { //비구조화 할당 const {name , children} = props;return (&lt;div&gt;안녕하세요, 제 이름은 {name} 입니다. children의 값은 {children} 입니다. &lt;/div&gt; );};(...)export default MyComponent; 다음과 같이도 수정 가능하다. MyComponent.js123456789101112//MyComponent.js 수정import React from 'react';const MyComponent = ({name , children}) =&gt; {return (&lt;div&gt;안녕하세요, 제 이름은 {name} 입니다. children의 값은 {children} 입니다. &lt;/div&gt; );};(...)export default MyComponent; 3.3.6 propTypes를 통한 props 검증 props에 타입을 지정할때는 propTypes를 사용한다.propTypes를 사용하기 위해서는 import 구문을 사용하여 불러와야 한다. MyComponent.js1234567891011121314import React from 'react';//propsType 불러오기import PropTypes from 'prop-types';const MyComponent = ({name , children}) =&gt; {return (...)};//props타입 지정MyComponent.propTypes = { name : PropTypes.string //문자열으로 타입을 지정, name의 값은 무조건 문자열로 전달해야한다.}export default MyComponent; name에 값을 문자열이 아닌 다른값(ex)숫자)로 전달하면 값은 나오지만, 개발자 도구 console탭에서 오류를 알려준다. 3.3.6.1 isRequired를 사용하여 필수 propTypes 설정 propTypes를 지정하지 않았을 때 경고 메시지 등을 띄어주기 위해 isRequired를사용한다.필수 propTypes를 지정할 때 사용 MyComponent.js123456789101112131415161718192021import React from 'react';//propsType 불러오기import PropTypes from 'prop-types';const MyComponent = ({name ,favoriteNumber, children}) =&gt; {return (&lt;div&gt;안녕하세요, 제 이름은 {name} 입니다. children의 값은 {children} 입니다. &lt;br/&gt; 제가 좋아하는 숫자는 {favoriteNumber}입니다. &lt;/div&gt; );};//props타입 지정MyComponent.propTypes = { name : PropTypes.string //문자열으로 타입을 지정, name의 값은 무조건 문자열로 전달해야한다. favoriteNumber : propTypes.number.isRequired}export default MyComponent; favoriteNumber의 값을 설정하지 않았으므로 개발자 도구에 오류가 발생하게된다. App.js12345678910import React from 'react';import MyComponent from './MyComponent';const App = () =&gt; {//App.js에서 favoriteNumber의 값을 불러옴 return &lt;MyComponent favoriteNumber={1}&gt;자식&lt;/MyComponent&gt;;};export default App; 더 많은 PropTypes의 종류들다음과 같은 것들이 PropTypes의 종류가 될 수 있다. array : 배열 arrayOf : 특정 propType으로 이루어진 배열 bool : true or false 값 func : 함수 object : 객체 number : 숫자 string : 문자 symbol : ES6의 Symbol node : 랜더링 할 수 있는 모든 것 (숫자, 문자열, JSX 등등) instanceOf(클래스) : 특정 클래스의 인스턴스 oneOf([‘dog’,’cat’]) : 주어진 배열 요소 값 중 하나 oneOfType([React.PropTypes.string, PropTypes.number]) : 주어진 배열 안의 종류 중 하나 objectOf(React.PropTypes.number): 객체의 모든 키 값이 인자로 주어진 propType인 객체 shape({name : PropTypes.string, num : PropTypes.number}) : 주어진 스키마를 가진 객체 any : 아무 종류 더 자세한 정보는 link: https://github.com/facebook/prop-types 에서 확인 가능 3.3.7 클래스형 컴포넌트에서 props 사용하기 클래스형 컴포넌트에서 props를 사용할땐, render 함수에서 this.props를 조회하면 된다. MyComponent.js123456789101112131415161718192021222324252627282930import React, { Component } from 'react';import propTypes from 'prop-types';class MyCompoenet extends Component { render() { const { name, favoriteNumber, children } = this.props; //비구조화 할당 return ( &lt;div&gt; 제 이름은 {name}입니다. &lt;br /&gt; 제가 좋아하는 색은 {favoriteNumber} 이구요 &lt;br /&gt; 저의 차일드는 {children} 입니다. &lt;/div&gt; ); }}//defaultProps 지정MyComponent.defaultProps ={ name : \"기본이름\";}//propTypes 지정MyComponent.propTypes = { name : PropTypes.string }export default MyCompoenet; class 내부에서 지정하는 방법도 있다. 12345678910111213141516171819202122232425262728import React, { Component } from 'react';import propTypes from 'prop-types';class MyCompoenet extends Component { //내부에서 지정 static defaultProps = { name: '기본이름', }; static propTypes = { name: propTypes.string, }; render() { const { name, favoriteNumber, children } = this.props; return ( &lt;div&gt; 제 이름은 {name}입니다. &lt;br /&gt; 제가 좋아하는 색은 {favoriteNumber} 이구요 &lt;br /&gt; 저의 차일드는 {children} 입니다. &lt;/div&gt; ); }}export default MyCompoenet; 3.4 state props가 부모 컴포넌트가 설정하는 값이며, 컴포넌트 자신은 해당 props를 읽는 용도로만 사용할 수 있고, props를 바꾸려먼 부모 컴포넌트에서 바꾸어야 하는 것이라면 state는 컴포넌트 내부에서 바뀔 수 있는 값을 말한다.리액트에서는 두 가지 state가 있다. 하나는 클래스형 컴포넌트가 지닌 state이고, 다른 하나는 함수형 컴포넌트에서 useState를 통해 사용하는 state 이다. 클래스형 컴포넌트의 state새로운 Counter.js라는 컴포넌트를 src 폴더에 생성한다. Conuter.js1234567891011121314151617181920212223242526272829import React, { Component } from 'react';class Counter extends Component { constructor(props) { super(props); //state의 초기값 설정 this.state = { number: 0, }; } render() { const { number } = this.state; //state를 조회할 때는 this.state로 조회한다. return ( &lt;div&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button //onClick을 통해 버튼이 클릭되었을때 호출할 함수를 지정 onClick={() =&gt; { //this.setState를 사용하여 state에 새로운 값을 넣는다. this.setState({ number: number + 1 }); }} &gt; +1 &lt;/button&gt; &lt;/div&gt; ); }}export default Counter; 컴포넌트의 state를 설정할 때는 다음과 같이 constructor 메서드를 작성하여 설정한다. 클래스형에서 constructor을 작성할때는 반드시 super(props)를 호출해 주어야 한다. 그 다음에, constructor 내부에 this.state값에 초깃값을 설정해준다. 컴포넌트의 state는 객체 형태 ({}) 여야 한다. render 함수에서 현재 state를 조회할 때는 this.state를 조회하면 된다. 그리고 button의 onClick 이벤트 안에 this.setState라는 함수를 사용해 state 값을 변경한다.후에 App.js에서 컴포넌트를 불러와 랜더링을 하면 버튼 클릭시 숫자가 1씩 올라가게 된다. 3.4.1.1 state 객체 안에 여러 값이 있을 때 state 객체 안에 여러 값이 있을때는 다음과 같이 작성한다. Conuter.js12345678910111213141516171819202122import React, { Component } from 'react';class Counter extends Component { constructor(props) { super(props); //state의 초기값 여러개 설정 this.state = { number: 0, fixedNumber : 0 }; } render() { const { number, fixedNumber } = this.state; //state를 조회할 때는 this.state로 조회한다. return ( &lt;h1&gt;{number}&lt;/h1&gt; &lt;h1&gt;변경 불가 값 : {fixedNumber}&lt;/h1&gt; ... ); }}export default Counter; 3.4.1.1 state를 constructor에서 꺼내기 state 초기값을 지정하기 위해 constructor 메서드를 선언해주었는데, 또 다른 방식으로도 state 초깃값을 지정할 수 있다. Counter.js1234567891011121314151617import React, { Component } from 'react';class Counter extends Component { //다른 방식으로 state 초깃값 설정하기 state = { number:0, fixedNumber :0; }; render() { const { number, fixedNumber } = this.state; //state를 조회할 때는 this.state로 조회한다. return ( ... ); }}export default Counter; 3.4.1.3 this.setState에 객체 대신 함수 인자 전달하기 this.setState를 사용하여 state 값을 업데이트 할 땐 상태가 비동기적으로 업데이트 된다. 만약 onClick 함수 내부에서 this.setState를 두 번 호출하면 클릭시 +2가 될까? Counter.js12345678910111213141516171819202122import React, { Component } from 'react';class Counter extends Component { (...) render() { const { number } = this.state; //state를 조회할 때는 this.state로 조회한다. return ( &lt;div&gt; (...) onClick={() =&gt; { //this.setState를 사용하여 state에 새로운 값을 넣는다. this.setState({ number: number + 1 }); this.setState({ number: this.state.number + 1 }); }} &gt; +1 &lt;/button&gt; &lt;/div&gt; ); }}export default Counter; 정답은 “NO”이다. this.setState를 사용한다고 해서 state 값이 바로 바뀌진 않기 때문이다. 이에 대한 해결을 하기 위해서는 this.setState를 사용할 때, 객체 대신 함수를 인자로 넣어주면 된다. this.setState 객체 대신 함수를 인자로 넣어주기123456//this.setState를 사용해 바로 값이 변경되게 하려면/?this.setState((prevState,props) =&gt; { return( //업데이트 할 내용 )}); 여기서 prevState는 기존 상태이고, props는 현재 지니고 있는 props를 가리키는데 , 만약 props 값이 업데이트 과정에서 필요없다면 생략 가능하다. Counter.js12345678910111213141516171819202122232425262728293031323334//클릭시 +2를 하게끔 this.setState를 두번 호출해보자!import React, { Component } from 'react';class Counter extends Component { (...) render() { const { number } = this.state; //state를 조회할 때는 this.state로 조회한다. return ( &lt;div&gt; (...) &lt;button onClick={ () =&gt; { //this.setState 바로바로 값 바꾸게 하기 this.setState(prevState =&gt; { return { number: prevState.number + 1, }; }); //한 번 더 this.setState(prevState =&gt; { return { number: prevState.number + 1, }; }); }} &gt; +2 &lt;/button&gt; &lt;/div&gt; ); }}export default Counter; this.setState가 끝난 뒤에 특정 작업 실행하기 setState를 사용해 값을 업데이트 하고 난 다음에 특정작업을 실행하기 위해서는 setState의 두번째 파라미터에 callback 함수를 등록해 작업을 처리하면 된다. Counter.js12345678910111213141516(...) &lt;button onClick={() =&gt; { this.setState( { number: number + 1, }, //콜백 함수로 업데이트 후 작업 처리 () =&gt; { console.log('작업 끝'); }, ); }} &gt; +1&lt;/button&gt; 3.4.2 함수형 컴포넌트에서 useState 사용하기 리액트 v16.8 이전에는 함수형 컴포넌트에서 state를 사용할 수 없었지만, 16.8 이후로부터는 useState라는 함수를 통해 함수형 컴포넌트에서도 state를 사용할 수 있게 되었다.이 과정에서 Hooks를 사용하게 된다.Hooks의 종류는 다양한데, 지금은 useState만을 사용해 보도록한다. 3.4.2.1 배열 비구조화 할당 배열 비구조화 할당은 배열 안에 들어 있는 값을 쉽게 추출할 수 있게 한다. 배열 비구조화 할당 예제123456789const array = [1,2];//배열 비구조화 전const one = array[0]; //1const one = array[1]; //2//배열 비구조화 후const [one, two] = array; 3.4.2.2 useState 사용새로운 Say.js 컴포넌트를 src 폴더에 생성한다. Say.js1234567891011121314151617import React, { useState } from 'react';const Say = () =&gt; { const [message, setMessage] = useState(''); const onClickEnter = () =&gt; setMessage('안녕하세요!'); const onClickLeave = () =&gt; setMessage('안녕히 가세요!'); const [color, setColor] = useState('black'); return ( &lt;div&gt; &lt;button onClick={onClickEnter}&gt;입장&lt;/button&gt; &lt;button onClick={onClickLeave}&gt;퇴장&lt;/button&gt; &lt;h1 style={{ color }}&gt;{message}&lt;/h1&gt; &lt;/div&gt; );};export default Say; useState 함수의 인자에 상태 초기값을 넣어준다. 클래스형 컴포넌트에서 state 초깃값은 항상 객체 형태로 넣어주어야 하는 것과 달리, useState 에서는 반드시 객체가 아니여도 크게 상관없다. 문자열, 숫자, 객체, 배열 모두 가능하다. 함수를 호출하면 배열이 반환되는데, 배열의 첫번째 요소 헌재상태이고,두번째는 상태를 바꿔주는 setter 함수이다. 위의 Say.js 의 경우 message가 현재상태이고, setMessage가 message의 상태값으 바꿔주는 setter 함수가 된다. App.js에서 Say.js를 랜더링을 하면입장 버튼 클릭시 ‘안녕하세요’라는 문자열이,퇴장 버튼 클릭시 ‘안녕히 가세요!’라는 문자열이 나오게된다. 3.4.2.3 한 컴포넌트에서 useState 여러번 사용하기 useState는 여러번 사용해도 상관없다. 또 다른 상태를 useState로 관리하면 된다. Say.js1234567891011121314151617181920212223242526272829import React, { useState } from 'react';const Say = () =&gt; { const [message, setMessage] = useState(''); const onClickEnter = () =&gt; setMessage('안녕하세요!'); const onClickLeave = () =&gt; setMessage('안녕히 가세요!'); const [color, setColor] = useState('black'); return ( &lt;div&gt; &lt;button onClick={onClickEnter}&gt;입장&lt;/button&gt; &lt;button onClick={onClickLeave}&gt;퇴장&lt;/button&gt; &lt;h1 style={{ color }}&gt;{message}&lt;/h1&gt; &lt;button style={{ color: 'red' }} onClick={() =&gt; setColor('red')}&gt; 빨간색 &lt;/button&gt; &lt;button style={{ color: 'green' }} onClick={() =&gt; setColor('green')}&gt; 초록색 &lt;/button&gt; &lt;button style={{ color: 'blue' }} onClick={() =&gt; setColor('blue')}&gt; 파란색 &lt;/button&gt; &lt;/div&gt; );};export default Say; 클릭시 텍스트 색상이 바뀌게 된다. state를 사용할 때 주의 사항 state 값을 바꾸어야 할때는 setState 혹은 전달받은 setter함수를 이용해야 한다.배열이나 객체를 업데이트 할때는 사본을 만들고 사본의 값을 업데이트 한 후, 그 사본의 상태값을 변경해줘야한다.객체에 대한 사본을 만들 때는 spread 연산자라 불리는 …을 사용하여 처리한다.배열에 대한 사본을 만들 때는 배열 내장 함수를 이용한다(filter, concat 등)) 1234567891011121314//사본을 만들어 업데이트 하는 예시//객체 다루기const object = {a:1, b:2, c:3};const nextObject = {...object, b:2}; //사본 생성//배열 const array = [ {id :1, value :true}, {id :2, value :false}];let nextArry = array.concat({id :4}); //새 항목 추가nextArry.filter(item =&gt; item.id !=2); //id가 2인 항목 제거","link":"/2019/10/20/react_md/react_chap3/"},{"title":"typescript chapter3. 변수 선언과 기본타입","text":"변수 선언var 선언자의 특징 호이스팅 블록 레벨 스코프가 지원되지 않음(함수 레벨 스코프) 호이스팅변수가 선언된 위치에 관계없이 스코프 최상위로 끌어올림되어 같은 스코프라면 어디서든 호출 할 수 있는 것 호이스팅 예제123helloMessage = \"hello\";console.log(helloMessage);var helloMessage; 변수를 먼저 선언하고 할당한 것처럼 변수 선언을 호이스팅에서 처리함 함수 레벨 스코프함수 내에서만 유효하고 함수 외부에서는 참조할 수 없음 12345678var myName = \"sad\";function functionLevel() { var myName = \"happy\";}functionLevel();console.log(myName); // sad 즉, var은 블록레벨 스코프를 지원하지 않는다. 블록 레벨 스코프블록{} 내에서만 유효하고 블록 외부에서는 참조할 수 없음 1234567// 블록 레벨 스코프를 지원하지 않을 경우// 내부에 있는 변수가 외부에 영향을 미칠수가 있다.var myName = \"sad\";if (true) { var myName = \"happy\";}console.log(myName); // happy 블록 레벨 스코프에 대표적 선언 let, const클래스, 인터페이스, 타입 에일리어스, enum 선언 let 선언자 특징 같은 블록 내에서 같은 이름의 변수를 중복해서 선언 불가 변수를 초기화하기 전에는 변수에 접근할 수가 없으므로 호이스팅 방지 선언할 변수에 블록 레벨 스코프 적용 let선언자로 선언된 변수는 같은 블록 내에서 중복 선언 할 수 없다. 12let myName2;let myName2; // Uncaught SyntaxError: Identifier 'myName2' has already been declared 호이스팅 방지 12console.log(myName); //Uncaught ReferenceError: myName is not definedlet myName = \"happy\"; 변수를 초기화 하기전에는 변수에 접근 불가 블록 레벨 스코프 지원 123456let myName2 = \"sad\";if (true) { let myName2; myName2 = \"happy\";}console.log(myName2); // sad 실습 폴더와 파일 구성tsconfig.json123456{ \"compilerOptions\": { \"outDir\": \"./dist\", \"target\": \"es6\" }} 상수 선언 const는 선언 할 때 초기화는 가능하지만 재할당은 불가능한 읽기 전용 (read only) 변수가 된다. 블록 레벨 스코프이며 호이스팅이 되지 않는다. 123// const로 선언했으므로 상수가 된다.// 값 재할당 금지, 읽기 전용 변수const birthMonth = 9; 특히 타입 어노테이션 (:)을 추가하지 않더라도 할당한 값에 따라 타입이 추론되어 number 타입이 된다. const는 블록 레벨 스코프이다. const는 입력값의 타입에 상관없이 변수를 읽기 전용으로 만든다. 변수가 읽기 전용이 되면 값을 새로 할당할 수 없다. 12345678910const profile = { name: \"happy\", month: 12};// const 는 값을 새로 할당할 수 없다profile = { name: \"happygrammer\", month: 1}; 그러나 예외적으로 const로 선언한 변수라도 객체 리터럴의 속성으로는 변경이 가능하다. 1234567const profile = { name: \"lee\", age: 28};profile.name = \"happy1\"; // 할당 가능profile.month--; // 할당 가능 이는, 타입스크립트가 값 자체를 재할당할 수는 없지만, 속성값의 변경은 허용하는 특성을 갖고 있기 때문이다. 타입 검사와 타입 선언점진적 타입 검사 타입 검사는 정적 타입 검사(statically type checking)과 동적 타입 검사(dynamically type checking)으로 나뉨정적 타입 검사 : 자바, C++동적 타입 검사 : 자바스크립트한편, 타입스크립트는 점진적 타입 검사(gradually type checking)을 수행 , 필요에 따라 타입 선언 생략을 허용한다.타입을 생략하면 암시적 형변환이 일어난다. 암시적 형변환12345function add10(a) { return a + 10;}add10(1); 매개변수 a에 타입을 선언하진 않았지만, 타입스크립트 컴파일러가 a를 오류로 취급하지 않는다.또한 변환된 자바스크립트는 동적으로 타입이 결정되어 오류 없이 실행된다.필요에 따라 타입을 생략할 수도 , 점진적으로 추가할 수도 있다.대표적으로 any타입은 모든 타입의 최상위 타입으로 동적 타입과 정적 타입의 경계에 있으며 어떤 타입의 변수도 받아들인다.(심지어 타입이 없는 변수도 받아들임) 자바스크립트의 동적 타이핑 자바스크립트는 기본 타입과 객체 타입이 있다. 기본 타입 - Number, String, Boolean 객체 타입 - 객체 리터럴, 배열, 내장 객체 자바스크립트에도 타입이 있지만 타입을 강제할 수는 없고 값 할당시에 타입을 추론한다. 12var number = 10; // number 타입var str = \"hello\"; // string 타입 이처럼 값을 변수에 할당할 때 타입이 정해지는 것을 동적 타이핑이라고 한다. 타입스크립트에서도 타입을 선언하지 않으면 입력값에 따라 타입이 결정된다. 정해진 타입을 예측할수 없으므로 타입을 검사하는 코드가 추가로 필요해지고, 이는 성능상으로 좋지 않다. typeOf1234567var width = 10;var animals = [];var myFullName = { first: \"happy\" };console.log(typeof width); // numberconsole.log(typeof animals); //objectconsole.log(typeof myFullName); //object 타입 계층도 가장 상위에 any가 있고 그 아래에 기본타입 객체 타입 기타 타입(유니언 타입, 인터섹션 타입) 기본 타입기본 타입(primative types)는 보편적으로 많이 사용된다. string, number, boolean symbol(es6에서 추가됨) enum 문자열 리터럴 string 타입은 작은 따음표나 큰 따음표, 역따옴표(백틱 , backtick)을 이용할 수 있다. number 타입은 es6에서 10진수뿐만 아닌 16진수, 2진수,8진수도 지원한다. bolean 타입은 true 또는 false 값 할당할 수 있다.\\ symbol 은 Symbol() 함수를 이용해 생성한 고유고 수정 불가능한 데이터 타입이다. 1let hello = Symbol(); enum 은 number에서 확장된 타입으로 enumm의 첫번째 요소에는 숫자 0의 값이 할당된다. 그 다음부턴 1씩 증가한다. 12345678910111213141516171819// 타입스크립트enum WeekDay { Mon, Tue, Wed, Thu}let day: WeekDay = WeekDay.Mon;// javascript로 변환했을 때var WeekDay;(function(WeekDay) { WeekDay[(WeekDay[\"Mon\"] = 0)] = \"Mon\"; WeekDay[(WeekDay[\"Tue\"] = 1)] = \"Tue\"; WeekDay[(WeekDay[\"Wed\"] = 2)] = \"Wed\"; WeekDay[(WeekDay[\"Thu\"] = 3)] = \"Thu\";})(WeekDay || (WeekDay = {}));var day = WeekDay.Mon; 문자열 리터럴 타입은 string 타입의 확장 타입으로 사용자 정의 타입에 정의한 문자열만 할당받을수 있다. 객체 타입객체 타입은 속성을 포함한다. Array Tuple Function 생성자 Class Interface array는 배열 요소에 대응하는 타입이다. 1let items: number[] = [1, 2, 3]; tuple은 배열 요소가 n개로 정해질 때 각 요소별로 타입을 지정한다. 123// 배열 요소가 문자열과 숫자일 때let x: [string, number];x = [\"tuple\", 100]; 함수타입 class 타입과 interface 타입은 객체 타입(object types)로 본류된다. 기타 타입 유니언(union) 인터섹션(intersection) 특수 타입 유니언 타입은 2개 이상의 타입을 하나의 타입으로 정의한 타입이다. 유니언 타입1var x: string | number; 인터섹션 타입은 두 타입을 합쳐 하나로 만들 수 있는 타입이다. 인터섹션 타입12345678interface Cat { leg: number;}interface Bird { wing: number;}let birdCat: Cat &amp; Bird = { leg: 4, wing: 2 }; 위 코드에서 birdCat 변수가 인터섹션 타입인 Cat&amp;Bird로 선언되어 있으므로 할당 객체는 leg와 wing 만 허용한다. void , null, undefined는 타입 계층도 가장 아래층에 위치한다. void는 빈 값을 나타내는 타입이다. 함수에 리턴값이 없을떄 void 타입을 선언할 수 있는데 undefined나 null값을 받을 때 사용한다. null 과 undefined는 다른 모든 타입의 하위 타입(subtype)이다. undefined는 빈 값으로도 초기화되지 않는 타입이다. null 타입은 빈 객체로 초기화된다. 타입스크립트의 타입 계층도는 기존 자바스크립트 타입을 확장한 형태이다. 자바스크립트 타입과 비교했을 때 다음과 같은 타입이 추가되었다. 객체 타입의 상위 타입으로 any추가 any 타입의 특수 타입으로 유니언 타입과 인터섹션 타입 추가 객체 타입의 하위 타입으로 Array,Interface,Tuple추가 void 타입 추가 변수에 타입 지정 타입 스크립트는 강력한 타입을 지원한다. 변수에 타입 지정1234var &lt;변수식별자&gt; : &lt;타입&gt; = &lt;값&gt;;//어떤 변수에 명시적으로 타입을 지정함var width2 : number = 10; 자바스크립트의 타입 타입스크립트에서는 자바스크립트에서 지원하는 내장타입을 제공한다.크게 기본타입, 객체타입, 함수타입 이 있다. 내장 타입 boolean, string, number 등이 있다. 이들은 명시적으로 전역 객체를 통해 직접 생성 가능하다. 12345678var type1 = new Boolean(false);var type2 = new String(\"hello\");var type3 = new Number(123);// 이들은 타입이 객체이므로 호출할 때 다음과 같다.type1.valueOf(); // falsetype2.valueOf(); // \"hello\"type3.valueOf(); // 123 Symbol() 함수처럼 객체 속성에 유일한 식별자로 사용하는 타입 null,undefined 처럼 null값이거나 아직 할당되지 않았다는 의미로 쓰이는 타입 이 외에도 object 타입 (배열이나 객체 리터럴 대상) 함수는 그 자체로 function 타입 등이 있다. 자바스크립트에서는 타입을 지정할 때 런타임 시 할당과 동시에 동적으로 타입이 결정되는 느슨한 타입타입스크립트는 지정한 값만 받는 엄격한 타입 쳬계를 사용한다. symbol 타입 자바스크립트 내장 타입중 symbol 타입은 es6에서 추가된 특징이다. 1let hello = Symbol(\"hello\"); symbol 타입은 심벌 객체를 반환한다. “hello”인수는 심벌의 설명(description)을 의미한다. 심벌에 접근할 때 사용할 수 있으며 생략 가능하다.만약, 어떤 변수를 불변 상수로 선언하려면 const를 사용한다. 1const hello = Symbol(); 위와 같이 선언하면 hello는 유일하면서(Symbol() 함수 사용) 불면(const 사용)인 특성을 갖게된다. symbol함수는 es6로 컴파일해야한다. tsconfig.json의 target을 es6로 선언하거나 1tsc sysmbol.ts(컴파일하려는 ts명) -t es6 명령어로 컴파일한다. 심벌 객체간 비교12345let hello1 = Symbol(\"hello\");let hello2 = Symbol(\"hello\");console.log(hello1 === hello2); //falseconsole.log(typeof hello1); //symbol 심벌 객체는 유일하므로 hello1과 hello2는 서로 다른 객체이다. Symbol() 함수의 반환값은 별다른 값을 취하지 않아도 그 자체로 식별자가 된다. Symbol()함수로 초기화된 변수는 객체 속성에 대한 유일한 식별자로서 값을 할당하는 용도로 사용한다. enum 타입 enum 타입은 es6에서 제안된 타입으로 컴파일 시간에 평가되며, 타입 계층도에 따르면 number 타입의 하위타입으로 , 컴파일 후에는 객체 타입이 된다.명명된 숫자 상수의 집합을 정의할때 사용한다.enum 타입은 숫자 상수를 기억하기 좋은 키워드로 변환해서 사용가능하다. 1234enum Day {속성 : 값, 속성 : 값}// 기억하기 좋게enum WeekDay {Mon,Tue,Wed,Thu} 각 속성은 상수와 연결되며 첫 번째 속성의 인덱스는 0부터 시작한다. 또한 특별히 명시하지 않는 이상 순차적으로 1씩 증가한다. 초기값을 할당할 수도 있는데 기본적으로 숫자 할당이 가능하다. enum은 const를 붙여서 상수 enum으로도 선언할 수 있다. 이때 상수 enum은 읽기 전용이 된다. const를 붙인 enum123456const enum WeekDay { Mon = 1, Tue = 2, Wed = 3, Thu = 4} 이렇게 읽기 전용으로 설정하면 인덱스 접근 표현식에 문자열 리터럴만 허용한다. const를 붙인 enum는 인덱스 접근에 문자열만 허용한다.1234let day = WeekDay[\"Mon\"]; // 문자열 리터럴 허용 가능let day2 = WeekDay[weekDay.Mon]; //불가능let day3 = WeekDay[1]; // 불가능let day4 = WekkDay; // const enum을 변수에 직접 할당 불가능 문자열 enum이 추가되어 초기값으로 문자열 할당 가능하다.문자열로 초기값을 설정하면 연산식 할당은 할 수 없다. 문자열 enum1234567891011enum WeekDay3 { Mon = \"Monday\", Tue = \"Tuesday\"}// 연산식 할당 불가enum WeekDay3 { Mon = 1 + 2, Tue = \"Tues\"}// Computed values are not permitted in an enum with string valued members// 계산된 값은 문자열 값 멤버가 포함된 열거형에 허용되지 않습니다. // TODO enum 타입 정리 타입스크립트의 내장타입 타입스크립트에서만 지원되는 내장타입을 알아본다. any 타입 any 타입은 어떤 타입의 값도 받아들일수 있으며 최소한의 타입 검사만 수행한다. any 타입 예제12let basket: any = 10;let vList: any[] = [1, false, \"happy\"]; // any[] : 배열의 타입이 다양해서 한 가지 타입으로 고정할 수 없을 때 사용 any는 모든 타입의 가장 최상위 타입이므로 자바스크립트의 모든 값을 할당 받을수 있다. any 타입을 선언하면 명시적으로 타입을 선언한거고, any 타입을 생략하면 타입이 없는 것 1let a; // let a : any;와 같음 any 타입으로 선언된 변수는 최소한의 정적 타입 검사만 수행한다. 타입이 선언된 경우와 타입이 없는 경우12345678let number = 50;let number2: any = 50;number.toFixed(1); // 가능number2.toFixed(1); // 가능number.notExitMethod(); // Property 'notExitMethod' does not exist on type 'number'.number2.notExitMethod(); 선언되지 않은 어떤 메서드를 호출할 때 타입을 선언하지 않으면 오류를 발생시킴 object 타입 object 타입은 any와 비슷하게 타입 구분없이 값을 할당할 수 있지만 차이점이 있다.any 타입은 런타임시 속성의 유뮤를 검사한다.object 타입은 컴파일 시간에 속성의 유무를 검사한다. 따라서, object 타입에 변수에 숫자를 할당해도 컴파일 시에 숫자 메서드를 인식하지 못하므로 컴파일 에러를 발생시킨다. 123456let number2: any = 40;let number3: Object = 40;number2.toFixed(1);number3.toFixed(1); // Property 'toFixed' does not exist on type 'Object'.console.log(typeof number3); // number nolmplicaitAny 옵션 any 타입을 반드시 지정해야 할 때 123456789// tsconfig.json{ \"compilerOptions\" : { \"noImplicitAny\" : true }}// 또는 cmd에서tsc --noImplicitAny true 배열 타입과 제네릭 배열 타입 배열은 배열타입과 제네릭 배열 타입으로 나뉜다. 배열 타입요소 타입에 []를 붙여서 선언한다. string,number,boolean, class, interface 모두 가능하다. 배열 타입1let myVar: number[] = [1, 2, 3, 4, 5]; any[]타입으로 지정하면 어떤 요소든 배열에 추가 가능하다. 타입을 제약하고 싶을때는 유니언 타입을 이용해 선언한다.(유니언타입 : 2개 이상의 타입을 하나의 타입으로 정의) 1let myVar: number | string | boolean = [1, \"1\", true]; 제네릭 배열Array[T] 형태로 선언한다. T는 타입을 의미한다. 제네릭 배열 타입1let myVar: Array&lt;number&gt; = [1, 2, 3]; 마찬가지로 유니언 타입으로 배열의 타입을 제약 가능하다. 1let myVar: Array&lt;number | string | boolean&gt; = [1, \"1\", true]; 내장 타입 외에 객체 타입도 받을 수 있다. 객체 타입12let nums: Array&lt;() =&gt; string&gt; = [() =&gt; \"one\", () =&gt; \"two\"];console.log(nums[0]()); // one 배열타입이건 제네릭 배열 타입이건 javascript로 컴파일 시에는 타입이 제거되므로 동일한 결과를 가져옴 튜플 타입(tuple type) 배열 요소에 대응하는 n개에 대한 타입이다. tuple12345//배열 : 요소 개수에 제한이 없다.let x: string[] = [\"h\", \"b\"];// 튜플 : 선언된 타입수와 할당된 배열 요소 수가 정확히 일치해야한다.let x: [number, string] = [1, \"h\"]; 타입스크립트 2.7 이후 튜플 타입에 따라 할당된 배열의 요소 수가 고정되었다. void, null,undefined void는 함수의 반환 값이 없을 때 지정하는 타입으로 null, undefined만 할당 할 수 있다.void는 null, undefined의 상위 타입이다.반환값이 없을 때 이를 명시적으로 나타내기 위헤 void를 지정한다. viod123456function hello(): void { //리턴값이 없음}console.log(hello()); // undefinedconsole.log(typeof hello()); // \"undefined\" hello() 의 반환 타입은 void 지만 리턴값이 없으므로 undefined로 할당된다.void 타입은 undefined나 null만 할당할 수 있으므로 유용한 타입이 아니다. null vs undefined undefined는 undefined 타입이며 아직 초기화 되지 않았음을 의미한다.null은 값이기 때문에 null을 할당하고 나면 object 타입이 된다.undefined와 null 모두 값이 없다는 점에서는 같다. 다만 undefined는 선언은 했으나 값이 할당되지 않는 경우이고,null은 값을 할당했으나 그 값이 없는 경우이다. undefined와 null123456789101112var testUndefined;console.log(testUndefined, typeof testUndefined); // undefined 'undefined'var testUndefined2: undefined = undefined;console.log(testUndefined2, typeof testUndefined2); // undefined 'undefined'var testUndefined3: null = null;console.log(testUndefined3, typeof testUndefined3); // null 'object'//console.log(null === undefined); // 값과 타입 모두 비교하므로 falseconsole.log(null == undefined); // 값만 비교하므로 둘다 값이 없으므로 true 값이 없음을 나타내기 위해서 null을 할당하는것인 권장하지 않는다. 12let empty; // undefinedlet empty = null; // 권장하지 않음","link":"/2020/03/16/ts_md/ts1/"},{"title":"typescript chapter7. 클래스와 인터페이스","text":"타입스크립트의 객체지향 프로그래밍 지원 객체지향 프로그래밍 요소 자바스크립트(ES6) 타입스크립트 클래스 class class 인터페이스 x interface 인터페이스구현 x implements 상속 extends extends 생성자 constructor(){} constructor(){} 접근 제한자 x private, public, protected final 제한자 x readonly(TS 2.0부터 지원) static 키워드 static static super 키워드 super super 자바스크립트는 객체지향 프로그래밍을 하기에 지원이 다소 부족하지만, 타입스크립트는 객체지향 프로그래밍에 부족함이 없다. 클래스클래스 선언과 객체 생성 타입스크립트에서 class를 선언할 때는 클래스명 앞에 class를 붙여 선언한다. 12345678910111213class Rectangle { x: number; y: number; constructor(x: number, y: number) { this.x = x; this.y = y; } getArea(): number { return this.x * this.y; }} 이렇게 선언한 Rectangle 클래스는 클래스 타입이 된다. Rectangle 클래스는 다음의 인터페이스 타입과 정확히 일치하게 된다. 12345interface Rectangle { x: number; y: number; getArea(): number;} 클래스 내부에는 생성자는 contstructor을 정의한다. 생성자는 객체 생성 시 클래스에 필요한 설정을 매개변수로 전달받아 멤버변수를 초기화한다.생성자를 생략하면 기본 생성자를 호출한다. 생성자는 클래스 선언 떄 생략 가능하다. 객체 생성 클래스는 멤버 변수와 메서드 등으로 구성된 ‘틀’이며 클래스를 실제로 사용하려면 객체를 새로 생성해줘야한다. 1let rectangle = new Rectangle(1, 4); new 키워드를 사용해 Rectangle 객체를 생성해 객체 참조변수에 할당한다. 이를 인스턴스화라고 한다.rectangle은 객체 참조변수(인스턴스) 이고, new 키워드를 통해 Rectangle객체를 생성함(인스턴스화) Rectangle 클래스 선언과 객체 생성123456789101112131415161718class Rectangle { x: number; y: number; constructor(x: number, y: number) { this.x = x; this.y = y; } getArea(): number { return this.x * this.y; }}let rectangle = new Rectangle(1, 4);let result: number = rectangle.getArea();console.log(result); // 4 상속관계, 포함관계 클래스 간의 관계는 상속 관계와 포함 관계가 있다. 상속 관계 부모 클래스를 기반 클래스 또는 슈퍼 클래스라고 하며 이를 상속 받는 자식 클래스를 파생 클래스 또는 서브 클래스라고 부른다.자식 클래스는 부모 클래스에 공개된 메서드나 변수를 상속받는다.( IS-A관계)상속을 위해 extends 키워드를 지원한다.단일 상속만 지원하므로 자식 클래스는 하나의 부모 클래스만 상속받을 수 있다. 상속시 자식 클래스 생성자에서 super() 메서드를 호출해 부모 클래스의 생성자를 호출해주어야한다. 12345class &lt;자식 클래스&gt; extends &lt;부모 클래스&gt;{ constructor(){ supper(); };} 포함 관계 클래스가 다른 클래스를 포함하는 (HAS-A) 관계이다.합성(composition)관계집합(aggregation)관계 합성 관계는 전체가 부분을 포함하며 강한 관계이다. 1234567891011class Engine {}class Car { private engine; constructor() { this.engine = new Engine(); }}let car = new Car();car = null; Car 클래스에 선언된 engine 객체는 Car 클래스가 new로 생성될때 함께 생성되고, car가 null이되면 함께 제거된다.(생명주기를 함께한다) 집합 관계는 전체가 부분을 포함하며 약한 관계이다. 1234567891011class Engine {}class Car { private engine: Engine; constructor(engine: Engine) { this.engine = engine; }}let engine = new Engine();let car = new Car(engine); Car 클래스의 car 객체가생성될때 외부에서 생성된 engine 객체를 전달하고 있다.따라서 car가 null이 되더라도,engine 객체는 Car클래스 외부에서 선언되어 null이 되지 않아 생명주기를 함꼐 하지 않는다. 상속관계와 포함 관계를 고려해 구현하기123456789101112131415161718192021222324252627282930313233343536373839// Flashlight 클래스 - 포함class Flashlight { constructor(public lightIntensity) {}}// Bicycle 클래스 - 부모class Bicycle { constructor(public numberOfWheel: number) {} getNumberOfWheel(): number { return this.numberOfWheel; }}// Bicycle 클래스를 상속함(IS-A 관계)class MountainBike extends Bicycle { flashlight: Flashlight; constructor(public numberOfWheel: number, public hasBackSaddle: boolean) { super(numberOfWheel); // 부모의 메서드numberOfWheel를 사용하기위해 // 자전거가 후레쉬 라이트를 포함함(HAS-A 관계) this.flashlight = new Flashlight(90); } getHasBackSaddle() { return this.hasBackSaddle; } getNumberOfWheel() { return this.numberOfWheel; }}let hasBackSaddle = true;let numberOfWheel = 2;let mountainBike = new MountainBike(numberOfWheel, hasBackSaddle);console.log(\"자전거의 안장 유무 : \" + mountainBike.getHasBackSaddle()); // trueconsole.log(\"자전거의 바퀴 개수 : \" + mountainBike.getNumberOfWheel()); // 2 접근 제한자 사용법 타입스크립트에서는 접근 제한자 (private, public , protected)를 제공한다. 접근 제한자 특징 상속 여부 외부객체를 통한 접근 public public으로 설정된 멤버(멤버 변수, 메서드)등은 자식 클래스에서 접근 할 수 있다. o o protected protected로 설정된 맴버는 자식 클래스에서 접근 가능 o x private private로 설정된 멤버는 현재 클래스에서만 접근할수 있고, 자식 클래스에서 접근 불가능 x x public 제한자와 private 제한자 public 은 클래스 내부와 외부에서 모두 접근 가능하게 한다. 객체 내부나 외부에서 접근할 수 있고 부모 클래스로부터 상속도 가능하다.private 제한자는 클래스 내부에서는 접근 할 수 있지만 외부에서는 접근 못하게 하는 접근 제한자이다. 생성자 매개변수에 접근 제한자 추가 생성자 매개변수에 접근 제한자를 추가하면 매개변수 속성이 되어 멤버 변수가 되는 효과가 있다. 12345678910111213class Cube { public width: number; constructor(pwidth: number) { this.width = pwidth; }}/****같은 역할을 하도록 코드를 간결하게 변경****/class Cube { constructor(public width: number) { }} 생성자 매개변수에 접근 제한자를 추가해 멤버 변수처럼 사용하는 예제 123456789101112131415161718class Cube { // #1 생성자 매개변수 선언 constructor( public width: number, private length: number, protected height: number ) {} // #2 직육면체 부피 구하기 getVolume() { return this.width * this.length * this.height; }}let [cWidth, cLength, cHeight] = [1, 2, 3]; // 가로, 세로, 높이let cube = new Cube(cWidth, cLength, cHeight);console.log(\"1번 세로 : \", cube.width, \"cm\"); // length, height는 접근 불가console.log(\"2번 부피 : \", cube.getVolume(), \"ml\"); 오직 public으로 선언된 생성자 매개변수 width만이 외부객체에서 접근을 허용함(private, protected는 비허용) protected 제한자의 사용법 protected는 객체를 통한 외부 접근은 비허용하지만 상속관계에서 부모클래스에 protected로 선언된 메서드나 멤버 변수의 접근은 허용한다. 부모 클래스의 맴버를 이용 super 키워드와 this 키워드를 이용해서 자식 클래스에서 부모 클래스에서 선언된 메서드나 변수를 이용할 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243class PC { constructor(hddCapacity) { this.hddCapacity = hddCapacity; this.ram = \"0G\"; } set ramCapacity(value) { this.ram = value; } // set 프로퍼티 get ramCapacity() { return this.ram; } // get 프로퍼티 getHddCapacity() { return this.hddCapacity; }}class Desktop extends PC { constructor(hddCapacity) { // 부모 클래스의 생성자를 호출함 super(hddCapacity); this.hddCapacity = hddCapacity; } getInfo() { console.log(\"1번 HDD 용량 : \" + super.getHddCapacity(), super.hddCapacity); console.log(\"2번 HDD 용량 : \" + this.getHddCapacity(), this.hddCapacity); this.hddCapacity = \"2000G\"; console.log(\"3번 HDD 용량 : \" + super.getHddCapacity(), super.hddCapacity); console.log(\"4번 HDD 용량 : \" + this.getHddCapacity(), this.hddCapacity); super.ramCapacity = \"16G\"; // 부모 클래스의 set 프로퍼티로 값을 설정함 console.log(\"5번 RAM 용량 : \" + this.ramCapacity, super.ramCapacity); this.ramCapacity = \"8G\"; // 상속 받은 set 프로퍼티로 값을 설정함 console.log(\"6번 RAM 용량 : \" + this.ramCapacity, super.ramCapacity); }}let myDesktop = new Desktop(\"1000G\");myDesktop.getInfo();/* 1번 HDD 용량 : 1000G undefined 2번 HDD 용량 : 1000G 1000G 3번 HDD 용량 : 2000G undefined 4번 HDD 용량 : 2000G 2000G 5번 RAM 용량 : 16G 16G 6번 RAM 용량 : 8G 8G*/ 기본 접근 제한자 접근 제한자 선언을 생략할 때 적용되며 , 대체로 public 이다.constructor에서 접근 제한자가 생략되면 생성자 내부에서만 사용 가능해진다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Account { balance: number; // 적금액 얻기(get 프로퍼티 이용) get getBalance() { return this.balance; } // 적금하기(set 프로퍼티 이용) set setBalance(amount: number) { this.balance += amount; } // 적금하기(메서드 이용) deposite(depositeAmount: number) { this.setBalance = depositeAmount; } // 기본 적금(balance)액을 설정하기 constructor( defaultBalance: number = 0, protected bankName: string = \"happy bank\", readonly interestRate: number = 0.1 ) { this.balance = defaultBalance; } // 생성자 매개변수 interestRate는 public으로 설정됐으므로 호출 가능 getInterestRate() { return this.interestRate; } // 생성자 매개변수 defaultBalance는 private(기본 접근 제한자)이므로 호출 불가 getDefaultBalance() { // return this.defaultBalance; }}class MyAccount extends Account { // 테스트 constructor() { super(); this.deposite(1000); // 1000원 적금하기 this.setBalance = 1000; // 1000원 적금하기 console.log( `2번) 적금 : ${this.balance}원, ${this.getBalance}원 / 이율 : ${ this.interestRate }, ${this.getInterestRate()}% / 은행명 : ${this.bankName} ` ); }}let account = new Account();console.log( `1번) 적금 : ${account.balance}원, ${account.getBalance}원 / 이율 : ${ account.interestRate }, ${account.getInterestRate()}% `);let myAccount = new MyAccount();account.bankName; // Property 'bankName' is protected and only accessible within class 'Account' and its subclasses 접근 제한자를 생략하면 기본적으로 public이 된다.위 예제에서 defaultBalance는 생성자 내부에서만 사용 가능한 private가 된다.bankName은 protected로 자식 클래스에서 접근가능하지만 객체를 통한 외부접근은 불가능하다.(account.bankName 불가)interestRate는 readOnly로 자식 클래스에서도 접근 가능하고 외부 접근도 가능하다. 추상 클래스 추상 클래스는 구현 메서드와 추상 클래스가 동시에 존재할 수 있다.abstract 키워드를 클래스 선언 앞에 붙여서 선언한다. 123456abstract class 추상클래스{ abstract 추상메서드(); abstract 추상멤버변수 : string; public 구현메서드():void{ }} 인터페이스 인터페이스는 타입스크립트에서만 지원한다. 인터페이스는 컴파일 후에는 사라지는 타입이다.인터페이스는 선언만 존재하며 멤버 변수와 멤버 메서드를 선언할 수 있지만 접근제한자 설정은 불가능하다. 123interface Car{ speed : number;} 자식 인터페이스sms extends 키워드를 사용해 부모 인터페이스를 상속해 확장 할 수 있다. 1interface &lt;자식 인터페이스명&gt; extends Car{} 자식 인터페이스는 여러 부모 인터페이스를 다중 상속할수 있다. 12345678910111213141516interface Car { speed: number;}interface SuperCar { gear: number;}// 다중 상속interface MyCar extends Car, SuperCar { setting: boolean;}let mycar = &lt;MyCar&gt;{};mycar.speed = 100;mycar.gear = 2;mycar.setting = true; 만약 부모 인터페이스에서 같은 이름의 메서드를 사용하고 이를 자식이 상속받으면 상속된 자식 인터페이스에서 같은 이름의 메서드를 모두 정의해야한다.인터페이스 정의를 마치면 implements 키워드를 이용해 인터페이스를 구현하는 클래스를 작성한다. 12345678910111213interface Dog { run(): void; getStatus(): { runningSpeed: number };}interface Bird { fly(): void; getStatus(): { flySpeed: number };}interface DogBird extends Dog, Bird { getStatus(): { runningSpeed: number; flySpeed: number };} 인터페이스 역할과 컴파일 결과 인터페이스를 이용하면 객체의 구조를 고정 할 수 있다.인터페이스는 타입 검사의 용도로 사용하고 컴파일 후에는 제거된다. typeof를 이용해 인터페이스 타입을 조사할 수 없다. 배열 요소 타입을 객체 리터럴 타입으로 사용 배열 요소가 객체 리터럴이면 배열 타입 선언 시, 배열 요소의 타입을 객체 리터럴로 지정할 수 있다.배열 요소 타입이 선언되어있으므로 이에 맞춰서 json의 속성을 지정해줄 수 있다. 123456789101112let person: { name: string; age: number }[];person = [ { name: \"lee\", age: 20, }, { name: \"kim\", age: 30, },]; 클래스를 배열 타입으로 지정함1234567class Person { constructor(public name: string, public age: number) {}}let person: Person[] = [new Person(\"lee\", 20), new Person(\"kim\", 30)];console.log(JSON.stringify(person)); // [{\"name\":\"lee\",\"age\":20},{\"name\":\"kim\",\"age\":30}] 인터페이스를 배열 타입으로 지정함1234567891011interface Person { name: string; age: number;}let person: Person[] = [ { name: \"lee\", age: 20 }, { name: \"kim\", age: 30 },];console.log(JSON.stringify(person)); // [{\"name\":\"lee\",\"age\":20},{\"name\":\"kim\",\"age\":30}] 클래스와 인터페이스의 활용오버라이딩(overriding) 오버라이딩은 부모 클래스에 정의된 메서드를 자식 클래스에 새로 구현하는 것을 말한다.부모 클래스를 오버라이든 클래스(overridden class)라고 한다.오버라이든 클래스 안에는 오버라이든 메서드가 존재한다. (부모)오버라이딩 메서드가 재 정의 되려면 (자식) 오버라이든 메서드의 매개변수 타입은 오버라이딩 메서드의 매개변수 타입과 같거나 상위 타입이여야한다. 오버라이든 메서드의 매개변수 개수가 오버라이딩 메서드의 매개변수 개수와 같거나 많아야한다.(위 조건 충족 시) 오버라이딩 예제1234567891011// Bird : 오버라이든 클래스 (부모)class Bird{ // 오버라이든 메서드 flight(sppeed : any = 0){} // 부모의 메서드의 타입이 같거나 상위 타입이어야함, 갯수가 같거나 많아야함 }// Eagle : 오버라이딩 클래스 (자식)class Eagle extends Bird{ // 오버라이딩 메서드(부모 메서드와 이름이 같음) flight(sppeed2 : number = 0){} // 매개변수 이름은 달라도 된다. 단 타입은 같거나 하위 타입이여함} 위 두개의 조건을 만족하지 않으면 오버라이딩 되지 않음 123// 위 경우는 메서드의 이름이 같아도 오버라이딩 되지 않는다.filght(speed : any = 0; distance : number = 0); // 오버라이든 메서드filght(speed : number = 0; distance : string = ''); // 오버라이딩 메서드 오버로딩(overloading) 메서드 오버로딩은 메서드의 이름이 같지만 매개변수 타입과 개수를 다르게 정의하는 방법을 말한다. 오버라이딩 메서드를 오버로딩하는법 부모 클래스에 상위 타입을 가지는 오버라이든 메서드를 구현하고, 파생 클래스에서 오버라이딩 메서드를 선언해 구현함 1234567891011121314151617181920212223242526272829class SingleTypeChecker { constructor() {} typeCheck(value: string): void { console.log(`${typeof value} : ${value}`); }}class UnionTypeChecker extends SingleTypeChecker { constructor() { super(); } typeCheck(value2: number): void; typeCheck(value2: string): void; // 같은 타입을 포함해야 한다. typeCheck(value2: any): void { if (typeof value2 === \"number\") { console.log(\"숫자 : \", value2); } else if (typeof value2 === \"string\") { console.log(\"문자열 : \", value2); } else { console.log(\"기타 : \", value2); } }}let unionTypeChecker = new UnionTypeChecker();unionTypeChecker.typeCheck(123);unionTypeChecker.typeCheck(\"happy\");// unionTypeChecker.typeCheck(true); // 에러 위 예제는 any 타입에 number와 string 만 받을 수 있도록 typeCheck 메서드를 정의함any 타입이 모든 타입을 받을 수 있을 것 같지만 실제로는 number와 string 만 받을 수 있다. 인터페이스를 클래스에서 구현하여 오버로딩 인터페이스를 이용해 오버로딩 하라면 인터페이스에 오버로딩할 기본 메서드를 선언하고, 클래스에서 기본 메서드를 구현해준다. 123456789101112131415161718interface IPoint { getX(x: any): any; // 기본 메서드 선언}class Point implements IPoint { getX(x?: number | string): any { // ?매개변수에 ? 을 추가해 선택 매개변수가 되어 입력값이 없는 호출을 받을 수 있다. p.getX(); if (typeof x === \"number\") { return x; } else if (typeof x === \"string\") { return x; } }}let p = new Point();console.log(p.getX()); // undefinedconsole.log(p.getX(\"hello\")); // helloconsole.log(p.getX(123)); // 123 다형성 여러 타입을 받아들여 여러 형태를 가지는 것. 타입스크립트에서는 다음 세 가지가 대표적인 예이다. 클래스의 다형성 인터페이스의 다형성 매개변수의 다형성 클래스의 다형성1234567891011121314151617181920212223class Planet { public diameter: number; // 접근 가능 getIsTransduction(): boolean { // 접근 가능 return this.isTransduction; } stop(): void { // 오버라이든 메서드 2) console.log(\"stop1\"); this.isTransduction = false; }}class Earth extends Planet { public features: string[] = [\"soil\", \"water\", \"oxyzen\"]; // 접근 불가 stop(): void { // 오버라이딩 메서드 console.log(\"stop2\"); this.isTransduction = false; }}let earth: Planet = new Earth(); // 1) 1) 부모 클래스(Planet) 타입으로 지정된 객체 참조변수(earth)는 자식 클래스의 객체(new Earth)를 할당받더라도 실제 동작은 부모 클래스를 기준으로 실행된다.따라서 earth는 부모 메서드는 접근 가능하지만 자식 클래스의 매개변수(features)에는 접근 할 수 없다. 2) 그런데, stop()은 부모 클래스의 stop() 메서드가 자식 클래스로 오버라이딩 되어있다. 이럴 경우 자식 클래스의 메서드가 우선으로 호출된다.즉 오버라이든 &lt; 오버라이딩이처럼, 런타임 시에 호출될 메서드가 결정되는 특성을 런타임 다형성이라고 한다. 인터페이스의 다형성12345678910111213141516171819interface IPerson { age: number; getAge(): number;}class MyPerson implements IPerson { age: number; getAge(): number { return 10; } hasClub() { return true; }}let man: IPerson = new MyPerson(); // 1)console.log(man.getAge()); // 2)console.log(man.hasClub()); //3) Property 'hasClub' does not exist on type 'IPerson'. 1) new MyPerson()는 원래 MyPerson 타입이지만 객체 참조변수(man)에 할당되면서 인터페이스(IPerson) 기준으로 접근이 이뤄진다.2) 따라서, man은 매개변수 age와 getAge()메서드에는 접근 가능하지만,3) 구현 클래스(MyPerson)에 새롭게 추가된 hasClub() 메서드는 접근 할 수 없다. 매개변수의 다형성 유니언 타입 이용 매개변수 타입을 유니언 타입을 이용하므로써 객체가 다형성의 성질을 띄도록 만들 수 있다. 인터페이스 타입 이용 클래스에서 getter,setter","link":"/2020/04/19/ts_md/ts5/"}],"tags":[{"name":"map","slug":"map","link":"/tags/map/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"이터레이터","slug":"이터레이터","link":"/tags/이터레이터/"},{"name":"제너레이터","slug":"제너레이터","link":"/tags/제너레이터/"},{"name":"git세팅","slug":"git세팅","link":"/tags/git세팅/"},{"name":"클로저","slug":"클로저","link":"/tags/클로저/"},{"name":"if","slug":"if","link":"/tags/if/"},{"name":"for","slug":"for","link":"/tags/for/"},{"name":"제어문","slug":"제어문","link":"/tags/제어문/"},{"name":"스코프","slug":"스코프","link":"/tags/스코프/"},{"name":"프로퍼티","slug":"프로퍼티","link":"/tags/프로퍼티/"},{"name":"클래스","slug":"클래스","link":"/tags/클래스/"},{"name":"인스턴스","slug":"인스턴스","link":"/tags/인스턴스/"},{"name":"var","slug":"var","link":"/tags/var/"},{"name":"let","slug":"let","link":"/tags/let/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"배열","slug":"배열","link":"/tags/배열/"}],"categories":[{"name":"러닝자바스크립트","slug":"러닝자바스크립트","link":"/categories/러닝자바스크립트/"},{"name":"ES6","slug":"ES6","link":"/categories/ES6/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"intelliJ","slug":"intelliJ","link":"/categories/intelliJ/"},{"name":"SASS/SCSS","slug":"SASS-SCSS","link":"/categories/SASS-SCSS/"},{"name":"타입스크립트","slug":"타입스크립트","link":"/categories/타입스크립트/"},{"name":"리액트 / react","slug":"리액트-react","link":"/categories/리액트-react/"}]}