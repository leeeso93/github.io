{"pages":[],"posts":[{"title":"chapter10. 맵과 셋","text":"10.1 맵 ES6 이전에는 키와 값을 연결하려면 객체를 사용해야함, 여러 단점 생성 프로토타입 체인으로 인해 의도하지 않은 연결이 생길 수 있음 객체 안에 연결된 키와 값이 몇 개인지 쉽게 알수 없음 키는 반드시 문자열이나 심볼이여야 하므로 객체를 키로 써서 값과 연결할 수 없음 객체는 프로퍼티 순서를 보장하지 않음 map123456789101112131415161718192021222324//mapconst u1= {name : 'Cynthia'};const u2= {name : 'Jackson'};const u3= {name : 'Olive'};const u4= {name : 'James'};const userRoles = new Map(); //맵 생성//set()을 사용해 사용자 역할 할당//set()은 체인으로 연결 할 수 있음userRoles .set(u1,'User') .set(u2,'User') .set(u3,'Admin');//생성자에 배열의 배열을 넘기는 형태로 써도됨const userRoles = new Map([ [u1,'User'], [u2,'User'], [u3,'Admin'],]);//u2의 role은? get();userRoles.get(u2); //\"User\" 맵에 존재하지 않은 키에 get()을 호출하면 undefined를 반환has() : 맵에 키가 존재하는지 확인 get&has12345//get()과 has()userRoles.has(u1)//trueuserRoles.get(u1) //\"User\"userRoles.has(u4) //falseuserRoles.get(u4) //undefined 맵에 이미 존재하는 키에 set()을 호출하면 값이 교체 set()으로값교체1234//set()으로 값 교체userRoles.get(u1); //\"User\"userRoles.set(u1,\"Admin\"); userRoles.get(u1); //\"Admin\" size : 맵의 요소 숫자를 반환 size1userRoles.size; //3 keys() : 맵의 키value() : 값entries() : 첫번째 요소가 키이고 두번째 요소가 값인 배열 반환 모두 for…of 루프를 사용할 수 있다. keys,value,entries1234567891011121314151617181920212223242526272829303132333435363738394041424344454647for(let u of userRoles.keys()) console.log(u.name); /* Cynthia Jackson Olive */for(let r of userRoles.values()) console.log(r); /* Admin User Admin */for(let ur of userRoles.entries()) console.log(`${ur[0].name}:${ur[1]}`); /* Cynthia:Admin Jackson:User Olive:Admin *///맵도 분해 가능 for(let [u,r] of userRoles.entries()) console.log(`${u.name}:${r}`); /* Cynthia:Admin Jackson:User Olive:Admin *///entries() 메서드는 맵의 기본 이터레이터//단축 가능합니다.for(let[u,r] of userRoles) console.log(`${u.name}:${r}`); /* Cynthia:Admin Jackson:User Olive:Admin */ delete() : 맵의 요소를 지움 delete()123//delete() :맵의 요소를 지움userRoles.delete(u2);userRoles.size //2 clear() : 맵의 모든 요소를 지움 clear()123//clear() : 맵의 모든 요소를 지움userRoles.clear();userRoles.size //0 10.2 위크맵 WeakMap은 다음 차이점을 제외하면 Map과 완전히 같다. 키는 반드시 객체여야한다. WeakMap의 키는 가비지 콜렉션에 포함 될 수 있다. WeakMap은 이터러블이 아니며 clear() 메서드도 없다. 자바스크립트 코드는 코드 어디에서 객체를 참조하는한 객체를 메모리에서 계속 유지 WeakMap은 그렇지 않으므로, 객체 인스턴스의 전용(private)한 키를 저장하기에 알맞는다. WeakMap12345678910111213141516171819//WeakMapconst SecretHolder = (function(){ const secrets = new WeakMap(); return class{ setSecret(secret){ //비밀저장 secrets.set(this, secret); } getSecret(){ //비밀호출 return secrets.get(this); } }})();const a = new SecretHolder();const b = new SecretHolder();a.setSecret('secret A');b.setSecret('secret B');a.getSecret(); //secret A IIEF 내부에서 그 인스턴스의 비밀스러운 내용을 저장할 수 있는 SecretHolder 클래스를 얻게된다. 10.3 셋 Set() : 중복을 허용하지 않는 데이터 집합 set()123456789101112const roles = new Set();roles.add(\"User\"); //사용자 역할 추가 add();roles.add(\"Admin\"); //관리자 역할 추가 add();/*Set(2) {\"User\", \"Admin\"}*/roles.size; //2 roles.delete(\"User\"); //trueroles //Set(1) {\"Admin\"}roles.delete(\"User\"); //false 10.3 위크셋 WeakSet() : 객체만 포함 할 수 있으며, 이 객체들은 가비지 콜렉션의 대상이됨 이터러블이 아님 주어진 객체가 set 안에 존재하는지 아닌지 판단하는 정도 WeakSet()123456789101112131415161718const naughty = new WeakSet();const childen = [ {name:'Suzy'}, {name : 'Derek'},];naughty.add(childen[1]); //value: {name: \"Derek\"}for(let child of childen){ if(naughty.has(child)) console.log(`Coal for ${child.name}`) else console.log(`presents for ${child.name}`)} /*presents for SuzyCoal for Derek*/","link":"/2019/07/23/chapter10/"},{"title":"chapter7. 스코프","text":"스코프 변수와 상수, 매개변수가 언제 어디서 정의되는지를 결정ex ) 함수 매개변수가 함수 바디 안에서만 존재하는 것 스코프123456//스코프function f(x){ return x + 3;}f(5); // 8x; //ReferenceError : x is not defined x가 아주 잠시나마 존재했으므로 x + 3을 계산 할 수 있었다. 그러나 함수를 벗어나면 x가 존재하지 않는 것처럼 보인다. 따라서 x의 스코프가 함수 f라고한다. 스코프 : 시야, 범위라고 이해 변수의 스코프가 어떤 함수라고 말할 때, 함수를 실제 호출할 때 까지는 함수 바디의 정해진 매개변수가 존재하지 않는다. 함수를 호출할 때마다 매개변수가 나타나고, 함수가 제어권을 반환하면 스코프 밖으로 사라진다. 변수와 상수는 만들기 전에는 존재하지 않는다. let이나 const로 선언 하기 전에는 스코프 안에서 존재하지 않는다. (var는 특수한 경우) 변수를 선언 : 식별자를 주어서 존재를 알린다.변수를 정의 : 선언과 함께 값을 부여한다.자바스크립트는 선언과 동시에 값이 주어지므로 둘을 구분하지 않는다. 7.1 스코프와 존재변수가 존재하지 않으면 그 변수는 스코프안에 ‘있지 않음’ → 그 변수는 존재하지 않는다 ?꼭 그런건 아님 스코프 : 실행 컨텍스트에서 현재 보이고 접근할 수 있는 식별자존재한다 : 그 식별자가 메모리가 할당된 무언가를 가리킴 ‘존재하지만 스코프 안에는 없는 변수의 예’ 무언가가 더 존재하지 않는다 해도 자바스크립트는 메모리를 바로 회수하는 것이 아닌, 자동적으로 가비지 콜렉션 프로세스에서 메모리를 회수 한다. 7.1 정적 스코프와 동적 스코프1234567891011function f1(){ console.log('one');}; function f2(){ console.log('two');}; f2();f1();f2(); 정적으로 보면 이 프로그램은 위에서 아래로 읽어내리지만(f1 정의-> f2정의) 실행을 하면 f2 -> f1 -> f2 자바스크립트의 스코프는 정적, 어떤 변수가 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다. 1234567891011const x = 3;function f(){ console.log(x); console.log(y);} { //새 스코프 const y = 5; f();} 1. 변수 x는 함수 f를 정의 할 때 존재하나 y는 다른 스코프에도 존재 한다. 2. 다른 스코프에서 y를 선언하고 그 스코프에서 f를 호출하더라도 f를 호출하면 x는 그 바디 안에 스코프에 있지만 y는 그렇지 않다. 3. 정적 스코프는 전역 스코프, 블록 스코프 , 함수 스코프에 적용된다. 7.3 전역 스코프스코프는 계층적이며 트리 맨아래 바탕이 되는 무언가가 있어야 한다.-&gt; 암시적으로 주어지는 스코프가 필요 이를 전역 스코프 라고 한다. 전역 스코프에서 선언한 것은 무엇이든 프로그램의 모든 스코프에서 볼 수 있다. 전역변수 : 전역 스코프에서 선언된 것 , 전역 스코프에 의존하는 걸 피해라.. 12345678910//전역 스코프, 전역변수 let name = 'lrene' //전역let age = 25; //전역 function greet(){ console.log(`hello ${name}`);}function getBirthYear(){ return new Date().getFullYear() - age;} 1. 함수가 호출하는 스코프에 대단히 의존적이다 2. name과 age의 값을 어디든지 실수로 바꿀 수 있다. 3. greet()와 getBirthYear()도 전역 변수에 의존하므로 name과 age를 정확히 사용한다는 가정에서만 쓸 수 있다. 12345678910111213//전역 스코프, 전역변수 개선ver1//단일 객체에 보관 let user = { name = 'Irene', age : 25,}; function greet(){ console.log(`hello ${name}`);}function getBirthYear(){ return new Date().getFullYear() - age;} 1. user을 써서 단일 객체에 보관 2. 그러나 아직 greet와 getBirthYear은 전역 user에 의존 123456789//전역 스코프, 전역변수 개선ver2//모든 스코프에서 호출할 수 있고, 명시적으로 user을 전달 받음 function greet(user){ console.log(`hello ${user.name}`);} function getBirthYear(user){ return new Date().getFullYear() - user.age;} 1. 모든 스코프에서 호출할 수 있고, 명시적으로 user을 전달 받음 7.4 블록 스코프 블록의 스코프안에서만 보이는 식별자let,const는 식별자를 블록 스코프에서 선언 1234567891011121314151617//블록 스코프 console.log('before block'); { console.log('inside block'); const x = 3; console.log(x);}console.log(`outside block; x = ${x}`);//결과/*before block inside block 3ReferenceError: x is not defined*/ x는 블록 안에서 정의되었고, 블록을 나가는 즉시 x도 스코프 밖으로 사라지므로 정의되지 않은 것으로 간주 7.5 변수 숨기기 다른 스코프에 있으면서 이름이 같은 변수나 상수는 혼란을 초래 1234567891011121314{ //block 1 const x = 'blue'; console.log(x); // \"blue\"}console.log(x); //ReferenceError: x is not defined { //block2 const x = 3; console.log(x) // \"3\"} console.log(typeof x); //undefined ; x는 스코프 밖에 있습니다. 변수 숨기기 12345678910111213141516//스코프 중첩 { //외부블록 let x = 'blue'; console.log(x) ; //\"blue\" { //내부블록 let x = 3; console.log(x); // \"3\" } console.log(x); //\"blue\" } console.log(typeof x); //undefined ; x는 스코프에 있지 않습니다. . 1. 내부 블록의 x와 외부블록의 x는 이름만 같은 다른 변수이다. 2. 그러므로 외부 스코프의 x를 숨기는 (가리는) 효과를 발휘 3. 실행 흐름이 내부 블록에 들어가 새 x를 정의 할 때, 두 변수가 모두 스코프 안에 있다 4. 이름이 같은 x의 경우 내부 블록에서 외부 스코프에 접근 할 방법은 없음 1234567891011121314151617{ //외부블록 let x = {color : \"blue\"}; let y = x; let z =3; { //내부블록 let x = 5; //외부블록의 x가 가려짐 console.log(x); //5 console.log(y.color)//\"blue\": y가 가리키는 외부 스코프의 x가 가리키는 객체는 모두 스코프 안에 있다. y.color = \"red\"; console.log(z) //\"3\" :z는 숨겨지지 않았다. } console.log(x.color); //\"red\" 객체가 내부스코프에서 수정됨 console.log(y.color); //\"red\"; x와 y는 같은 객체를 가리킴 console.log(z); //\"3\"} 1. 스코프는 계층적 , 이로인해 스코프 체인이란 개념이 생김 2. 스코프 체인에 있는 변수는 스코프에 있는 것이므로 숨겨지지만 않으면 접근이 가능하다. 7.6 함수, 클로저, 정적 스코프 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 경우가 많다.이를 클로저라고 한다.클로저 : 스코프를 함수 주변으로 좁히는 것 클로저예제12345678910//클로저 예제 let globalFunc; //정의되지 않은 전역함수 { let blockVar = \"a\"; globalFunc = function(){ console.log(blockVar); }} globalFunc(); //\"a\" 1. globalFunc가 블록 안에서 값을 할당 받음 2. globalFunc를 호출하면 이 함수는 스코프에서 빠져나왔어도 blockVar에 접근 할 수 있다. 3. 일반적으로 스코프를 빠져나가면 해당 스코프 안에서 선언한 변수는 메모리에서 제거해도 안전하다 4. 그러나 스코프 안에서 함수를 정의했고, 이 함수는 스코프 밖에서도 참조할 수 있으므로 자바스크립트는 스코프를 계속 유지한다. => 즉, 스코프 안에서 함수를 정의하면 해당 스코프는 더 오래 유지가 된다 . => 또한, 접근 할 수 없는 것에 접근 할 수 있게하는 효과도 있다. 123456789let f; //정의되지 않은 함수 { let o = {note : 'safe'}; f = function(){ return 0; }}let oRef = f();oRef.note = 'not so safe after all!'; 1. 일반적으로 스코프 바깥쪽에 있는 것들은 접근할 수 없다. 2. 그러나 함수를 정의해 클로저를 만들면 접근할 방법이 생긴다 . 7.7 즉시 호출하는 함수 표현식 함수 표현식을 사용하면 즉시 호출하는 함수 표현식(llEF)를 만들 수 있다.IIFE : Immediately Invoked Function Expressions, 함수를 선언하고 즉시 실행 IIEF1234//IIEF(function(){ //IIEF 바디 })(); 함수 표현식으로 익명 함수를 만들고 그 함수를 즉시 호출 IIFE는 내부에 있는 것 모두 자신의 스코프를 가지지만, IIEF가 함수이므로 스코프 밖으로 무언갈 내보낼 수 있는 장점을 가짐 12345const message =(function(){ const secret = \"I'm a secret!\"; return `The secret is ${secret.length} characters long.`;})();console.log(message);//The secret is 13 characters long. 1. 변수 secret은 IIEF 스코프 안에서 안전하게 보호되며 외부에서 접근 할 수 없다. 2. 그렇지만 IIEF는 함수이므로 무엇이든 반환할 수 있다. 12345678910const f = (function(){ let count = 0; return function(){ return `i have been called ${++count} time(s)`; }})(); f(); //i have been called 1 time(s)f(); //i have been called 2 time(s)//... 변수 count는 IIEF안에 안전하게 보관되어 있으므로 손댈 방법이 없다. f는 자신이 몇 번 호출됐는지 정확히 알고 있다. 7.8 함수 스코프와 호이스팅 letlet으로 변수를 선언하면, 그 변수는 선언하기 전에 존재하지 않는다. varvar로 선언한 변수는 현재 스코프 안이라면 어디서든 사용할 수 있으며, 선언하기 전에도 사용할 수 있다. 아직 선언되지않은 변수의 값 == 에러를 일으킴존재하되 값이 undefined인 변수 = 에러를 일으키지 않음 1234567891011121314151617//let x; //x가 정의되지 않음 let x = 3; //에러가 실행되어 멈춰서 여기에 도달할 수 없음``` &lt;pre&gt;let을 쓰면 변수를 선언하기 전에 사용하려고 할때 에러가 난다. &lt;/pre&gt;```javascript//var x;var x = 3;x; //3x; //선언(할당은 아닌)이 끌어올려 집니다. x; //undefinedvar x = 3;x; //3 1. var로 변수를 선언하면, 선언하기 전에도 사용할 수 있다. 2. var로 선언한 변수는 끌어올린다는 뜻의 호이스팅이라는 메커니즘을 따름 3. 선언만 끌어올리지며, 할당은 끌어올리지지 않는다. 123456789101112131415161718192021222324252627282930313233343536//원래코드 if(x !==3){ console.log(y); //undefined var y = 5; if(y === 5){ var x = 3; } console.log(y); //5} if(x === 3){ console.log(y); //5} //자바스크립트가 해석한 코드 var x;var y; if(x !== 3){ console.log(y); y = 5; if (y === 5){ x = 3; } console.log(y);} if(x === 3){ console.log(y);}var x = 3;if(x === 3){ var x = 2; console.log(x); //2}console.log(x); //2 1. 같은 함수나 전역 스코프 안에서는 var로 새 변수를 만들 수 없다. 2. let으로 가능 했던 변수 숨김도 불가능 3. 그렇지만 ES5로 트랜스 컴파일 해야하므로 var의 동작을 이해해야한다. 7.9 함수 호이스팅 var로 선언된 변수와 마찬가지로, 함수 선언도 스코프 맨 위로 끌어올려진다.함수를 선언하기 전에 호출 할 수 있다. 1234f(); //\"f\"function f(){ console.log(f);} 그러나, 변수에 할당한 함수 표현식은 끌어올려지지 않는다. 1234f(); //ReferrenceError : f는 정의되지 않았습니다.let f = function(){ console.log(f);}; 7.10 사각지대 let으로 선언하는 변수는 선언하기 전까지 존재하지 않는다는 직관적 개념스코프 안에서 변수의 사각지대는 변수가 선언되기 전의 코드 1234567if(typeof x ===\"undefined\"){ console.log(\"x doesn't exist or is undefined\");}else{ //x를 사용해도 안전한 코드} //결과 x doesn't exist or is undefined 해당 코드는 안전하고 에러가 발생하지 않는다. BUT, 이 코드를 let으로 바꾸면 에러가 발생 사각지대let1234567//사각지대 letif(typeof x === \"undefined\"){ console.log(\"x doesn't exist or is undefined\");}else{ //x를 사용해도 안전한 코드 }let x = 5;//Uncaught ReferenceError: Cannot access 'x' before initialization ES6에서는 typeof 연산자로 변수가 정의됐는지 확인 할 필요가 거의 없어짐 7.11 스트릭트 모드 암시적 전역변수(ES5문법) : var로 변수를 선언하는 것을 잊으면 자바스크립트는 전역 변수를 참조하려 한다고 간주하고,그런 전역변수를 스스로 생성 =&gt; 수많은 문제 생성스트릭트 모드 : 암시적 전역 변수를 허용하지 않음“use strict”를 코드 맨 앞에 씀 전역 스코프에서 스트릭트 모드를 사용하지 않는 편이 좋다 . 스트릭트모드123456(function(){ 'use strict'; //코드를 전부 이 안에서 작성합니다. //이 코드는 스트릭트 모드로 동작하지만, //이 코드와 함께 동작하는 다른 스크립트는 스트릭트 모드에 영향을 받지 않습니다.})();","link":"/2019/07/13/chapter7/"},{"title":"chapter9. 객체와 객체지향 프로그래밍","text":"9.1 프로퍼티 나열 1) 배열은 값을 가지며 각 값에는 숫자형 인덱스가 있습니다. 객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있습니다2) 배열에는 순서가 있습니다. 반면 객체는 그런 순서가 보장되지 않습니다. 9.1.1 for…in for…in : 객체 프로퍼티를 나열할 떄 123456789101112const SYM = Symbol();const o ={a:1,b:2,c:3,[SYM]:4};for(let prop in o){ if(!o.hasOwnProperty(prop)) continue; console.log(`${prop}:${o[prop]}`)}/*a:1b:2c:3*/ hasOwnProperty : for...in에 나타날 위험을 제거하기 위해 사용 for...in 루프에는 키가 심볼인 프로퍼티는 포함 안됌 9.1.2 Object.keys 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환 12345678910// 9.1.2 Object.keysconst SYM = Symbol();const o ={a:1,b:2,c:3,[SYM]:4};Object.keys(o).forEach(prop =&gt; console.log (`${prop} :${o[prop]}`));/*a:1b:2c:3*/ hasOwnProperty를 체크할 필요가 없다. 객체의 프로퍼티 키를 배열로 가져와야 할때 Object.keys가 편리하다. 9.2 객체지향 프로그래밍 OOP) 객체 : 데이터와 기능을 논리적으로 묶은 것 클래스 : 자동차처럼 추상적이고 범용적인 것 인스턴스 : 특정 자동차처럼 구체적이고 한정적인 것 메서드 : 기능 클래스 메서드 : 클래스지만 특정 인스턴스에 묶이지 않는 기능 생성자 : 인스턴스를 처음 만들 떄 생성자가 실행됨, 객체 인스턴스를 초기화함 클래스 : 운송수단서브 클래스 : 자동차, 보트, 비행기..보트 서브 클래스 : 요트, 카누,모터보트… 9.2.1 클래스와 인스턴스 생성 ES6애서 클래스를 만드는 간편한 새 문법을 도입함 클래스만들기12345class Car{ constructor(){ }} 새 클래스 Car을 만듬, 아직 인스턴스(특정 자동차)는 안만들어짐 인스턴스만들기12const car1 = new Car();const car2 = new Car(); 인스턴스를 만들 떈 new 키워드를 사용한다 instanceof123//instanceofcar1 instanceof Car //truecar1 instanceof Bus //false instanceof : 객체가 클래스인지, 인스턴스인지 확인 car1은 Car의 인스턴스이지만, Bus의 인스턴스는 아니다. 12345678910111213141516171819202122//제조사, 모델, 변속 기능 추가class Car{ constructor(make, model){ this.make = make; this.model = model; this.userGears = ['P','N','R','D']; this.userGear = this.userGears[0]; } shift(gear){ if(this.userGears.indexOf(gear)&lt;0) throw new Error('invalid gear :' `${gear}`); this.userGear = gear }}//실제 사용const car1 = new Car('Thsla','Model S');const car2 = new Car('Mazda','3i');car1.shift('D');car2.shift('R');car1.userGear //\"R\" this : 메서드를 호출한 인스턴스를 가리키는 목적 userGears : 사용할 수 있는 기어 목록 gear : 현재 기어 사용할 수 있는 첫번째 기어로 초기화 shift : 메서드(기어변속) * 실수로 기어 프로퍼티를 고치지 않도록 어느 정도 막을 수 있다. _ : 외부에서 접근하면 안돼는 프로퍼티 이름 앞에 붙이는 가짜 접근 제한 ex)_userGears 9.2.2 클래스는 함수다. ES6에서 class 키워드를 도입하기 전까지,클래스를 만드는 것은 곧 클래스 생성자로 사용될 함수를 만든다는 의미but, class는 단축 문법일 뿐이고 자바스크립트의 클래스가 바뀐 것은 아님 es5123456function Car(make,model){ this.make = make; this.model = model; this.userGears = ['P','N','R','D']; this.userGear = this.userGears[0];} es61234class Es6Car {} //생성자는 의도적으로 생략function Es5Car {}&gt; typeof Es6Car //'function'&gt; typeof Es5Car //'function' 9.2.3 프로토타입 프로토타입 메서드: 클래스의 인스턴스에서 사용할 수 있는 메서드ex) Car.prototype.shift :Car 클래스의 인스턴스에서 사용할 수 있는 shift 메서드는 프로토타입 메서드임 최근엔 메서드를 ‘#’로 표기하기도함 ex)Car#shift 클래스는 대문자로 시작하는게 관용적임 함수의 prototype 프로퍼티가 중요한 시점은 new 키워드로 새 인스턴스를 만들때 new 키워드로 만든 새 객체는 생성자 prototype 프로퍼티에 접근가능 ‘proto‘(밑줄 2개) 프로퍼티에 저장() 동적 디스패치 : 메서드 호출 prototype123456789101112131415161718192021222324252627282930313233//9.2.3 프로토타입const Car = (function(){ const carProps = new WeakMap(); class Car{ constructor(make,model){ this.make = make; this.model = model; this._userGears = ['P','N','R','D']; carProps.set(this,{userGear:this._userGears[0]}); } get userGear(){return carProps.get(this).userGear;} set userGear(value){ if(this._userGears.indexOf(value)&lt;0) throw new Error(`${value}`); carProps.get(this).userGear = value; } shift(gear){this.userGear = gear;} } return Car;})();const car1 = new Car();const car2 = new Car();car1.shift === Car.prototype.shift; //true;car1.shift('D');car1.shift('d');//error;car1.userGear; // 'D';car1.shift === car2.shift; //true;car1.shift = function(gear) {this.userGear = gear.toUpperCase();}car1.shift === Car.prototype.shift; //false 9.2.4 정적 메서드 정적 메서드 : 클래스 메서드 특정 인스턴스에 적용되지 않음 this는 인스턴스가 아니라 클래스 자체에 묶임 클래스와 관련되지만 인스턴스와 관련없는 범용적 작업에 사용ex) 자동차 식별 번호 (VIN) 붙이기 여러 인스턴스를 대상으로 하는 작업에도 사용 정적메서드123456789101112131415161718192021222324252627282930313233//areSimilar : 두 자동차의 제조사와 모델이 같으면 true 반환 메서드//areSame : 두 자동차의 VIN이 같으면 true반환 메서드class Car{ static getNextVin(){ return Car.nextVin++; //this.nextVin++이라고 써도 되지만, // Car을 앞에 쓰면 정적 메서드라는 걸 상기 } constructor(make,model){ this.make = make; this.model = model; this.vin = Car.getNextVin(); } static areSimilar(car1,car2){ return car1.make == car2.make &amp;&amp; car1.model == car2.model; } static areSame(car1,car2){ return car1.vin === car2.vin; }}Car.nextVin = 0; //초기값const car1 = new Car(\"Tesla\",\"S\");const car2 = new Car(\"Mazda\",\"3\");const car3 = new Car(\"Mazda\",\"3\");car1.vin; //0car2.vin; //1car3.vin; //2Car.areSimilar(car1,car2);//falseCar.areSimilar(car2,car3);//trueCar.areSame(car2,car3);//falseCar.areSame(car2,car2);//true 9.2.5 상속 클래스 인스턴스는 클래스의 기능을 모두 상속한다. 프로토타입 체인 : 조건에 맞는 프로토타입을 찾을 때 까지 체인을 계속 거슬러감 프로토타입을 찾지 못하면 에러를 일으킴 123456789101112131415161718192021222324252627282930313233343536//프로토타입 체인/*deployAirbags */class Vehicle { constructor(){ this.passengers = []; console.log(\"Vehicle created\"); } addPassenger(p){ this.passengers.push(p); }}class Car extends Vehicle{ constructor(){ super(); console.log(\"Car created\"); } deployAirbags(){ console.log(\"BWOOSH\"); }}const v = new Vehicle(); v.addPassenger(\"Frank\");v.addPassenger(\"Judy\");v.passengers; // [\"Frank\",\"Judy\"];const c = new Car();c.addPassenger(\"Alice\");c.addPassenger(\"Cameron\");c.passengers; //[\"Alice\",\"Cameron\"]v.deployAirbags(); //errorc.deployAirbags(); //console.log(\"BWOOSH\"); extends : Car를 Vehicle의 서브 클래스로 만듬 super() : 슈퍼클래스의 생성자 호출, 서브클래스에서는 이 함수를 반드시 호출 c 에서는 deployAirbags 호출 가능, v 에서는 error 서브클래스는 슈퍼클래스의 모든 메서드에 접근 가능 / 반대는 불가 9.2.6 다형성 다형성 : 여러 슈퍼클러스의 맴버인 인스턴스instanceOf 연산자: 객체가 클래스의 인스턴스인지 확인 다형성123456789//다형성// Vehicle : 슈퍼클래스 // Motorcycle 와 Car는 Vehicle의 서브클래스임 class Motorcycle extends Vehicle{};const c = new Car();const m = new Motorcycle();c instanceof Car; //truec instanceof Vehicle; //truem instanceof Car //false 자바스크립트의 모든 객체는 루트 클래스인 Object의 인스턴스이다 9.2.7 객체 프로퍼티 나열 다시 보기1234567891011121314151617181920212223242526272829//class Super{ constructor(){ this.name = 'Super'; this.isSuper = true; }}//유효하지만 권장xSuper.prototype.sneaky = 'not recommended';class Sub extends Super{ constructor(){ super();//서브클래스는 써줘야함 this.name = 'Sub'; this.isSub = true; }}const obj = new Sub(); for(let p in obj){ console.log(`${p} : ${obj[p]}`+ (obj.hasOwnProperty(p)? '': '(inherited)'));}/*name : SubisSuper : trueisSub : truesneaky : not recommended(inherited) */ 9.2.8 문자열 표현 toString : 객채의 기본적인 문자열 표현을 제공 9.3 다중 상속, 믹스인, 인터페이스 다중 상속 : 클래스가 슈퍼 클래스 두 개를 가지는 기능, 충돌 위험 존재인터페이스 : 다중 상속을 지원하지 않는 언어의 경우 인터페이스를 도입믹스인 : 기능을 필요한 만큼 섞은 것Symbol() : 심볼은 고유하므로, 다른 슈퍼클래스의 기능과 충돌할 가능성이 없다.","link":"/2019/07/22/chapter9/"},{"title":"chapter8. 배열과 배열 처리","text":"8.1 배열의 기초 1) 배열은 객체와 본질에서 순서가 있는 데이터 집합이며 0으로 시작하는 숫자형 인덱스를 사용합니다.2) 자바스크립트 배열은 비균질적입니다. 즉 한 배열의 요소가 모두 같은 타입일 필요는 없습니다.다른 배열이나 객체도 포함 할 수 있습니다.3) 배열 리터럴은 대괄호로 만들고, 배열 요소에 인덱스로 접근할 때도 대괄호[]를 사용합니다.4) 모든 배열에는 요소가 몇 개 있는지 나타내는 length 프로퍼티가 있습니다.5) 배열에 배열 길이보다 큰 인덱스를 사용해서 요소를 할당하면 배열은 자동으로 그 인덱스에 맞게 늘어나며,빈 자리는 undefined로 채워집니다.6) Array 생성자를 써서 배열을 만들수도 있습니다.(별로 사용하진 않음) 1234567891011121314151617181920212223242526272829303132333435363738394041//배열 리터럴const arr1 = [1,2,3]; //숫자배열const arr2 = [\"one\",2,\"three\"] //비균질적 배열const arr3 = [[1,2,3], [\"one\",2,\"three\"]]//배열을 포함한 배열const arr4 = [ //비균질적 배열 {name :\"Fred\",type :\"object\", luckyNumbers=[5,7,13] },[ {name :\"Susan\",type:\"object\"}, {name :\"Anthony\",type:\"object\"},],1,function(){return 'arrays can contain functions too'},\"three\",]; //배열 요소에 접근하기arr1[0]; //1arr1[2]; //3arr3[1] //[\"one\",2,\"three\"]arr4[1][0] //{name :\"Susan\",type:\"object\"} //배열 길이arr1.length; //3arr4.length; //5arr4[1].length //2 //배열 길이 늘리기 arr1[4] = 5; //[1, 2, 3, undefined, 5]arr1.length // 5 //배열의 현재 길이보다 큰 인덱스에 접근하는 것 만으로는 길이가 늘어나지 않음arr2[10];//undefined;arr2.length //3 //Array 생성자 const arr5 = new Array(); //빈 배열 생성 const arr6 = new Array(1,2,3) //[1,2,3]const arr7 = new Array(2) //(2) [empty × 2] 길이가 2개인 빈 배열 const arr8 = new Array(\"2\");//[\"2\"]; 8.2 배열 요소 조작 배열 메서드 중 일부는 배열 ‘자체를’ 수정하며, 다른 일부는 새 배열을 반환한다. push : 배열 자체를 수정 concat : 새 배열을 반환 8.2.1 배열의 처음이나 끝에서 요소 하나를 추가하거나 제거하기 배열의 처음 : 인덱스가 0인 요소배열의 끝 : 인덱스가 가장 큰 요소 arr.length - 1인 요소 push() : 배열의 끝에서 요소를 추가 pop() : 배열의 끝에서 요소를 제거 ※ 데이터를 수직으로 쌓아올리는 스택 stack 에 해당하는 행동 shift() : 배열의 앞에서 요소를 제거 unshift() : 베열의앞에서 요소를 추가 ※ 대기열과 비슷한 큐 stack 에 해당하는 행동 12345const arr = [\"b\",\"c\",\"d\"];arr.push(\"e\"); //arr = [\"b\",\"c\",\"d\",\"e\"];arr.pop(); // arr = [\"b\",\"c\",\"d\"];arr.unshift(\"a\"); // arr = [\"a\",\"b\",\"c\",\"d\"];arr.shift();//arr = [\"b\",\"c\",\"d\"]; 8.2.3 배열 일부 가져오기 *slice(a,b) : *배열의 일부를 가져옴 a : 어디서부터 가져올지, b : 어디까지 가져올지(바로 앞 인덱스까지) 지정 두번째 매개변수를 생략하면 배열의 마지막까지 반환음수 인덱스를 쓸수 있고, 음수 인덱스를 쓰면 배열의 끝에서부터 요소를 센다. slice12345678//sliceconst arr = [1,2,3,4,5];arr.slice(3); // [4,5]arr.slice(2,4); //[3,4]arr.slice(-2); //[4,5]arr.slice(1,-2); //[2,3]arr.slice(-2,-1); //[4]//arr는 바뀌지 않는다. 8.2.4 임의의 위치에 요소 추가하거나 제거하기 splice(a,b,c) : 배열을 수정 a : 수정을 시작할 인덱스 , b: 제거할 요소 숫자 (아무것도 제거하지 않을땐 0 ) c : 배열에 추가될 요소 splice123456//splice const arr = [1,5,7];arr.splice(1,0,2,3,4); //[1,2,3,4,5,7];arr.splice(5,0,6); //[1,2,3,4,5,6,7];arr.splice(1,2); // [1,4,5,6,7];arr.splice(2,1,\"a\",\"b\"); // [1,4,\"a\",\"b\",6,7]; 8.2.5 배열 안에서 요소 교체하기 copyWithin(a,b,c) : ES6에서 새로도입한 메서드 a : 복사한 요소를 붙여넣을 위치 b : 복사할 위치 c : 복사를 끝낼 위치 (생략가능) slice과 마찬가지로 음수 인덱스를 사용하면 배열의 끝에서 부터 센다. 12345678910111213141516171819202122//copywithinconst arr = [1,2,3,4];arr.copyWithin(1,2);//[1, 3, 4, 4]arr.copyWithin(2,0,2);//[1, 3, 1, 3]arr.copyWithin(0,-3,-1); //[3, 1, 1, 3]``` ## 8.2.6 특정 값으로 배열 채우기* **fill()**: 정해진 값으로 배열을 채움 크기를 지정해서 배열을 생성하는 Array 생성자와 아주 잘 어울림 배열의 일부만 채우려고 할때는 시작 인덱스와 끝 인덱스를 지정 음수 인덱스도 사용할 수 있다. ```javascript fill //fill const arr = new Array(5).fill(1);//[1,1,1,1,1]; arr.fill(\"a\"); // [\"a\", \"a\", \"a\", \"a\", \"a\"] arr.fill(\"b\",1);//[\"a\", \"b\", \"b\", \"b\", \"b\"] arr.fill(\"c\",2,4);//[\"a\", \"b\", \"c\", \"c\", \"b\"] arr.fill(5.5,-4); //[\"a\", 5.5, 5.5, 5.5, 5.5] arr.fill(0,-3,-1); //[\"a\", 5.5, 0, 0, 5.5] reverse() : 배열의 요소를 반대로 바꿈 sort() : sort는 배열의 요소의 순서를 정렬 (오름차순) reverse&sort1234567//reverse const arr = [1,2,3,4,5]; arr.reverse(); // [5,4,3,2,1] //sort const arr = [5,3,2,4,1]; arr.sort(); // [1,2,3,4,5]; 8.3 배열 검색 indexOf() : 찾고자 하는 것과 정확히 일치(===)하는 첫 번째 요소의 인덱스를 반환 lastIndexOf() : 배열의 끝에서부터 검색 배열의 일부분을 검색하려면 시작 인덱스를 지정 일치하는 것을 못찾으면 -1을 반환 indexOf1234567891011121314151617//indexOf const o = {name : \"Jerry\"};const arr = [1,5,\"a\",o,true,5,[1,2],\"9\"];arr.indexOf(5);//1arr.lastIndexOf(5);//5arr.indexOf(\"a\"); //2arr.lastIndexOf(\"a\"); //2arr.indexOf( {name : \"Jerry\"} ); //-1arr.indexOf(o); //3arr.indexOf([1,2]); //-1arr.indexOf(\"9\"); //7arr.indexOf(9); //-1 arr.indexOf(\"a\",5) //-1arr.indexOf(5,5) //5arr.lastIndexOf(5,4) //1arr.lastIndexOf(true,3) //-1순으로 정렬 findIndex() : 보조함수를 써서 검색 조건을 지정할 수 있다. 하지만 검색을 시작할 인덱스를 지정할 수 없고, 뒤에서 부터 찾을 수도 없다. findIndex123456findIndexconst arr = [{id : 5 , name: \"Judith\"}, {id : 7 , name: \"Francis\"}];arr.findIndex(o =&gt; o.id===5); //0arr.findIndex(o =&gt; o.name ==='Francis'); //1 arr.findIndex(o =&gt; o ===3); //-1arr.findIndex(o =&gt; o.id ===17); //-1 find() : indexOf와 findIndexOf()는 조건에 맞는 요소의 인덱스를 찾을 때 알맞지만, 요소의 인덱스가 아닌 요소 자체를 찾을때 조건에 맞는 요소가 없을 때 undefined를 반환 find123const arr = [{id : 5 , name: \"Judith\"}, {id : 7 , name: \"Francis\"}];arr.find(o =&gt; o.id===5); //{id: 5, name: \"Judith\"}arr.find(o =&gt; o.id===2); //undefined find와 findIndex에 전달하는 함수는 배열의 각 요소를 첫번째 매개변수로 받고,현재 요소의 인덱스와 배열 자체도 매개변수로 받는다. 특정 인덱스보다 뒤에 있는 제곱수를 찾아야 한다. 12const arr = [1,17,16,5,4,16,10,3,49];arr.find((x,i) =&gt; i &gt;2 &amp;&amp; Number.isInteger(Math.sqrt(x))); find와 findIndex에 전달하는 함수의 this도 수정 할 수 있다. 함수가 객체의 메서드인 것처럼 호출 할 수 있다. 간혹, 조건을 만족하는 요소의 인덱스나 요소 자체가 아닌, 단순히 조건을 만족하는 요소가 있는지 없는지만 알아도 될때 some() : 조건에 맞는 요소를 찾으면 즉시 검색을 멈추고 true 를 반환, 찾지 못하면 false를 반환 every() : 배열의 모든 요소가 조건에 맞아야 true를 반환하며, 그렇지 않으면 false를 반환 조건에 맞지 않은 요소를 찾아야만 검색을 멈추고 false를 반환 some&every123456789//someconst arr = [5,7,12,15,17];arr.some(x =&gt; x%2 ===0); //짝수 찾기 12가 짝수이므로 truearr.some(x =&gt; Number.isInteger(Math.sqrt(x))); //제곱수 false //everyconst arr = [4,6,16,36];arr.every(x =&gt; x%2 ===0); //짝수찾기 모든 요소가 짝수 true arr.every(x =&gt; Number.isInteger(Math.sqrt(x))); //false 6이 제곱수가 아님 8.4 map과 filter map(a,i) : 배열 요소를 변형 , 사본을 반환하며 원래 배열은 바뀌지 않는다. a : 요소 i :인덱스 filter() : 배열에서 필요한 것들만 남김, 사본을 반환하며 새 배열에는 필요한 요소만 남음 map&filter12345678910111213141516171819202122232425262728293031323334353637383940//mapconst cart =[{name : 'Widget',price : 9.95},{name : 'Gadget',price : 22.95}];const names = cart.map(x =&gt; x.name); // ['Widget','Gadget'];const prices = cart.map(x =&gt; x.price); // [9.95,22.95];const disCountPrices = prices.map(x =&gt; x*0.8); //[7.96,18.36]; //filterconst cards = [];for(let suit of [\"H\",\"C\",\"D\",\"S\"]) for(let value=1; value&lt;=13; value++) cards.push({suit,value}); //value가 2인 카드cards.filter(c =&gt; c.value ===2);/*[0: {suit: \"H\", value: 2}1: {suit: \"C\", value: 2}2: {suit: \"D\", value: 2}3: {suit: \"S\", value: 2}]*/ //다이아몬드cards.filter(c =&gt; c.suit ===\"D\"); //length = 13 //킹,퀸,주니어cards.filter(c =&gt; c.value &gt; 10); //length = 12 //하트의 킹,퀸,주니어cards.filter(c =&gt; c.suit ===\"H\" &amp;&amp; c.value&gt; 10); //length = 12/*[0: {suit: \"H\", value: 11}1: {suit: \"H\", value: 12}2: {suit: \"H\", value: 13}length: 3]*/ 8.5 배열의 마법 reduce reduce(a,b,i) : 배열 자체를 변형, 배열을 값 하나로 줄이는데 쓰임 a : 누적값 b: 현재값 i : 인덱스 예) 배열에 들어있는 숫자를 더하거나, 평균을 구하는 것 배열의 값을 하나로 줄이는 동작 reduce가 반환하는 값 하나는 객체일 수도 있고, 다른 배열일 수도 있다. 1. map과 filter와 마찬가지로 콜백 함수를 받는다. 2. reduce가 받는 첫 번째 매개변수는 배열이 줄어드는 대상인 어큐물레이터이다. 3. reduce는 초기값도 옵션으로 받을 수 있다. reduce12const arr = [5,7,2,4];const sum = arr.reduce((a,x)=&gt; a +=x,0); //sum =18 reduce의 콜백함수는 매개변수로 누적값 a와 현재배열요소 x를 받음 누적값 : 0 으로 시작 12const arr = [5,7,2,4];const sum = arr.reduce((a,x)=&gt; a +=x); //sum =18 위 처럼 첫번째 배열 요소가 그대로 초기값이 될 경우에는 초기값을 생략해도된다. reduce는 보통 숫자나 원시 값을 누적값으로 사용하지만, 객체 또한 누적값이 될 수 있다. 예)영단어로 이뤄진 배열이 있고, 각 단어를 첫 글자에 따라 묶는 예제 12345678910111213141516//영단어로 이뤄진 배열이 있고, 각 단어를 첫 글자에 따라 묶는 예제 const words = [\"Beachball\",\"Redeo\",\"Angel\",\"Adrdvark\",\"Xylphone\"];const alphabetical = words.reduce((a,x) =&gt; { if(!a[x[0]]) a[x[0]] =[]; a[x[0]].push(x); return a;}, {}); /*{B: Array(1), R: Array(1), A: Array(2), X: Array(1)}A: (2) [\"Angel\", \"Adrdvark\"]B: [\"Beachball\"]R: [\"Redeo\"]X: [\"Xylphone\"] */ 1. 배열의 모든 요소에서 콜백 함수는 전 단계의 결과에 이 단어의 첫번째 글자인 프로퍼티가 있는지 확인 2. 그런 프로퍼티가 없다면 빈 배열을 추가 예) 문자열을 누적값으로 사용 123456789101112const words = [\"Beachball\",\"Redeo\",\"Angel\",\"Adrdvark\",\"Xylphone\"]; const longWords = words.reduce((a,w)=&gt; w.length &gt; 6 ? a + \" \" : a ,\"\" ).trim(); //trim() : 문자열 좌우 공백제거 메서드/* longWords \"Beachball Adrdvark Xylphone\" */ 8.6 삭제되거나 정의되지 않은 요소들&gt; Array 메서드에서, 삭제되거나 정의되지 않은 요소들에서 이상하게 동작하기도 한다. map,filter,reduce는 삭제되거나 정의되지 않는 요소들에서 콜백함수를 호출하지 않는다. 123456789//삭제되거나 정의되지 않은 요소들 const arr = Array(10).map(function(x){return 5}); /*//arr//(10) [empty × 10]*///arr는 전부 undefined 123456const arr = [1,2,3,4,5];delete arr[2]; //arr : (5) [1, 2, empty, 4, 5]arr.map(x =&gt; 0); //[0,0,undefined,0,0]//(5) [0, 0, empty, 0, 0]//배열 중간 요소를 삭제하고 map을 호출하면 가운데 구멍이 생김 8.7 문자열 병합 Array.prototype.join() : 매개변수로 구분자 하나를 받고 요소들을 하나로 합친 문자열을 반환 매개변수가 생략되면 기본값은 쉼표(,) 정의되지 않은 요소, 삭제된 요소,null,undefined 모두 빈 문자열로 취급한다. 123456//문자열 병합 const arr = [1,null,\"hello\",\"world\",true,undefined];delete arr[3];arr.join(); //\"1,,hello,,true,\" arr.join(''); //\"1hellotrue\"arr.join(' -- '); //\"1 -- -- hello -- -- true -- \" *8.8 요약 * 표 8-1 배열 함수의 매개변수(순서대로) 메서드설명reduce에만 적용누적값, 초깃값 또는 마지막 호출에서 반환한 값모든 메서드요소(현재 요소의 값)모든 메서드현재 요소의 인덱스모든 메서드배열 자체(그다지 쓸모는 없음) 콜백을 받는 메서드들은 옵션으로 콜백을 호출할 때 this로 사용한 값을 받을 수 있다. 표 8-2 배열 콘텐츠 조작 하고 싶은 일사용할 메서드수정 또는 사본스택(후입 선출)을 만들때push(바뀐 길이 반환), pop배열 수정큐(선입 선출)을 만들때&nbsp;unshift(바뀐 길이 반환),shift배열 수정여러 요소를 배열 마지막에 추가할 때concat사본 반환배열 일부가 필요할 때slice사본반환임위의 위치에 요소를 추가하거나 제거splice배열 수정배열 안에서 요소를 교체copyWithin배열 수정배열을 채울 때fill배열 수정배열 반대 정렬reverse배열 수정배열 정렬sort(정렬 함수 사용 가능)배열 수정&nbsp; 표 8-3 배열 검색 찾고자 하는 것사용할 메서드요소의 인덱스indexOf(단순한 값), findIndex(복잡한 값)인덱스를 뒤에서 부터 찾을 때lastIndexOf(단순한 값)요소 자체find조건을 만족하는 요소가 들어 있는지 확인some모든 요소가 그 조건을 만족하는지 확인every 표 8-4 배열 변형 하고 싶은 일사용할 메서드수정 또는 사본배열의 모든 요소를 변형map사본 반환조건에 맞는 요소만 남김fill사본 반환배열 전체를 다른 데이터 타입으로 변형reduce사본 반환요소를 문자열로 바꿔서 하나로 합침join&nbsp;사본 반환&nbsp; [##Image|kage@FQF0t/btqwDJ8nvzH/toKJ3Ysq9UFUuAszaHgM0k/img.jpg|alignCenter|data-filename=”B2328850940_l.jpg” width=”154” height=”198”|러닝 자바스크립트##]","link":"/2019/07/15/chapter8/"}],"tags":[{"name":"map","slug":"map","link":"/tags/map/"},{"name":"set","slug":"set","link":"/tags/set/"},{"name":"스코프","slug":"스코프","link":"/tags/스코프/"},{"name":"프로퍼티","slug":"프로퍼티","link":"/tags/프로퍼티/"},{"name":"클래스","slug":"클래스","link":"/tags/클래스/"},{"name":"인스턴스","slug":"인스턴스","link":"/tags/인스턴스/"},{"name":"배열","slug":"배열","link":"/tags/배열/"}],"categories":[{"name":"러닝자바스크립트","slug":"러닝자바스크립트","link":"/categories/러닝자바스크립트/"}]}